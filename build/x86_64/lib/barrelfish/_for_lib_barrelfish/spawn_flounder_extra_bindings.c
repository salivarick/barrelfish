/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: spawn
 * INTEFACE FILE: ../if/spawn.if
 * INTERFACE DESCRIPTION: Interface to spawn domains
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for RPC
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/spawn_rpcclient_defs.h>

/*
 * RPC wrapper functions
 */
static  errval_t spawn_spawn_domain__rpc(struct spawn_rpc_client *_rpc, const char *path, const char *argvbuf, size_t argvbytes, const char *envbuf, size_t envbytes, spawn_errval_t *err, spawn_domainid_t *domain_id)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).spawn_domain_call)(_rpc->b, NOP_CONT, path, argvbuf, argvbytes, envbuf, envbytes));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct spawn_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).spawn_domain_response).err);
    *domain_id = (((_binding->rx_union).spawn_domain_response).domain_id);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t spawn_spawn_domain_with_caps__rpc(struct spawn_rpc_client *_rpc, const char *path, const char *argvbuf, size_t argvbytes, const char *envbuf, size_t envbytes, struct capref inheritcn_cap, struct capref argcn_cap, spawn_errval_t *err, spawn_domainid_t *domain_id)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).spawn_domain_with_caps_call)(_rpc->b, NOP_CONT, path, argvbuf, argvbytes, envbuf, envbytes, inheritcn_cap, argcn_cap));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct spawn_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).spawn_domain_with_caps_response).err);
    *domain_id = (((_binding->rx_union).spawn_domain_with_caps_response).domain_id);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t spawn_use_local_memserv__rpc(struct spawn_rpc_client *_rpc)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).use_local_memserv_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t spawn_kill__rpc(struct spawn_rpc_client *_rpc, spawn_domainid_t domain_id, spawn_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).kill_call)(_rpc->b, NOP_CONT, domain_id));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct spawn_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).kill_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t spawn_exit__rpc(struct spawn_rpc_client *_rpc, spawn_domainid_t domain_id, uint8_t exitcode)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).exit_call)(_rpc->b, NOP_CONT, domain_id, exitcode));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t spawn_wait__rpc(struct spawn_rpc_client *_rpc, spawn_domainid_t domain_id, bool nohang, uint8_t *exitcode, spawn_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).wait_call)(_rpc->b, NOP_CONT, domain_id, nohang));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct spawn_binding *_binding = _rpc->b;
    *exitcode = (((_binding->rx_union).wait_response).exitcode);
    *err = (((_binding->rx_union).wait_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t spawn_get_domainlist__rpc(struct spawn_rpc_client *_rpc, uint8_t **domains, size_t *len)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).get_domainlist_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct spawn_binding *_binding = _rpc->b;
    *domains = (((_binding->rx_union).get_domainlist_response).domains);
    *len = (((_binding->rx_union).get_domainlist_response).len);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t spawn_status__rpc(struct spawn_rpc_client *_rpc, spawn_domainid_t domain_id, spawn_ps_entry_t *ps_entry, char **argv, size_t *len, spawn_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).status_call)(_rpc->b, NOP_CONT, domain_id));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct spawn_binding *_binding = _rpc->b;
    *ps_entry = (((_binding->rx_union).status_response).ps_entry);
    *argv = (((_binding->rx_union).status_response).argv);
    *len = (((_binding->rx_union).status_response).len);
    *err = (((_binding->rx_union).status_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}


/*
 * Receive handlers
 */
static  void spawn_spawn_domain__rpc_rx_handler(struct spawn_binding *_binding, spawn_errval_t err, spawn_domainid_t domain_id)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).spawn_domain_response).err = err;
    ((_binding->rx_union).spawn_domain_response).domain_id = domain_id;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void spawn_spawn_domain_with_caps__rpc_rx_handler(struct spawn_binding *_binding, spawn_errval_t err, spawn_domainid_t domain_id)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).spawn_domain_with_caps_response).err = err;
    ((_binding->rx_union).spawn_domain_with_caps_response).domain_id = domain_id;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void spawn_use_local_memserv__rpc_rx_handler(struct spawn_binding *_binding)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void spawn_kill__rpc_rx_handler(struct spawn_binding *_binding, spawn_errval_t err)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).kill_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void spawn_exit__rpc_rx_handler(struct spawn_binding *_binding)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void spawn_wait__rpc_rx_handler(struct spawn_binding *_binding, uint8_t exitcode, spawn_errval_t err)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).wait_response).exitcode = exitcode;
    ((_binding->rx_union).wait_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void spawn_get_domainlist__rpc_rx_handler(struct spawn_binding *_binding, uint8_t *domains, size_t len)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).get_domainlist_response).domains = domains;
    ((_binding->rx_union).get_domainlist_response).len = len;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void spawn_status__rpc_rx_handler(struct spawn_binding *_binding, spawn_ps_entry_t ps_entry, char *argv, size_t len, spawn_errval_t err)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).status_response).ps_entry = ps_entry;
    ((_binding->rx_union).status_response).argv = argv;
    ((_binding->rx_union).status_response).len = len;
    ((_binding->rx_union).status_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}


/*
 * RPC Vtable
 */
static  struct spawn_rpc_vtbl spawn_rpc_vtbl = {
    .spawn_domain = spawn_spawn_domain__rpc,
    .spawn_domain_with_caps = spawn_spawn_domain_with_caps__rpc,
    .use_local_memserv = spawn_use_local_memserv__rpc,
    .kill = spawn_kill__rpc,
    .exit = spawn_exit__rpc,
    .wait = spawn_wait__rpc,
    .get_domainlist = spawn_get_domainlist__rpc,
    .status = spawn_status__rpc,
};

/*
 * Error handler
 */
static  void spawn_rpc_client_error(struct spawn_binding *_binding, errval_t _err)
{
    // get RPC client state pointer
    struct spawn_rpc_client *_rpc = _binding->st;
    
    if (_rpc->rpc_in_progress) {
        assert(err_is_fail(_err));
        _rpc->async_error = _err;
        // kick waitset with dummy event
        flounder_support_register(&(_rpc->rpc_waitset), &(_rpc->dummy_chanstate), dummy_event_closure, true);
    } else {
        USER_PANIC_ERR(_err, "async error in RPC");
    }
}


/*
 * Init function
 */
 errval_t spawn_rpc_client_init(struct spawn_rpc_client *rpc, struct spawn_binding *binding)
{
    errval_t _err;
    
    // Setup state of RPC client object
    rpc->b = binding;
    rpc->reply_present = false;
    rpc->rpc_in_progress = false;
    rpc->async_error = SYS_ERR_OK;
    waitset_init(&(rpc->rpc_waitset));
    flounder_support_waitset_chanstate_init(&(rpc->dummy_chanstate));
    rpc->vtbl = spawn_rpc_vtbl;
    binding->st = rpc;
    
    // Change waitset on binding
    _err = ((binding->change_waitset)(binding, &(rpc->rpc_waitset)));
    if (err_is_fail(_err)) {
        waitset_destroy(&(rpc->rpc_waitset));
        return(err_push(_err, FLOUNDER_ERR_CHANGE_WAITSET));
    }
    
    // Set RX handlers on binding object for RPCs
    (binding->rx_vtbl).spawn_domain_response = spawn_spawn_domain__rpc_rx_handler;
    (binding->rx_vtbl).spawn_domain_with_caps_response = spawn_spawn_domain_with_caps__rpc_rx_handler;
    (binding->rx_vtbl).use_local_memserv_response = spawn_use_local_memserv__rpc_rx_handler;
    (binding->rx_vtbl).kill_response = spawn_kill__rpc_rx_handler;
    (binding->rx_vtbl).exit_response = spawn_exit__rpc_rx_handler;
    (binding->rx_vtbl).wait_response = spawn_wait__rpc_rx_handler;
    (binding->rx_vtbl).get_domainlist_response = spawn_get_domainlist__rpc_rx_handler;
    (binding->rx_vtbl).status_response = spawn_status__rpc_rx_handler;
    
    // Set error handler on binding object
    binding->error_handler = spawn_rpc_client_error;
    
    return(SYS_ERR_OK);
}

