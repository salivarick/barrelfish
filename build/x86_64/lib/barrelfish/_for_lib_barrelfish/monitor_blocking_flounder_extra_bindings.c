/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: monitor_blocking
 * INTEFACE FILE: ../if/monitor_blocking.if
 * INTERFACE DESCRIPTION: The monitor to client RPC interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for LMP on x86_64
 */

#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <flounder/flounder_support_lmp.h>
#include <if/monitor_blocking_defs.h>

/*
 * Send handler functions
 */
static  void monitor_blocking_get_bootinfo_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_blocking_get_bootinfo_call__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_bootinfo_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_get_bootinfo_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, ((_binding->tx_union).get_bootinfo_response).frame, monitor_blocking_get_bootinfo_response__msgnum, ((_binding->tx_union).get_bootinfo_response).err, ((_binding->tx_union).get_bootinfo_response).frame_size);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_bootinfo_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_remote_cap_retype_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send4(&(b->chan), b->flags, ((_binding->tx_union).remote_cap_retype_call).croot, monitor_blocking_remote_cap_retype_call__msgnum | ((((uintptr_t )(((_binding->tx_union).remote_cap_retype_call).size_bits)) << 16) | (((uintptr_t )(((_binding->tx_union).remote_cap_retype_call).src)) << 24)), (((_binding->tx_union).remote_cap_retype_call).to) | (((uintptr_t )(((_binding->tx_union).remote_cap_retype_call).slot)) << 32), ((_binding->tx_union).remote_cap_retype_call).dcn_vbits, ((_binding->tx_union).remote_cap_retype_call).objtype);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_remote_cap_retype_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_remote_cap_retype_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_remote_cap_retype_response__msgnum, ((_binding->tx_union).remote_cap_retype_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_remote_cap_retype_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_remote_cap_delete_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).remote_cap_delete_call).croot, monitor_blocking_remote_cap_delete_call__msgnum | ((((uintptr_t )(((_binding->tx_union).remote_cap_delete_call).vbits)) << 16) | (((uintptr_t )(((_binding->tx_union).remote_cap_delete_call).src)) << 24)));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_remote_cap_delete_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_remote_cap_delete_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_remote_cap_delete_response__msgnum, ((_binding->tx_union).remote_cap_delete_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_remote_cap_delete_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_remote_cap_revoke_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).remote_cap_revoke_call).croot, monitor_blocking_remote_cap_revoke_call__msgnum | ((((uintptr_t )(((_binding->tx_union).remote_cap_revoke_call).vbits)) << 16) | (((uintptr_t )(((_binding->tx_union).remote_cap_revoke_call).src)) << 24)));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_remote_cap_revoke_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_remote_cap_revoke_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_remote_cap_revoke_response__msgnum, ((_binding->tx_union).remote_cap_revoke_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_remote_cap_revoke_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_get_phyaddr_cap_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_blocking_get_phyaddr_cap_call__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_phyaddr_cap_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_get_phyaddr_cap_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, ((_binding->tx_union).get_phyaddr_cap_response).pyaddr, monitor_blocking_get_phyaddr_cap_response__msgnum, ((_binding->tx_union).get_phyaddr_cap_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_phyaddr_cap_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_get_io_cap_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_blocking_get_io_cap_call__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_io_cap_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_get_io_cap_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, ((_binding->tx_union).get_io_cap_response).io, monitor_blocking_get_io_cap_response__msgnum, ((_binding->tx_union).get_io_cap_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_io_cap_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_rsrc_manifest_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), ((_binding->tx_union).rsrc_manifest_call).dispatcher, monitor_blocking_rsrc_manifest_call__msgnum);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_string(&(b->chan), b->flags, ((_binding->tx_union).rsrc_manifest_call).manifest, &(_binding->tx_str_pos), &(_binding->tx_str_len));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_rsrc_manifest_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_rsrc_manifest_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_rsrc_manifest_response__msgnum | (((uintptr_t )(((_binding->tx_union).rsrc_manifest_response).id)) << 16), ((_binding->tx_union).rsrc_manifest_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_rsrc_manifest_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_rsrc_join_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).rsrc_join_call).dispatcher, monitor_blocking_rsrc_join_call__msgnum | (((uintptr_t )(((_binding->tx_union).rsrc_join_call).id)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_rsrc_join_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_rsrc_join_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_rsrc_join_response__msgnum, ((_binding->tx_union).rsrc_join_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_rsrc_join_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_rsrc_phase_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_rsrc_phase_call__msgnum | (((uintptr_t )(((_binding->tx_union).rsrc_phase_call).id)) << 16), ((_binding->tx_union).rsrc_phase_call).phase);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_rsrc_phase_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_rsrc_phase_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_blocking_rsrc_phase_response__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_rsrc_phase_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_alloc_monitor_ep_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_blocking_alloc_monitor_ep_call__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_alloc_monitor_ep_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_alloc_monitor_ep_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, ((_binding->tx_union).alloc_monitor_ep_response).ep, monitor_blocking_alloc_monitor_ep_response__msgnum, ((_binding->tx_union).alloc_monitor_ep_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_alloc_monitor_ep_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_cap_identify_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).cap_identify_call).cap, monitor_blocking_cap_identify_call__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_cap_identify_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_cap_identify_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send6(&(b->chan), b->flags, NULL_CAP, monitor_blocking_cap_identify_response__msgnum, ((_binding->tx_union).cap_identify_response).err, (((_binding->tx_union).cap_identify_response).caprep).w0, (((_binding->tx_union).cap_identify_response).caprep).w1, (((_binding->tx_union).cap_identify_response).caprep).w2, (((_binding->tx_union).cap_identify_response).caprep).w3);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_cap_identify_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_cap_set_remote_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).cap_set_remote_call).cap, monitor_blocking_cap_set_remote_call__msgnum | (((uintptr_t )((((_binding->tx_union).cap_set_remote_call).remote) != false)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_cap_set_remote_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_cap_set_remote_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_cap_set_remote_response__msgnum, ((_binding->tx_union).cap_set_remote_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_cap_set_remote_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_irq_handle_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).irq_handle_call).ep, monitor_blocking_irq_handle_call__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_irq_handle_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_irq_handle_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_irq_handle_response__msgnum | (((uintptr_t )(((_binding->tx_union).irq_handle_response).vector)) << 16), ((_binding->tx_union).irq_handle_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_irq_handle_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_arm_irq_handle_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).arm_irq_handle_call).ep, monitor_blocking_arm_irq_handle_call__msgnum | (((uintptr_t )(((_binding->tx_union).arm_irq_handle_call).irq)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_arm_irq_handle_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_arm_irq_handle_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_arm_irq_handle_response__msgnum, ((_binding->tx_union).arm_irq_handle_response).err);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_arm_irq_handle_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_get_arch_core_id_call__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, monitor_blocking_get_arch_core_id_call__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_arch_core_id_call__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void monitor_blocking_get_arch_core_id_response__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, monitor_blocking_get_arch_core_id_response__msgnum, ((_binding->tx_union).get_arch_core_id_response).id);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = monitor_blocking_get_arch_core_id_response__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}


/*
 * Message sender functions
 */
static  errval_t monitor_blocking_get_bootinfo_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_bootinfo_call__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor_blocking.get_bootinfo_call\n");
    
    // try to send!
    monitor_blocking_get_bootinfo_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_get_bootinfo_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err, struct capref frame, size_t frame_size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_bootinfo_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_bootinfo_response).err = err;
    ((_binding->tx_union).get_bootinfo_response).frame = frame;
    ((_binding->tx_union).get_bootinfo_response).frame_size = frame_size;
    FL_DEBUG("lmp TX monitor_blocking.get_bootinfo_response\n");
    
    // try to send!
    monitor_blocking_get_bootinfo_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_remote_cap_retype_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref croot, uint32_t src, uint64_t objtype, uint8_t size_bits, uint32_t to, uint32_t slot, int32_t dcn_vbits)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_remote_cap_retype_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).remote_cap_retype_call).croot = croot;
    ((_binding->tx_union).remote_cap_retype_call).src = src;
    ((_binding->tx_union).remote_cap_retype_call).objtype = objtype;
    ((_binding->tx_union).remote_cap_retype_call).size_bits = size_bits;
    ((_binding->tx_union).remote_cap_retype_call).to = to;
    ((_binding->tx_union).remote_cap_retype_call).slot = slot;
    ((_binding->tx_union).remote_cap_retype_call).dcn_vbits = dcn_vbits;
    FL_DEBUG("lmp TX monitor_blocking.remote_cap_retype_call\n");
    
    // try to send!
    monitor_blocking_remote_cap_retype_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_remote_cap_retype_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_remote_cap_retype_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).remote_cap_retype_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.remote_cap_retype_response\n");
    
    // try to send!
    monitor_blocking_remote_cap_retype_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_remote_cap_delete_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref croot, uint32_t src, uint8_t vbits)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_remote_cap_delete_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).remote_cap_delete_call).croot = croot;
    ((_binding->tx_union).remote_cap_delete_call).src = src;
    ((_binding->tx_union).remote_cap_delete_call).vbits = vbits;
    FL_DEBUG("lmp TX monitor_blocking.remote_cap_delete_call\n");
    
    // try to send!
    monitor_blocking_remote_cap_delete_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_remote_cap_delete_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_remote_cap_delete_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).remote_cap_delete_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.remote_cap_delete_response\n");
    
    // try to send!
    monitor_blocking_remote_cap_delete_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_remote_cap_revoke_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref croot, uint32_t src, uint8_t vbits)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_remote_cap_revoke_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).remote_cap_revoke_call).croot = croot;
    ((_binding->tx_union).remote_cap_revoke_call).src = src;
    ((_binding->tx_union).remote_cap_revoke_call).vbits = vbits;
    FL_DEBUG("lmp TX monitor_blocking.remote_cap_revoke_call\n");
    
    // try to send!
    monitor_blocking_remote_cap_revoke_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_remote_cap_revoke_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_remote_cap_revoke_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).remote_cap_revoke_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.remote_cap_revoke_response\n");
    
    // try to send!
    monitor_blocking_remote_cap_revoke_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_get_phyaddr_cap_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_phyaddr_cap_call__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor_blocking.get_phyaddr_cap_call\n");
    
    // try to send!
    monitor_blocking_get_phyaddr_cap_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_get_phyaddr_cap_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref pyaddr, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_phyaddr_cap_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_phyaddr_cap_response).pyaddr = pyaddr;
    ((_binding->tx_union).get_phyaddr_cap_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.get_phyaddr_cap_response\n");
    
    // try to send!
    monitor_blocking_get_phyaddr_cap_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_get_io_cap_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_io_cap_call__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor_blocking.get_io_cap_call\n");
    
    // try to send!
    monitor_blocking_get_io_cap_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_get_io_cap_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref io, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_io_cap_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_io_cap_response).io = io;
    ((_binding->tx_union).get_io_cap_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.get_io_cap_response\n");
    
    // try to send!
    monitor_blocking_get_io_cap_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_rsrc_manifest_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref dispatcher, const char *manifest)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_rsrc_manifest_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_manifest_call).dispatcher = dispatcher;
    ((_binding->tx_union).rsrc_manifest_call).manifest = ((char *)(manifest));
    FL_DEBUG("lmp TX monitor_blocking.rsrc_manifest_call\n");
    
    // try to send!
    monitor_blocking_rsrc_manifest_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_rsrc_manifest_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_rsrcid_t id, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_rsrc_manifest_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_manifest_response).id = id;
    ((_binding->tx_union).rsrc_manifest_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.rsrc_manifest_response\n");
    
    // try to send!
    monitor_blocking_rsrc_manifest_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_rsrc_join_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_rsrcid_t id, struct capref dispatcher)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_rsrc_join_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_join_call).id = id;
    ((_binding->tx_union).rsrc_join_call).dispatcher = dispatcher;
    FL_DEBUG("lmp TX monitor_blocking.rsrc_join_call\n");
    
    // try to send!
    monitor_blocking_rsrc_join_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_rsrc_join_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_rsrc_join_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_join_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.rsrc_join_response\n");
    
    // try to send!
    monitor_blocking_rsrc_join_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_rsrc_phase_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_rsrcid_t id, uint32_t phase)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_rsrc_phase_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).rsrc_phase_call).id = id;
    ((_binding->tx_union).rsrc_phase_call).phase = phase;
    FL_DEBUG("lmp TX monitor_blocking.rsrc_phase_call\n");
    
    // try to send!
    monitor_blocking_rsrc_phase_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_rsrc_phase_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_rsrc_phase_response__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor_blocking.rsrc_phase_response\n");
    
    // try to send!
    monitor_blocking_rsrc_phase_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_alloc_monitor_ep_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_alloc_monitor_ep_call__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor_blocking.alloc_monitor_ep_call\n");
    
    // try to send!
    monitor_blocking_alloc_monitor_ep_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_alloc_monitor_ep_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err, struct capref ep)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_alloc_monitor_ep_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).alloc_monitor_ep_response).err = err;
    ((_binding->tx_union).alloc_monitor_ep_response).ep = ep;
    FL_DEBUG("lmp TX monitor_blocking.alloc_monitor_ep_response\n");
    
    // try to send!
    monitor_blocking_alloc_monitor_ep_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_cap_identify_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_cap_identify_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_identify_call).cap = cap;
    FL_DEBUG("lmp TX monitor_blocking.cap_identify_call\n");
    
    // try to send!
    monitor_blocking_cap_identify_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_cap_identify_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err, monitor_blocking_caprep_t caprep)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_cap_identify_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_identify_response).err = err;
    ((_binding->tx_union).cap_identify_response).caprep = caprep;
    FL_DEBUG("lmp TX monitor_blocking.cap_identify_response\n");
    
    // try to send!
    monitor_blocking_cap_identify_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_cap_set_remote_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref cap, bool remote)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_cap_set_remote_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_set_remote_call).cap = cap;
    ((_binding->tx_union).cap_set_remote_call).remote = remote;
    FL_DEBUG("lmp TX monitor_blocking.cap_set_remote_call\n");
    
    // try to send!
    monitor_blocking_cap_set_remote_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_cap_set_remote_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_cap_set_remote_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).cap_set_remote_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.cap_set_remote_response\n");
    
    // try to send!
    monitor_blocking_cap_set_remote_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_irq_handle_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref ep)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_irq_handle_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).irq_handle_call).ep = ep;
    FL_DEBUG("lmp TX monitor_blocking.irq_handle_call\n");
    
    // try to send!
    monitor_blocking_irq_handle_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_irq_handle_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err, uint32_t vector)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_irq_handle_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).irq_handle_response).err = err;
    ((_binding->tx_union).irq_handle_response).vector = vector;
    FL_DEBUG("lmp TX monitor_blocking.irq_handle_response\n");
    
    // try to send!
    monitor_blocking_irq_handle_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_arm_irq_handle_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, struct capref ep, uint32_t irq)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_arm_irq_handle_call__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).arm_irq_handle_call).ep = ep;
    ((_binding->tx_union).arm_irq_handle_call).irq = irq;
    FL_DEBUG("lmp TX monitor_blocking.arm_irq_handle_call\n");
    
    // try to send!
    monitor_blocking_arm_irq_handle_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_arm_irq_handle_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, monitor_blocking_errval_t err)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_arm_irq_handle_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).arm_irq_handle_response).err = err;
    FL_DEBUG("lmp TX monitor_blocking.arm_irq_handle_response\n");
    
    // try to send!
    monitor_blocking_arm_irq_handle_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_get_arch_core_id_call__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_arch_core_id_call__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX monitor_blocking.get_arch_core_id_call\n");
    
    // try to send!
    monitor_blocking_get_arch_core_id_call__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_get_arch_core_id_response__lmp_send(struct monitor_blocking_binding *_binding, struct event_closure _continuation, uintptr_t id)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = monitor_blocking_get_arch_core_id_response__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).get_arch_core_id_response).id = id;
    FL_DEBUG("lmp TX monitor_blocking.get_arch_core_id_response\n");
    
    // try to send!
    monitor_blocking_get_arch_core_id_response__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct monitor_blocking_tx_vtbl monitor_blocking_lmp_tx_vtbl = {
    .get_bootinfo_call = monitor_blocking_get_bootinfo_call__lmp_send,
    .get_bootinfo_response = monitor_blocking_get_bootinfo_response__lmp_send,
    .remote_cap_retype_call = monitor_blocking_remote_cap_retype_call__lmp_send,
    .remote_cap_retype_response = monitor_blocking_remote_cap_retype_response__lmp_send,
    .remote_cap_delete_call = monitor_blocking_remote_cap_delete_call__lmp_send,
    .remote_cap_delete_response = monitor_blocking_remote_cap_delete_response__lmp_send,
    .remote_cap_revoke_call = monitor_blocking_remote_cap_revoke_call__lmp_send,
    .remote_cap_revoke_response = monitor_blocking_remote_cap_revoke_response__lmp_send,
    .get_phyaddr_cap_call = monitor_blocking_get_phyaddr_cap_call__lmp_send,
    .get_phyaddr_cap_response = monitor_blocking_get_phyaddr_cap_response__lmp_send,
    .get_io_cap_call = monitor_blocking_get_io_cap_call__lmp_send,
    .get_io_cap_response = monitor_blocking_get_io_cap_response__lmp_send,
    .rsrc_manifest_call = monitor_blocking_rsrc_manifest_call__lmp_send,
    .rsrc_manifest_response = monitor_blocking_rsrc_manifest_response__lmp_send,
    .rsrc_join_call = monitor_blocking_rsrc_join_call__lmp_send,
    .rsrc_join_response = monitor_blocking_rsrc_join_response__lmp_send,
    .rsrc_phase_call = monitor_blocking_rsrc_phase_call__lmp_send,
    .rsrc_phase_response = monitor_blocking_rsrc_phase_response__lmp_send,
    .alloc_monitor_ep_call = monitor_blocking_alloc_monitor_ep_call__lmp_send,
    .alloc_monitor_ep_response = monitor_blocking_alloc_monitor_ep_response__lmp_send,
    .cap_identify_call = monitor_blocking_cap_identify_call__lmp_send,
    .cap_identify_response = monitor_blocking_cap_identify_response__lmp_send,
    .cap_set_remote_call = monitor_blocking_cap_set_remote_call__lmp_send,
    .cap_set_remote_response = monitor_blocking_cap_set_remote_response__lmp_send,
    .irq_handle_call = monitor_blocking_irq_handle_call__lmp_send,
    .irq_handle_response = monitor_blocking_irq_handle_response__lmp_send,
    .arm_irq_handle_call = monitor_blocking_arm_irq_handle_call__lmp_send,
    .arm_irq_handle_response = monitor_blocking_arm_irq_handle_response__lmp_send,
    .get_arch_core_id_call = monitor_blocking_get_arch_core_id_call__lmp_send,
    .get_arch_core_id_response = monitor_blocking_get_arch_core_id_response__lmp_send,
};
/*
 * Receive handler
 */
 void monitor_blocking_lmp_rx_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct monitor_blocking_binding *_binding = arg;
    struct monitor_blocking_lmp_binding *b = arg;
    errval_t err;
    
    struct lmp_recv_msg msg = LMP_RECV_MSG_INIT;
    struct capref cap;
    struct event_closure recv_closure = (struct event_closure){  .handler = monitor_blocking_lmp_rx_handler,  .arg = arg };
    
    do {
        // try to retrieve a message from the channel
        err = lmp_chan_recv(&(b->chan), &msg, &cap);
        // check if we succeeded
        if (err_is_fail(err)) {
            if (err_no(err) == LIB_ERR_NO_LMP_MSG) {
                // no message
                break;
            } else {
                // real error
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_CHAN_RECV));
                return;
            }
        }
        
        // allocate a new receive slot if needed
        if (!capref_is_null(cap)) {
            err = lmp_chan_alloc_recv_slot(&(b->chan));
            if (err_is_fail(err)) {
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT));
            }
        }
        
        // is this the start of a new message?
        if ((_binding->rx_msgnum) == 0) {
            // check message length
            if (((msg.buf).msglen) == 0) {
                (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_EMPTY_MSG);
                break;
            }
            // unmarshall message number from first word, set fragment to 0
            _binding->rx_msgnum = (((msg.words)[0]) & 0xffff);
            _binding->rx_msg_fragment = 0;
        }
        
        // switch on message number and fragment number
        switch (_binding->rx_msgnum) {
        case monitor_blocking_get_bootinfo_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor_blocking.get_bootinfo_call\n");
                assert(((_binding->rx_vtbl).get_bootinfo_call) != NULL);
                ((_binding->rx_vtbl).get_bootinfo_call)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_get_bootinfo_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_bootinfo_response).err = ((msg.words)[1]);
                ((_binding->rx_union).get_bootinfo_response).frame_size = ((msg.words)[2]);
                ((_binding->rx_union).get_bootinfo_response).frame = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.get_bootinfo_response\n");
                assert(((_binding->rx_vtbl).get_bootinfo_response) != NULL);
                ((_binding->rx_vtbl).get_bootinfo_response)(_binding, ((_binding->rx_union).get_bootinfo_response).err, ((_binding->rx_union).get_bootinfo_response).frame, ((_binding->rx_union).get_bootinfo_response).frame_size);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_remote_cap_retype_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).remote_cap_retype_call).size_bits = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).remote_cap_retype_call).src = ((((msg.words)[0]) >> 24) & 0xffffffff);
                ((_binding->rx_union).remote_cap_retype_call).to = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).remote_cap_retype_call).slot = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).remote_cap_retype_call).dcn_vbits = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).remote_cap_retype_call).objtype = ((msg.words)[3]);
                ((_binding->rx_union).remote_cap_retype_call).croot = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.remote_cap_retype_call\n");
                assert(((_binding->rx_vtbl).remote_cap_retype_call) != NULL);
                ((_binding->rx_vtbl).remote_cap_retype_call)(_binding, ((_binding->rx_union).remote_cap_retype_call).croot, ((_binding->rx_union).remote_cap_retype_call).src, ((_binding->rx_union).remote_cap_retype_call).objtype, ((_binding->rx_union).remote_cap_retype_call).size_bits, ((_binding->rx_union).remote_cap_retype_call).to, ((_binding->rx_union).remote_cap_retype_call).slot, ((_binding->rx_union).remote_cap_retype_call).dcn_vbits);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_remote_cap_retype_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).remote_cap_retype_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.remote_cap_retype_response\n");
                assert(((_binding->rx_vtbl).remote_cap_retype_response) != NULL);
                ((_binding->rx_vtbl).remote_cap_retype_response)(_binding, ((_binding->rx_union).remote_cap_retype_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_remote_cap_delete_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).remote_cap_delete_call).vbits = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).remote_cap_delete_call).src = ((((msg.words)[0]) >> 24) & 0xffffffff);
                ((_binding->rx_union).remote_cap_delete_call).croot = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.remote_cap_delete_call\n");
                assert(((_binding->rx_vtbl).remote_cap_delete_call) != NULL);
                ((_binding->rx_vtbl).remote_cap_delete_call)(_binding, ((_binding->rx_union).remote_cap_delete_call).croot, ((_binding->rx_union).remote_cap_delete_call).src, ((_binding->rx_union).remote_cap_delete_call).vbits);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_remote_cap_delete_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).remote_cap_delete_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.remote_cap_delete_response\n");
                assert(((_binding->rx_vtbl).remote_cap_delete_response) != NULL);
                ((_binding->rx_vtbl).remote_cap_delete_response)(_binding, ((_binding->rx_union).remote_cap_delete_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_remote_cap_revoke_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).remote_cap_revoke_call).vbits = ((((msg.words)[0]) >> 16) & 0xff);
                ((_binding->rx_union).remote_cap_revoke_call).src = ((((msg.words)[0]) >> 24) & 0xffffffff);
                ((_binding->rx_union).remote_cap_revoke_call).croot = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.remote_cap_revoke_call\n");
                assert(((_binding->rx_vtbl).remote_cap_revoke_call) != NULL);
                ((_binding->rx_vtbl).remote_cap_revoke_call)(_binding, ((_binding->rx_union).remote_cap_revoke_call).croot, ((_binding->rx_union).remote_cap_revoke_call).src, ((_binding->rx_union).remote_cap_revoke_call).vbits);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_remote_cap_revoke_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).remote_cap_revoke_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.remote_cap_revoke_response\n");
                assert(((_binding->rx_vtbl).remote_cap_revoke_response) != NULL);
                ((_binding->rx_vtbl).remote_cap_revoke_response)(_binding, ((_binding->rx_union).remote_cap_revoke_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_get_phyaddr_cap_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor_blocking.get_phyaddr_cap_call\n");
                assert(((_binding->rx_vtbl).get_phyaddr_cap_call) != NULL);
                ((_binding->rx_vtbl).get_phyaddr_cap_call)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_get_phyaddr_cap_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_phyaddr_cap_response).err = ((msg.words)[1]);
                ((_binding->rx_union).get_phyaddr_cap_response).pyaddr = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.get_phyaddr_cap_response\n");
                assert(((_binding->rx_vtbl).get_phyaddr_cap_response) != NULL);
                ((_binding->rx_vtbl).get_phyaddr_cap_response)(_binding, ((_binding->rx_union).get_phyaddr_cap_response).pyaddr, ((_binding->rx_union).get_phyaddr_cap_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_get_io_cap_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor_blocking.get_io_cap_call\n");
                assert(((_binding->rx_vtbl).get_io_cap_call) != NULL);
                ((_binding->rx_vtbl).get_io_cap_call)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_get_io_cap_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_io_cap_response).err = ((msg.words)[1]);
                ((_binding->rx_union).get_io_cap_response).io = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.get_io_cap_response\n");
                assert(((_binding->rx_vtbl).get_io_cap_response) != NULL);
                ((_binding->rx_vtbl).get_io_cap_response)(_binding, ((_binding->rx_union).get_io_cap_response).io, ((_binding->rx_union).get_io_cap_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_rsrc_manifest_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_manifest_call).dispatcher = cap;
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_string(&msg, &(((_binding->rx_union).rsrc_manifest_call).manifest), &(_binding->rx_str_pos), &(_binding->rx_str_len));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX monitor_blocking.rsrc_manifest_call\n");
                    assert(((_binding->rx_vtbl).rsrc_manifest_call) != NULL);
                    ((_binding->rx_vtbl).rsrc_manifest_call)(_binding, ((_binding->rx_union).rsrc_manifest_call).dispatcher, ((_binding->rx_union).rsrc_manifest_call).manifest);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_rsrc_manifest_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_manifest_response).id = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).rsrc_manifest_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.rsrc_manifest_response\n");
                assert(((_binding->rx_vtbl).rsrc_manifest_response) != NULL);
                ((_binding->rx_vtbl).rsrc_manifest_response)(_binding, ((_binding->rx_union).rsrc_manifest_response).id, ((_binding->rx_union).rsrc_manifest_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_rsrc_join_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_join_call).id = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).rsrc_join_call).dispatcher = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.rsrc_join_call\n");
                assert(((_binding->rx_vtbl).rsrc_join_call) != NULL);
                ((_binding->rx_vtbl).rsrc_join_call)(_binding, ((_binding->rx_union).rsrc_join_call).id, ((_binding->rx_union).rsrc_join_call).dispatcher);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_rsrc_join_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_join_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.rsrc_join_response\n");
                assert(((_binding->rx_vtbl).rsrc_join_response) != NULL);
                ((_binding->rx_vtbl).rsrc_join_response)(_binding, ((_binding->rx_union).rsrc_join_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_rsrc_phase_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).rsrc_phase_call).id = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).rsrc_phase_call).phase = (((msg.words)[1]) & 0xffffffff);
                
                FL_DEBUG("lmp RX monitor_blocking.rsrc_phase_call\n");
                assert(((_binding->rx_vtbl).rsrc_phase_call) != NULL);
                ((_binding->rx_vtbl).rsrc_phase_call)(_binding, ((_binding->rx_union).rsrc_phase_call).id, ((_binding->rx_union).rsrc_phase_call).phase);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_rsrc_phase_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor_blocking.rsrc_phase_response\n");
                assert(((_binding->rx_vtbl).rsrc_phase_response) != NULL);
                ((_binding->rx_vtbl).rsrc_phase_response)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_alloc_monitor_ep_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor_blocking.alloc_monitor_ep_call\n");
                assert(((_binding->rx_vtbl).alloc_monitor_ep_call) != NULL);
                ((_binding->rx_vtbl).alloc_monitor_ep_call)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_alloc_monitor_ep_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).alloc_monitor_ep_response).err = ((msg.words)[1]);
                ((_binding->rx_union).alloc_monitor_ep_response).ep = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.alloc_monitor_ep_response\n");
                assert(((_binding->rx_vtbl).alloc_monitor_ep_response) != NULL);
                ((_binding->rx_vtbl).alloc_monitor_ep_response)(_binding, ((_binding->rx_union).alloc_monitor_ep_response).err, ((_binding->rx_union).alloc_monitor_ep_response).ep);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_cap_identify_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_identify_call).cap = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.cap_identify_call\n");
                assert(((_binding->rx_vtbl).cap_identify_call) != NULL);
                ((_binding->rx_vtbl).cap_identify_call)(_binding, ((_binding->rx_union).cap_identify_call).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_cap_identify_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 6) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_identify_response).err = ((msg.words)[1]);
                (((_binding->rx_union).cap_identify_response).caprep).w0 = ((msg.words)[2]);
                (((_binding->rx_union).cap_identify_response).caprep).w1 = ((msg.words)[3]);
                (((_binding->rx_union).cap_identify_response).caprep).w2 = ((msg.words)[4]);
                (((_binding->rx_union).cap_identify_response).caprep).w3 = ((msg.words)[5]);
                
                FL_DEBUG("lmp RX monitor_blocking.cap_identify_response\n");
                assert(((_binding->rx_vtbl).cap_identify_response) != NULL);
                ((_binding->rx_vtbl).cap_identify_response)(_binding, ((_binding->rx_union).cap_identify_response).err, ((_binding->rx_union).cap_identify_response).caprep);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_cap_set_remote_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_set_remote_call).remote = ((((msg.words)[0]) >> 16) & 0x1);
                ((_binding->rx_union).cap_set_remote_call).cap = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.cap_set_remote_call\n");
                assert(((_binding->rx_vtbl).cap_set_remote_call) != NULL);
                ((_binding->rx_vtbl).cap_set_remote_call)(_binding, ((_binding->rx_union).cap_set_remote_call).cap, ((_binding->rx_union).cap_set_remote_call).remote);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_cap_set_remote_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).cap_set_remote_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.cap_set_remote_response\n");
                assert(((_binding->rx_vtbl).cap_set_remote_response) != NULL);
                ((_binding->rx_vtbl).cap_set_remote_response)(_binding, ((_binding->rx_union).cap_set_remote_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_irq_handle_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).irq_handle_call).ep = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.irq_handle_call\n");
                assert(((_binding->rx_vtbl).irq_handle_call) != NULL);
                ((_binding->rx_vtbl).irq_handle_call)(_binding, ((_binding->rx_union).irq_handle_call).ep);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_irq_handle_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).irq_handle_response).vector = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).irq_handle_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.irq_handle_response\n");
                assert(((_binding->rx_vtbl).irq_handle_response) != NULL);
                ((_binding->rx_vtbl).irq_handle_response)(_binding, ((_binding->rx_union).irq_handle_response).err, ((_binding->rx_union).irq_handle_response).vector);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_arm_irq_handle_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).arm_irq_handle_call).irq = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).arm_irq_handle_call).ep = cap;
                
                FL_DEBUG("lmp RX monitor_blocking.arm_irq_handle_call\n");
                assert(((_binding->rx_vtbl).arm_irq_handle_call) != NULL);
                ((_binding->rx_vtbl).arm_irq_handle_call)(_binding, ((_binding->rx_union).arm_irq_handle_call).ep, ((_binding->rx_union).arm_irq_handle_call).irq);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_arm_irq_handle_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).arm_irq_handle_response).err = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.arm_irq_handle_response\n");
                assert(((_binding->rx_vtbl).arm_irq_handle_response) != NULL);
                ((_binding->rx_vtbl).arm_irq_handle_response)(_binding, ((_binding->rx_union).arm_irq_handle_response).err);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_get_arch_core_id_call__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX monitor_blocking.get_arch_core_id_call\n");
                assert(((_binding->rx_vtbl).get_arch_core_id_call) != NULL);
                ((_binding->rx_vtbl).get_arch_core_id_call)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case monitor_blocking_get_arch_core_id_response__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).get_arch_core_id_response).id = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX monitor_blocking.get_arch_core_id_response\n");
                assert(((_binding->rx_vtbl).get_arch_core_id_response) != NULL);
                ((_binding->rx_vtbl).get_arch_core_id_response)(_binding, ((_binding->rx_union).get_arch_core_id_response).id);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        default:
            (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_MSGNUM);
            goto out;
        }
    } while (err_is_ok(err));
    out:
    // re-register for another receive notification
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, recv_closure);
    assert(err_is_ok(err));
}


/*
 * Control functions
 */
static  bool monitor_blocking_lmp_can_send(struct monitor_blocking_binding *b)
{
    return((b->tx_msgnum) == 0);
}

static  errval_t monitor_blocking_lmp_register_send(struct monitor_blocking_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(flounder_support_register(ws, &(b->register_chanstate), _continuation, monitor_blocking_lmp_can_send(b)));
}

static  void monitor_blocking_lmp_default_error_handler(struct monitor_blocking_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated monitor_blocking lmp binding (default handler)");
    abort();
}

static  errval_t monitor_blocking_lmp_change_waitset(struct monitor_blocking_binding *_binding, struct waitset *ws)
{
    struct monitor_blocking_lmp_binding *b = (void *)(_binding);
    
    // Migrate register and TX continuation notifications
    flounder_support_migrate_notify(&(_binding->register_chanstate), ws);
    flounder_support_migrate_notify(&(_binding->tx_cont_chanstate), ws);
    
    // change waitset on binding
    _binding->waitset = ws;
    
    // Migrate send and receive notifications
    lmp_chan_migrate_recv(&(b->chan), ws);
    lmp_chan_migrate_send(&(b->chan), ws);
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_blocking_lmp_control(struct monitor_blocking_binding *_binding, idc_control_t control)
{
    struct monitor_blocking_lmp_binding *b = (void *)(_binding);
    
    b->flags = idc_control_to_lmp_flags(control, b->flags);
    
    return(SYS_ERR_OK);
}

/*
 * Functions to initialise/destroy the binding state
 */
 void monitor_blocking_lmp_init(struct monitor_blocking_lmp_binding *b, struct waitset *waitset)
{
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = monitor_blocking_lmp_can_send;
    (b->b).register_send = monitor_blocking_lmp_register_send;
    (b->b).error_handler = monitor_blocking_lmp_default_error_handler;
    (b->b).tx_vtbl = monitor_blocking_lmp_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    lmp_chan_init(&(b->chan));
    (b->b).change_waitset = monitor_blocking_lmp_change_waitset;
    (b->b).control = monitor_blocking_lmp_control;
    b->flags = LMP_SEND_FLAGS_DEFAULT;
}

 void monitor_blocking_lmp_destroy(struct monitor_blocking_lmp_binding *b)
{
    flounder_support_waitset_chanstate_destroy(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_destroy(&((b->b).tx_cont_chanstate));
    lmp_chan_destroy(&(b->chan));
}


/*
 * Bind function
 */
static  void monitor_blocking_lmp_bind_continuation(void *st, errval_t err, struct lmp_chan *chan)
{
    struct monitor_blocking_lmp_binding *b = st;
    
    if (err_is_ok(err)) {
        // allocate a cap receive slot
        err = lmp_chan_alloc_recv_slot(chan);
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
            goto fail;
        }
        
        // register for receive
        err = lmp_chan_register_recv(chan, (b->b).waitset, (struct event_closure){  .handler = monitor_blocking_lmp_rx_handler,  .arg = b });
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
            goto fail;
        }
    } else {
        fail:
        monitor_blocking_lmp_destroy(b);
    }
    
    ((b->b).bind_cont)((b->b).st, err, &(b->b));
}

 errval_t monitor_blocking_lmp_bind(struct monitor_blocking_lmp_binding *b, iref_t iref, monitor_blocking_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags, size_t lmp_buflen)
{
    errval_t err;
    monitor_blocking_lmp_init(b, waitset);
    (b->b).st = st;
    (b->b).bind_cont = _continuation;
    err = lmp_chan_bind(&(b->chan), (struct lmp_bind_continuation){  .handler = monitor_blocking_lmp_bind_continuation,  .st = b }, &((b->b).event_qnode), iref, lmp_buflen);
    if (err_is_fail(err)) {
        monitor_blocking_lmp_destroy(b);
    }
    return(err);
}


/*
 * Connect callback for export
 */
 errval_t monitor_blocking_lmp_connect_handler(void *st, size_t buflen_words, struct capref endpoint, struct lmp_chan **retchan)
{
    struct monitor_blocking_export *e = st;
    errval_t err;
    
    // allocate storage for binding
    struct monitor_blocking_lmp_binding *b = malloc(sizeof(struct monitor_blocking_lmp_binding ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    struct monitor_blocking_binding *_binding = &(b->b);
    monitor_blocking_lmp_init(b, e->waitset);
    
    // run user's connect handler
    err = ((e->connect_cb)(e->st, _binding));
    if (err_is_fail(err)) {
        // connection refused
        monitor_blocking_lmp_destroy(b);
        return(err);
    }
    
    // accept the connection and setup the channel
    // FIXME: user policy needed to decide on the size of the message buffer?
    err = lmp_chan_accept(&(b->chan), buflen_words, endpoint);
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_CHAN_ACCEPT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // allocate a cap receive slot
    err = lmp_chan_alloc_recv_slot(&(b->chan));
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // register for receive
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, (struct event_closure){  .handler = monitor_blocking_lmp_rx_handler,  .arg = b });
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    *retchan = (&(b->chan));
    
    return(SYS_ERR_OK);
}

/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: monitor_blocking
 * INTEFACE FILE: ../if/monitor_blocking.if
 * INTERFACE DESCRIPTION: The monitor to client RPC interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for RPC
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/monitor_blocking_rpcclient_defs.h>

/*
 * RPC wrapper functions
 */
static  errval_t monitor_blocking_get_bootinfo__rpc(struct monitor_blocking_rpc_client *_rpc, monitor_blocking_errval_t *err, struct capref *frame, size_t *frame_size)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).get_bootinfo_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).get_bootinfo_response).err);
    *frame = (((_binding->rx_union).get_bootinfo_response).frame);
    *frame_size = (((_binding->rx_union).get_bootinfo_response).frame_size);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_remote_cap_retype__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref croot, uint32_t src, uint64_t objtype, uint8_t size_bits, uint32_t to, uint32_t slot, int32_t dcn_vbits, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).remote_cap_retype_call)(_rpc->b, NOP_CONT, croot, src, objtype, size_bits, to, slot, dcn_vbits));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).remote_cap_retype_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_remote_cap_delete__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref croot, uint32_t src, uint8_t vbits, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).remote_cap_delete_call)(_rpc->b, NOP_CONT, croot, src, vbits));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).remote_cap_delete_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_remote_cap_revoke__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref croot, uint32_t src, uint8_t vbits, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).remote_cap_revoke_call)(_rpc->b, NOP_CONT, croot, src, vbits));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).remote_cap_revoke_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_get_phyaddr_cap__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref *pyaddr, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).get_phyaddr_cap_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *pyaddr = (((_binding->rx_union).get_phyaddr_cap_response).pyaddr);
    *err = (((_binding->rx_union).get_phyaddr_cap_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_get_io_cap__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref *io, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).get_io_cap_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *io = (((_binding->rx_union).get_io_cap_response).io);
    *err = (((_binding->rx_union).get_io_cap_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_rsrc_manifest__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref dispatcher, const char *manifest, monitor_blocking_rsrcid_t *id, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).rsrc_manifest_call)(_rpc->b, NOP_CONT, dispatcher, manifest));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *id = (((_binding->rx_union).rsrc_manifest_response).id);
    *err = (((_binding->rx_union).rsrc_manifest_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_rsrc_join__rpc(struct monitor_blocking_rpc_client *_rpc, monitor_blocking_rsrcid_t id, struct capref dispatcher, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).rsrc_join_call)(_rpc->b, NOP_CONT, id, dispatcher));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).rsrc_join_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_rsrc_phase__rpc(struct monitor_blocking_rpc_client *_rpc, monitor_blocking_rsrcid_t id, uint32_t phase)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).rsrc_phase_call)(_rpc->b, NOP_CONT, id, phase));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_alloc_monitor_ep__rpc(struct monitor_blocking_rpc_client *_rpc, monitor_blocking_errval_t *err, struct capref *ep)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).alloc_monitor_ep_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).alloc_monitor_ep_response).err);
    *ep = (((_binding->rx_union).alloc_monitor_ep_response).ep);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_cap_identify__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref cap, monitor_blocking_errval_t *err, monitor_blocking_caprep_t *caprep)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).cap_identify_call)(_rpc->b, NOP_CONT, cap));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).cap_identify_response).err);
    *caprep = (((_binding->rx_union).cap_identify_response).caprep);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_cap_set_remote__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref cap, bool remote, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).cap_set_remote_call)(_rpc->b, NOP_CONT, cap, remote));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).cap_set_remote_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_irq_handle__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref ep, monitor_blocking_errval_t *err, uint32_t *vector)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).irq_handle_call)(_rpc->b, NOP_CONT, ep));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).irq_handle_response).err);
    *vector = (((_binding->rx_union).irq_handle_response).vector);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_arm_irq_handle__rpc(struct monitor_blocking_rpc_client *_rpc, struct capref ep, uint32_t irq, monitor_blocking_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).arm_irq_handle_call)(_rpc->b, NOP_CONT, ep, irq));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).arm_irq_handle_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t monitor_blocking_get_arch_core_id__rpc(struct monitor_blocking_rpc_client *_rpc, uintptr_t *id)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).get_arch_core_id_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct monitor_blocking_binding *_binding = _rpc->b;
    *id = (((_binding->rx_union).get_arch_core_id_response).id);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}


/*
 * Receive handlers
 */
static  void monitor_blocking_get_bootinfo__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err, struct capref frame, size_t frame_size)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).get_bootinfo_response).err = err;
    ((_binding->rx_union).get_bootinfo_response).frame = frame;
    ((_binding->rx_union).get_bootinfo_response).frame_size = frame_size;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_remote_cap_retype__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).remote_cap_retype_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_remote_cap_delete__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).remote_cap_delete_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_remote_cap_revoke__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).remote_cap_revoke_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_get_phyaddr_cap__rpc_rx_handler(struct monitor_blocking_binding *_binding, struct capref pyaddr, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).get_phyaddr_cap_response).pyaddr = pyaddr;
    ((_binding->rx_union).get_phyaddr_cap_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_get_io_cap__rpc_rx_handler(struct monitor_blocking_binding *_binding, struct capref io, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).get_io_cap_response).io = io;
    ((_binding->rx_union).get_io_cap_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_rsrc_manifest__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_rsrcid_t id, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).rsrc_manifest_response).id = id;
    ((_binding->rx_union).rsrc_manifest_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_rsrc_join__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).rsrc_join_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_rsrc_phase__rpc_rx_handler(struct monitor_blocking_binding *_binding)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_alloc_monitor_ep__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err, struct capref ep)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).alloc_monitor_ep_response).err = err;
    ((_binding->rx_union).alloc_monitor_ep_response).ep = ep;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_cap_identify__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err, monitor_blocking_caprep_t caprep)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).cap_identify_response).err = err;
    ((_binding->rx_union).cap_identify_response).caprep = caprep;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_cap_set_remote__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).cap_set_remote_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_irq_handle__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err, uint32_t vector)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).irq_handle_response).err = err;
    ((_binding->rx_union).irq_handle_response).vector = vector;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_arm_irq_handle__rpc_rx_handler(struct monitor_blocking_binding *_binding, monitor_blocking_errval_t err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).arm_irq_handle_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void monitor_blocking_get_arch_core_id__rpc_rx_handler(struct monitor_blocking_binding *_binding, uintptr_t id)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).get_arch_core_id_response).id = id;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}


/*
 * RPC Vtable
 */
static  struct monitor_blocking_rpc_vtbl monitor_blocking_rpc_vtbl = {
    .get_bootinfo = monitor_blocking_get_bootinfo__rpc,
    .remote_cap_retype = monitor_blocking_remote_cap_retype__rpc,
    .remote_cap_delete = monitor_blocking_remote_cap_delete__rpc,
    .remote_cap_revoke = monitor_blocking_remote_cap_revoke__rpc,
    .get_phyaddr_cap = monitor_blocking_get_phyaddr_cap__rpc,
    .get_io_cap = monitor_blocking_get_io_cap__rpc,
    .rsrc_manifest = monitor_blocking_rsrc_manifest__rpc,
    .rsrc_join = monitor_blocking_rsrc_join__rpc,
    .rsrc_phase = monitor_blocking_rsrc_phase__rpc,
    .alloc_monitor_ep = monitor_blocking_alloc_monitor_ep__rpc,
    .cap_identify = monitor_blocking_cap_identify__rpc,
    .cap_set_remote = monitor_blocking_cap_set_remote__rpc,
    .irq_handle = monitor_blocking_irq_handle__rpc,
    .arm_irq_handle = monitor_blocking_arm_irq_handle__rpc,
    .get_arch_core_id = monitor_blocking_get_arch_core_id__rpc,
};

/*
 * Error handler
 */
static  void monitor_blocking_rpc_client_error(struct monitor_blocking_binding *_binding, errval_t _err)
{
    // get RPC client state pointer
    struct monitor_blocking_rpc_client *_rpc = _binding->st;
    
    if (_rpc->rpc_in_progress) {
        assert(err_is_fail(_err));
        _rpc->async_error = _err;
        // kick waitset with dummy event
        flounder_support_register(&(_rpc->rpc_waitset), &(_rpc->dummy_chanstate), dummy_event_closure, true);
    } else {
        USER_PANIC_ERR(_err, "async error in RPC");
    }
}


/*
 * Init function
 */
 errval_t monitor_blocking_rpc_client_init(struct monitor_blocking_rpc_client *rpc, struct monitor_blocking_binding *binding)
{
    errval_t _err;
    
    // Setup state of RPC client object
    rpc->b = binding;
    rpc->reply_present = false;
    rpc->rpc_in_progress = false;
    rpc->async_error = SYS_ERR_OK;
    waitset_init(&(rpc->rpc_waitset));
    flounder_support_waitset_chanstate_init(&(rpc->dummy_chanstate));
    rpc->vtbl = monitor_blocking_rpc_vtbl;
    binding->st = rpc;
    
    // Change waitset on binding
    _err = ((binding->change_waitset)(binding, &(rpc->rpc_waitset)));
    if (err_is_fail(_err)) {
        waitset_destroy(&(rpc->rpc_waitset));
        return(err_push(_err, FLOUNDER_ERR_CHANGE_WAITSET));
    }
    
    // Set RX handlers on binding object for RPCs
    (binding->rx_vtbl).get_bootinfo_response = monitor_blocking_get_bootinfo__rpc_rx_handler;
    (binding->rx_vtbl).remote_cap_retype_response = monitor_blocking_remote_cap_retype__rpc_rx_handler;
    (binding->rx_vtbl).remote_cap_delete_response = monitor_blocking_remote_cap_delete__rpc_rx_handler;
    (binding->rx_vtbl).remote_cap_revoke_response = monitor_blocking_remote_cap_revoke__rpc_rx_handler;
    (binding->rx_vtbl).get_phyaddr_cap_response = monitor_blocking_get_phyaddr_cap__rpc_rx_handler;
    (binding->rx_vtbl).get_io_cap_response = monitor_blocking_get_io_cap__rpc_rx_handler;
    (binding->rx_vtbl).rsrc_manifest_response = monitor_blocking_rsrc_manifest__rpc_rx_handler;
    (binding->rx_vtbl).rsrc_join_response = monitor_blocking_rsrc_join__rpc_rx_handler;
    (binding->rx_vtbl).rsrc_phase_response = monitor_blocking_rsrc_phase__rpc_rx_handler;
    (binding->rx_vtbl).alloc_monitor_ep_response = monitor_blocking_alloc_monitor_ep__rpc_rx_handler;
    (binding->rx_vtbl).cap_identify_response = monitor_blocking_cap_identify__rpc_rx_handler;
    (binding->rx_vtbl).cap_set_remote_response = monitor_blocking_cap_set_remote__rpc_rx_handler;
    (binding->rx_vtbl).irq_handle_response = monitor_blocking_irq_handle__rpc_rx_handler;
    (binding->rx_vtbl).arm_irq_handle_response = monitor_blocking_arm_irq_handle__rpc_rx_handler;
    (binding->rx_vtbl).get_arch_core_id_response = monitor_blocking_get_arch_core_id__rpc_rx_handler;
    
    // Set error handler on binding object
    binding->error_handler = monitor_blocking_rpc_client_error;
    
    return(SYS_ERR_OK);
}

