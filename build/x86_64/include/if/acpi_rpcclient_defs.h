#ifndef __acpi_RPC_CLIENT_H
#define __acpi_RPC_CLIENT_H 1
/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: acpi
 * INTEFACE FILE: ../if/acpi.if
 * INTERFACE DESCRIPTION: acpi RPC Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * RPC client
 */

#include <if/acpi_defs.h>

/*
 * Forward declaration of binding type
 */
struct acpi_rpc_client;

/*
 * Function signatures
 */
typedef  errval_t acpi_get_pcie_confspace__rpc_method_fn(struct acpi_rpc_client *_rpc, acpi_errval_t *err, uint64_t *address, uint16_t *segment, uint8_t *startbus, uint8_t *endbus);
typedef  errval_t acpi_read_irq_table__rpc_method_fn(struct acpi_rpc_client *_rpc, const char *handle, acpi_pci_address_t addr, uint8_t bus, acpi_errval_t *error, char **child);
typedef  errval_t acpi_set_device_irq__rpc_method_fn(struct acpi_rpc_client *_rpc, const char *handle, uint32_t irq, acpi_errval_t *error);
typedef  errval_t acpi_enable_and_route_interrupt__rpc_method_fn(struct acpi_rpc_client *_rpc, uint32_t gsi, acpi_coreid_t dest, uint32_t vector, acpi_errval_t *error_code);
typedef  errval_t acpi_reset__rpc_method_fn(struct acpi_rpc_client *_rpc, acpi_errval_t *err);
typedef  errval_t acpi_sleep__rpc_method_fn(struct acpi_rpc_client *_rpc, uint32_t state, acpi_errval_t *err);
typedef  errval_t acpi_get_vbe_bios_cap__rpc_method_fn(struct acpi_rpc_client *_rpc, acpi_errval_t *err, struct capref *cap, uint32_t *size);
typedef  errval_t acpi_mm_alloc_range_proxy__rpc_method_fn(struct acpi_rpc_client *_rpc, uint8_t sizebits, uint64_t minbase, uint64_t maxlimit, struct capref *devframe, acpi_errval_t *err);
typedef  errval_t acpi_mm_free_proxy__rpc_method_fn(struct acpi_rpc_client *_rpc, struct capref devframe, uint64_t base, uint8_t sizebits, acpi_errval_t *err);

/*
 * VTable struct definition for the interface
 */
struct acpi_rpc_vtbl {
    acpi_get_pcie_confspace__rpc_method_fn *get_pcie_confspace;
    acpi_read_irq_table__rpc_method_fn *read_irq_table;
    acpi_set_device_irq__rpc_method_fn *set_device_irq;
    acpi_enable_and_route_interrupt__rpc_method_fn *enable_and_route_interrupt;
    acpi_reset__rpc_method_fn *reset;
    acpi_sleep__rpc_method_fn *sleep;
    acpi_get_vbe_bios_cap__rpc_method_fn *get_vbe_bios_cap;
    acpi_mm_alloc_range_proxy__rpc_method_fn *mm_alloc_range_proxy;
    acpi_mm_free_proxy__rpc_method_fn *mm_free_proxy;
};

/*
 * The Binding structure
 */
struct acpi_rpc_client {
    struct acpi_binding *b;
    struct acpi_rpc_vtbl vtbl;
    bool rpc_in_progress;
    bool reply_present;
    errval_t async_error;
    struct waitset rpc_waitset;
    struct waitset_chanstate dummy_chanstate;
};

/*
 * Function to initialise an RPC client
 */
extern  errval_t acpi_rpc_client_init(struct acpi_rpc_client *rpc, struct acpi_binding *binding);

#endif // __acpi_RPC_CLIENT_H
