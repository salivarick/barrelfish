#ifndef __ohci_DEV_H
#define __ohci_DEV_H 1
/*
 * DEVICE DEFINITION: OHCI USB controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) ohci ## _ ## x
/*
 * Constants defn: ohci.state (Functional state)
 *  - no width specified
 */
typedef uint8_t ohci_state_t;
#define ohci_st_reset ((ohci_state_t)0x0)
#define ohci_st_resume ((ohci_state_t)0x1)
#define ohci_st_operational ((ohci_state_t)0x2)
#define ohci_st_suspend ((ohci_state_t)0x3)

static inline char *ohci_state_describe(ohci_state_t _e) __attribute__ ((always_inline));
static inline char *ohci_state_describe(ohci_state_t _e)
{
    switch (_e) {
    case ohci_st_reset:
        return("st_reset: Reset (after h/w reset)");
    case ohci_st_resume:
        return("st_resume: Resume from downstream port");
    case ohci_st_operational:
        return("st_operational: Operational (running)");
    case ohci_st_suspend:
        return("st_suspend: Suspend (after s/w reset)");
    default:
        return(NULL);
    }
}

static inline int ohci_state_prtval(char *_s, size_t _size, ohci_state_t _e) __attribute__ ((always_inline));
static inline int ohci_state_prtval(char *_s, size_t _size, ohci_state_t _e)
{
    char *d = ohci_state_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "ohci_state_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: ohci_revision_t
 * Description: Implicit type of Revision register
 * Fields:
 *   rev	(size 8, offset 0, init 0):	RO	BCD rep. of interface version
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t ohci_revision_t;
#define ohci_revision_default 0x0
static inline uint8_t ohci_revision_rev_extract(ohci_revision_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_revision_rev_extract(ohci_revision_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline ohci_revision_t ohci_revision_rev_insert(ohci_revision_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_revision_t ohci_revision_rev_insert(ohci_revision_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((ohci_revision_t )(_fieldval)) << 0)));
}

static inline int ohci_revision_prtval(char *_s, size_t _size, ohci_revision_t _regval) __attribute__ ((always_inline));
static inline int ohci_revision_prtval(char *_s, size_t _size, ohci_revision_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev =\t%" PRIx8 "\t(BCD rep. of interface version)\n", ohci_revision_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_control_t
 * Description: Implicit type of Control register
 * Fields:
 *   cbsr	(size 2, offset 0, init 0):	RW	Control/bulk service ratio
 *   pe	(size 1, offset 2, init 0):	RW	Periodic list enable
 *   ie	(size 1, offset 3, init 0):	RW	Isochronous enable
 *   cle	(size 1, offset 4, init 0):	RW	Control list enable
 *   ble	(size 1, offset 5, init 0):	RW	Bulk list enable
 *   hcfs	(size 2, offset 6, init 0):	RW	Host controller functional state
 *   ir	(size 1, offset 8, init 0):	RW	Interrupt routing
 *   rwc	(size 1, offset 9, init 0):	RW	Remote wakeup connected
 *   rwe	(size 1, offset 10, init 0):	RW	Remote wakeup enabled
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
typedef uint32_t ohci_control_t;
#define ohci_control_default 0x0
static inline uint8_t ohci_control_cbsr_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_cbsr_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x3) >> 0));
}

static inline ohci_control_t ohci_control_cbsr_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_cbsr_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((ohci_control_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_control_pe_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_pe_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ohci_control_t ohci_control_pe_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_pe_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ohci_control_t )(_fieldval)) << 2)));
}

static inline uint8_t ohci_control_ie_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_ie_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ohci_control_t ohci_control_ie_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_ie_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ohci_control_t )(_fieldval)) << 3)));
}

static inline uint8_t ohci_control_cle_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_cle_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ohci_control_t ohci_control_cle_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_cle_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ohci_control_t )(_fieldval)) << 4)));
}

static inline uint8_t ohci_control_ble_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_ble_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ohci_control_t ohci_control_ble_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_ble_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ohci_control_t )(_fieldval)) << 5)));
}

static inline ohci_state_t ohci_control_hcfs_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline ohci_state_t ohci_control_hcfs_extract(ohci_control_t _regval)
{
    return((ohci_state_t )((_regval & 0xc0) >> 6));
}

static inline ohci_control_t ohci_control_hcfs_insert(ohci_control_t _regval, ohci_state_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_hcfs_insert(ohci_control_t _regval, ohci_state_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((ohci_control_t )(_fieldval)) << 6)));
}

static inline uint8_t ohci_control_ir_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_ir_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ohci_control_t ohci_control_ir_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_ir_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ohci_control_t )(_fieldval)) << 8)));
}

static inline uint8_t ohci_control_rwc_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_rwc_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ohci_control_t ohci_control_rwc_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_rwc_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ohci_control_t )(_fieldval)) << 9)));
}

static inline uint8_t ohci_control_rwe_extract(ohci_control_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_control_rwe_extract(ohci_control_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ohci_control_t ohci_control_rwe_insert(ohci_control_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_rwe_insert(ohci_control_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((ohci_control_t )(_fieldval)) << 10)));
}

static inline int ohci_control_prtval(char *_s, size_t _size, ohci_control_t _regval) __attribute__ ((always_inline));
static inline int ohci_control_prtval(char *_s, size_t _size, ohci_control_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cbsr =\t%" PRIx8 "\t(Control/bulk service ratio)\n", ohci_control_cbsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Periodic list enable)\n", ohci_control_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ie =\t%" PRIx8 "\t(Isochronous enable)\n", ohci_control_ie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cle =\t%" PRIx8 "\t(Control list enable)\n", ohci_control_cle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ble =\t%" PRIx8 "\t(Bulk list enable)\n", ohci_control_ble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcfs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_state_prtval(_s + _r, _avail, ohci_control_hcfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host controller functional state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ir =\t%" PRIx8 "\t(Interrupt routing)\n", ohci_control_ir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rwc =\t%" PRIx8 "\t(Remote wakeup connected)\n", ohci_control_rwc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rwe =\t%" PRIx8 "\t(Remote wakeup enabled)\n", ohci_control_rwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_cmdstatus_t
 * Description: Implicit type of 08 CommandStatus register
 * Fields:
 *   hcr	(size 1, offset 0, init 0):	RW	Host controller reset
 *   clf	(size 1, offset 1, init 0):	RW	Control list filled
 *   blf	(size 1, offset 2, init 0):	RW	Bulk list filled
 *   ocr	(size 1, offset 3, init 0):	RW	Ownership change request
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   soc	(size 2, offset 16, init 0):	RO	Scheduling overrun count
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
typedef uint32_t ohci_cmdstatus_t;
#define ohci_cmdstatus_default 0x0
static inline uint8_t ohci_cmdstatus_hcr_extract(ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_hcr_extract(ohci_cmdstatus_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ohci_cmdstatus_t ohci_cmdstatus_hcr_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_cmdstatus_t ohci_cmdstatus_hcr_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ohci_cmdstatus_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_cmdstatus_clf_extract(ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_clf_extract(ohci_cmdstatus_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ohci_cmdstatus_t ohci_cmdstatus_clf_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_cmdstatus_t ohci_cmdstatus_clf_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ohci_cmdstatus_t )(_fieldval)) << 1)));
}

static inline uint8_t ohci_cmdstatus_blf_extract(ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_blf_extract(ohci_cmdstatus_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ohci_cmdstatus_t ohci_cmdstatus_blf_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_cmdstatus_t ohci_cmdstatus_blf_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ohci_cmdstatus_t )(_fieldval)) << 2)));
}

static inline uint8_t ohci_cmdstatus_ocr_extract(ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_ocr_extract(ohci_cmdstatus_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ohci_cmdstatus_t ohci_cmdstatus_ocr_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_cmdstatus_t ohci_cmdstatus_ocr_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ohci_cmdstatus_t )(_fieldval)) << 3)));
}

static inline uint8_t ohci_cmdstatus_soc_extract(ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_soc_extract(ohci_cmdstatus_t _regval)
{
    return((uint8_t )((_regval & 0x30000) >> 16));
}

static inline ohci_cmdstatus_t ohci_cmdstatus_soc_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_cmdstatus_t ohci_cmdstatus_soc_insert(ohci_cmdstatus_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((ohci_cmdstatus_t )(_fieldval)) << 16)));
}

static inline int ohci_cmdstatus_prtval(char *_s, size_t _size, ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline int ohci_cmdstatus_prtval(char *_s, size_t _size, ohci_cmdstatus_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t%" PRIx8 "\t(Host controller reset)\n", ohci_cmdstatus_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clf =\t%" PRIx8 "\t(Control list filled)\n", ohci_cmdstatus_clf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " blf =\t%" PRIx8 "\t(Bulk list filled)\n", ohci_cmdstatus_blf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocr =\t%" PRIx8 "\t(Ownership change request)\n", ohci_cmdstatus_ocr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " soc =\t%" PRIx8 "\t(Scheduling overrun count)\n", ohci_cmdstatus_soc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_interrupt_t
 * Description: Interrupts
 * Fields:
 *   so	(size 1, offset 0, init 0):	NOATTR	Scheduling overrun
 *   wdh	(size 1, offset 1, init 0):	NOATTR	Writeback done head
 *   sf	(size 1, offset 2, init 0):	NOATTR	Start of frame
 *   rd	(size 1, offset 3, init 0):	NOATTR	Resume detected
 *   ue	(size 1, offset 4, init 0):	NOATTR	Unrecoverable error
 *   fno	(size 1, offset 5, init 0):	NOATTR	Frame number overflow
 *   rhsc	(size 1, offset 6, init 0):	NOATTR	Root hub status change
 *   _anon7	(size 23, offset 7, init 0):	RSVD	_
 *   oc	(size 1, offset 30, init 0):	NOATTR	Ownership change
 *   mie	(size 1, offset 31, init 0):	NOATTR	Master interrupt enable
 */
typedef uint32_t ohci_interrupt_t;
#define ohci_interrupt_default 0x0
static inline uint8_t ohci_interrupt_so_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_so_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ohci_interrupt_t ohci_interrupt_so_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_so_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ohci_interrupt_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_interrupt_wdh_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_wdh_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ohci_interrupt_t ohci_interrupt_wdh_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_wdh_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ohci_interrupt_t )(_fieldval)) << 1)));
}

static inline uint8_t ohci_interrupt_sf_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_sf_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ohci_interrupt_t ohci_interrupt_sf_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_sf_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ohci_interrupt_t )(_fieldval)) << 2)));
}

static inline uint8_t ohci_interrupt_rd_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_rd_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ohci_interrupt_t ohci_interrupt_rd_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_rd_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ohci_interrupt_t )(_fieldval)) << 3)));
}

static inline uint8_t ohci_interrupt_ue_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_ue_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ohci_interrupt_t ohci_interrupt_ue_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_ue_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ohci_interrupt_t )(_fieldval)) << 4)));
}

static inline uint8_t ohci_interrupt_fno_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_fno_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline ohci_interrupt_t ohci_interrupt_fno_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_fno_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((ohci_interrupt_t )(_fieldval)) << 5)));
}

static inline uint8_t ohci_interrupt_rhsc_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_rhsc_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline ohci_interrupt_t ohci_interrupt_rhsc_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_rhsc_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((ohci_interrupt_t )(_fieldval)) << 6)));
}

static inline uint8_t ohci_interrupt_oc_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_oc_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline ohci_interrupt_t ohci_interrupt_oc_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_oc_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((ohci_interrupt_t )(_fieldval)) << 30)));
}

static inline uint8_t ohci_interrupt_mie_extract(ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_interrupt_mie_extract(ohci_interrupt_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ohci_interrupt_t ohci_interrupt_mie_insert(ohci_interrupt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_interrupt_mie_insert(ohci_interrupt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ohci_interrupt_t )(_fieldval)) << 31)));
}

static inline int ohci_interrupt_prtval(char *_s, size_t _size, ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline int ohci_interrupt_prtval(char *_s, size_t _size, ohci_interrupt_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " so =\t%" PRIx8 "\t(Scheduling overrun)\n", ohci_interrupt_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdh =\t%" PRIx8 "\t(Writeback done head)\n", ohci_interrupt_wdh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sf =\t%" PRIx8 "\t(Start of frame)\n", ohci_interrupt_sf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(Resume detected)\n", ohci_interrupt_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ue =\t%" PRIx8 "\t(Unrecoverable error)\n", ohci_interrupt_ue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fno =\t%" PRIx8 "\t(Frame number overflow)\n", ohci_interrupt_fno_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhsc =\t%" PRIx8 "\t(Root hub status change)\n", ohci_interrupt_rhsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oc =\t%" PRIx8 "\t(Ownership change)\n", ohci_interrupt_oc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mie =\t%" PRIx8 "\t(Master interrupt enable)\n", ohci_interrupt_mie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_hcca_t
 * Description: Implicit type of Host controller communication area register
 * Fields:
 *   _anon0	(size 8, offset 0, init 0):	MBZ	_
 *   hcca	(size 24, offset 8, init 0):	RW	Physical address
 */
typedef uint32_t ohci_hcca_t;
#define ohci_hcca_default 0x0
static inline uint32_t ohci_hcca_hcca_extract(ohci_hcca_t _regval) __attribute__ ((always_inline));
static inline uint32_t ohci_hcca_hcca_extract(ohci_hcca_t _regval)
{
    return((uint32_t )((_regval & 0xffffff00) >> 8));
}

static inline ohci_hcca_t ohci_hcca_hcca_insert(ohci_hcca_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ohci_hcca_t ohci_hcca_hcca_insert(ohci_hcca_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xff) | (0xffffff00 & (((ohci_hcca_t )(_fieldval)) << 8)));
}

static inline int ohci_hcca_prtval(char *_s, size_t _size, ohci_hcca_t _regval) __attribute__ ((always_inline));
static inline int ohci_hcca_prtval(char *_s, size_t _size, ohci_hcca_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcca =\t%" PRIx32 "\t(Physical address)\n", ohci_hcca_hcca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_physptr_t
 * Description: Physical address pointer
 * Fields:
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   addr	(size 28, offset 4, init 0):	NOATTR	Address
 */
typedef uint32_t ohci_physptr_t;
#define ohci_physptr_default 0x0
static inline uint32_t ohci_physptr_addr_extract(ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline uint32_t ohci_physptr_addr_extract(ohci_physptr_t _regval)
{
    return((uint32_t )((_regval & 0xfffffff0) >> 4));
}

static inline ohci_physptr_t ohci_physptr_addr_insert(ohci_physptr_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_physptr_addr_insert(ohci_physptr_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xf) | (0xfffffff0 & (((ohci_physptr_t )(_fieldval)) << 4)));
}

static inline int ohci_physptr_prtval(char *_s, size_t _size, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline int ohci_physptr_prtval(char *_s, size_t _size, ohci_physptr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address)\n", ohci_physptr_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_fm_interval_t
 * Description: Implicit type of Frame interval register
 * Fields:
 *   fi	(size 14, offset 0, init 0):	RW	Frame interval (dflt 0x2edf)
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 *   fsmps	(size 15, offset 16, init 0):	RW	FS largest data packet
 *   fit	(size 1, offset 31, init 0):	RW	Frame interval toggle
 */
typedef uint32_t ohci_fm_interval_t;
#define ohci_fm_interval_default 0x0
static inline uint16_t ohci_fm_interval_fi_extract(ohci_fm_interval_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_interval_fi_extract(ohci_fm_interval_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline ohci_fm_interval_t ohci_fm_interval_fi_insert(ohci_fm_interval_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_fm_interval_t ohci_fm_interval_fi_insert(ohci_fm_interval_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((ohci_fm_interval_t )(_fieldval)) << 0)));
}

static inline uint16_t ohci_fm_interval_fsmps_extract(ohci_fm_interval_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_interval_fsmps_extract(ohci_fm_interval_t _regval)
{
    return((uint16_t )((_regval & 0x7fff0000) >> 16));
}

static inline ohci_fm_interval_t ohci_fm_interval_fsmps_insert(ohci_fm_interval_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_fm_interval_t ohci_fm_interval_fsmps_insert(ohci_fm_interval_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x8000ffff) | (0x7fff0000 & (((ohci_fm_interval_t )(_fieldval)) << 16)));
}

static inline uint8_t ohci_fm_interval_fit_extract(ohci_fm_interval_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_fm_interval_fit_extract(ohci_fm_interval_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ohci_fm_interval_t ohci_fm_interval_fit_insert(ohci_fm_interval_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_fm_interval_t ohci_fm_interval_fit_insert(ohci_fm_interval_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ohci_fm_interval_t )(_fieldval)) << 31)));
}

static inline int ohci_fm_interval_prtval(char *_s, size_t _size, ohci_fm_interval_t _regval) __attribute__ ((always_inline));
static inline int ohci_fm_interval_prtval(char *_s, size_t _size, ohci_fm_interval_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame interval (dflt 0x2edf))\n", ohci_fm_interval_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fsmps =\t%" PRIx16 "\t(FS largest data packet)\n", ohci_fm_interval_fsmps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fit =\t%" PRIx8 "\t(Frame interval toggle)\n", ohci_fm_interval_fit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_fm_remain_t
 * Description: Implicit type of Frame remaining register
 * Fields:
 *   fr	(size 14, offset 0, init 0):	RO	Bit time remaining in current frame
 *   _anon14	(size 17, offset 14, init 0):	RSVD	_
 *   frt	(size 1, offset 31, init 0):	RO	Frame remaining toggle
 */
typedef uint32_t ohci_fm_remain_t;
#define ohci_fm_remain_default 0x0
static inline uint16_t ohci_fm_remain_fr_extract(ohci_fm_remain_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_remain_fr_extract(ohci_fm_remain_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline ohci_fm_remain_t ohci_fm_remain_fr_insert(ohci_fm_remain_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_fm_remain_t ohci_fm_remain_fr_insert(ohci_fm_remain_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((ohci_fm_remain_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_fm_remain_frt_extract(ohci_fm_remain_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_fm_remain_frt_extract(ohci_fm_remain_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ohci_fm_remain_t ohci_fm_remain_frt_insert(ohci_fm_remain_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_fm_remain_t ohci_fm_remain_frt_insert(ohci_fm_remain_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ohci_fm_remain_t )(_fieldval)) << 31)));
}

static inline int ohci_fm_remain_prtval(char *_s, size_t _size, ohci_fm_remain_t _regval) __attribute__ ((always_inline));
static inline int ohci_fm_remain_prtval(char *_s, size_t _size, ohci_fm_remain_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fr =\t%" PRIx16 "\t(Bit time remaining in current frame)\n", ohci_fm_remain_fr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frt =\t%" PRIx8 "\t(Frame remaining toggle)\n", ohci_fm_remain_frt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_fm_num_t
 * Description: Implicit type of Frame number register
 * Fields:
 *   fn	(size 16, offset 0, init 0):	RO	Frame number (16-bit counter)
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t ohci_fm_num_t;
#define ohci_fm_num_default 0x0
static inline uint16_t ohci_fm_num_fn_extract(ohci_fm_num_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_num_fn_extract(ohci_fm_num_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline ohci_fm_num_t ohci_fm_num_fn_insert(ohci_fm_num_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_fm_num_t ohci_fm_num_fn_insert(ohci_fm_num_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((ohci_fm_num_t )(_fieldval)) << 0)));
}

static inline int ohci_fm_num_prtval(char *_s, size_t _size, ohci_fm_num_t _regval) __attribute__ ((always_inline));
static inline int ohci_fm_num_prtval(char *_s, size_t _size, ohci_fm_num_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fn =\t%" PRIx16 "\t(Frame number (16-bit counter))\n", ohci_fm_num_fn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_period_start_t
 * Description: Implicit type of Period start register
 * Fields:
 *   ps	(size 14, offset 0, init 0):	RW	Start time for processing periodic list
 *   _anon14	(size 18, offset 14, init 0):	RSVD	_
 */
typedef uint32_t ohci_period_start_t;
#define ohci_period_start_default 0x0
static inline uint16_t ohci_period_start_ps_extract(ohci_period_start_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_period_start_ps_extract(ohci_period_start_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline ohci_period_start_t ohci_period_start_ps_insert(ohci_period_start_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_period_start_t ohci_period_start_ps_insert(ohci_period_start_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((ohci_period_start_t )(_fieldval)) << 0)));
}

static inline int ohci_period_start_prtval(char *_s, size_t _size, ohci_period_start_t _regval) __attribute__ ((always_inline));
static inline int ohci_period_start_prtval(char *_s, size_t _size, ohci_period_start_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps =\t%" PRIx16 "\t(Start time for processing periodic list)\n", ohci_period_start_ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_hclsthreshold_t
 * Description: Implicit type of LS threshold register
 * Fields:
 *   lst	(size 11, offset 0, init 0):	RW	Low-speed threshold (should be 0x0628)
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
typedef uint32_t ohci_hclsthreshold_t;
#define ohci_hclsthreshold_default 0x0
static inline uint16_t ohci_hclsthreshold_lst_extract(ohci_hclsthreshold_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_hclsthreshold_lst_extract(ohci_hclsthreshold_t _regval)
{
    return((uint16_t )((_regval & 0x7ff) >> 0));
}

static inline ohci_hclsthreshold_t ohci_hclsthreshold_lst_insert(ohci_hclsthreshold_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_hclsthreshold_t ohci_hclsthreshold_lst_insert(ohci_hclsthreshold_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff800) | (0x7ff & (((ohci_hclsthreshold_t )(_fieldval)) << 0)));
}

static inline int ohci_hclsthreshold_prtval(char *_s, size_t _size, ohci_hclsthreshold_t _regval) __attribute__ ((always_inline));
static inline int ohci_hclsthreshold_prtval(char *_s, size_t _size, ohci_hclsthreshold_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lst =\t%" PRIx16 "\t(Low-speed threshold (should be 0x0628))\n", ohci_hclsthreshold_lst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_rh_descra_t
 * Description: Implicit type of Root hub descriptor a register
 * Fields:
 *   ndp	(size 8, offset 0, init 0):	RO	Number of downstream ports
 *   psm	(size 1, offset 8, init 0):	RW	Power switching mode
 *   nps	(size 1, offset 9, init 0):	RW	No power switching
 *   dt	(size 1, offset 10, init 0):	RO	Device type
 *   ocpm	(size 1, offset 11, init 0):	RW	Overcurrent protection mode
 *   nocp	(size 1, offset 12, init 0):	RW	No overcurrent protection
 *   _anon13	(size 11, offset 13, init 0):	RSVD	_
 *   potpgt	(size 8, offset 24, init 0):	RW	Power-on to power-good time (* 2ms)
 */
typedef uint32_t ohci_rh_descra_t;
#define ohci_rh_descra_default 0x0
static inline uint8_t ohci_rh_descra_ndp_extract(ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_ndp_extract(ohci_rh_descra_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline ohci_rh_descra_t ohci_rh_descra_ndp_insert(ohci_rh_descra_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_ndp_insert(ohci_rh_descra_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((ohci_rh_descra_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_rh_descra_psm_extract(ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_psm_extract(ohci_rh_descra_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ohci_rh_descra_t ohci_rh_descra_psm_insert(ohci_rh_descra_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_psm_insert(ohci_rh_descra_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ohci_rh_descra_t )(_fieldval)) << 8)));
}

static inline uint8_t ohci_rh_descra_nps_extract(ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_nps_extract(ohci_rh_descra_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ohci_rh_descra_t ohci_rh_descra_nps_insert(ohci_rh_descra_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_nps_insert(ohci_rh_descra_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ohci_rh_descra_t )(_fieldval)) << 9)));
}

static inline uint8_t ohci_rh_descra_dt_extract(ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_dt_extract(ohci_rh_descra_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline ohci_rh_descra_t ohci_rh_descra_dt_insert(ohci_rh_descra_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_dt_insert(ohci_rh_descra_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((ohci_rh_descra_t )(_fieldval)) << 10)));
}

static inline uint8_t ohci_rh_descra_ocpm_extract(ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_ocpm_extract(ohci_rh_descra_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline ohci_rh_descra_t ohci_rh_descra_ocpm_insert(ohci_rh_descra_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_ocpm_insert(ohci_rh_descra_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((ohci_rh_descra_t )(_fieldval)) << 11)));
}

static inline uint8_t ohci_rh_descra_nocp_extract(ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_nocp_extract(ohci_rh_descra_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline ohci_rh_descra_t ohci_rh_descra_nocp_insert(ohci_rh_descra_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_nocp_insert(ohci_rh_descra_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((ohci_rh_descra_t )(_fieldval)) << 12)));
}

static inline uint8_t ohci_rh_descra_potpgt_extract(ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_potpgt_extract(ohci_rh_descra_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline ohci_rh_descra_t ohci_rh_descra_potpgt_insert(ohci_rh_descra_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_potpgt_insert(ohci_rh_descra_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((ohci_rh_descra_t )(_fieldval)) << 24)));
}

static inline int ohci_rh_descra_prtval(char *_s, size_t _size, ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline int ohci_rh_descra_prtval(char *_s, size_t _size, ohci_rh_descra_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ndp =\t%" PRIx8 "\t(Number of downstream ports)\n", ohci_rh_descra_ndp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " psm =\t%" PRIx8 "\t(Power switching mode)\n", ohci_rh_descra_psm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nps =\t%" PRIx8 "\t(No power switching)\n", ohci_rh_descra_nps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dt =\t%" PRIx8 "\t(Device type)\n", ohci_rh_descra_dt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocpm =\t%" PRIx8 "\t(Overcurrent protection mode)\n", ohci_rh_descra_ocpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nocp =\t%" PRIx8 "\t(No overcurrent protection)\n", ohci_rh_descra_nocp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " potpgt =\t%" PRIx8 "\t(Power-on to power-good time (* 2ms))\n", ohci_rh_descra_potpgt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_rh_descrb_t
 * Description: Implicit type of Root hub descriptor b register
 * Fields:
 *   dr	(size 16, offset 0, init 0):	RW	Device removal
 *   ppcm	(size 16, offset 16, init 0):	RW	Port power control mask
 */
typedef uint32_t ohci_rh_descrb_t;
#define ohci_rh_descrb_default 0x0
static inline uint16_t ohci_rh_descrb_dr_extract(ohci_rh_descrb_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_rh_descrb_dr_extract(ohci_rh_descrb_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline ohci_rh_descrb_t ohci_rh_descrb_dr_insert(ohci_rh_descrb_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descrb_t ohci_rh_descrb_dr_insert(ohci_rh_descrb_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((ohci_rh_descrb_t )(_fieldval)) << 0)));
}

static inline uint16_t ohci_rh_descrb_ppcm_extract(ohci_rh_descrb_t _regval) __attribute__ ((always_inline));
static inline uint16_t ohci_rh_descrb_ppcm_extract(ohci_rh_descrb_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline ohci_rh_descrb_t ohci_rh_descrb_ppcm_insert(ohci_rh_descrb_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_descrb_t ohci_rh_descrb_ppcm_insert(ohci_rh_descrb_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((ohci_rh_descrb_t )(_fieldval)) << 16)));
}

static inline int ohci_rh_descrb_prtval(char *_s, size_t _size, ohci_rh_descrb_t _regval) __attribute__ ((always_inline));
static inline int ohci_rh_descrb_prtval(char *_s, size_t _size, ohci_rh_descrb_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dr =\t%" PRIx16 "\t(Device removal)\n", ohci_rh_descrb_dr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppcm =\t%" PRIx16 "\t(Port power control mask)\n", ohci_rh_descrb_ppcm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_rh_status_t
 * Description: Implicit type of Root hub status register
 * Fields:
 *   lps	(size 1, offset 0, init 0):	WO	Clear global power
 *   oci	(size 1, offset 1, init 0):	RO	Overcurrent indicator
 *   _anon2	(size 13, offset 2, init 0):	RSVD	_
 *   drwe	(size 1, offset 15, init 0):	RWC	Device remote wakeup enable
 *   lpsc	(size 1, offset 16, init 0):	WO	Set globl power
 *   ocic	(size 1, offset 17, init 0):	RWC	Overcurrent indicator change
 *   _anon18	(size 13, offset 18, init 0):	RSVD	_
 *   crwe	(size 1, offset 31, init 0):	WO	Clear remote wakeup enable
 */
typedef uint32_t ohci_rh_status_t;
#define ohci_rh_status_default 0x0
static inline uint8_t ohci_rh_status_lps_extract(ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_lps_extract(ohci_rh_status_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ohci_rh_status_t ohci_rh_status_lps_insert(ohci_rh_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_lps_insert(ohci_rh_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ohci_rh_status_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_rh_status_oci_extract(ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_oci_extract(ohci_rh_status_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ohci_rh_status_t ohci_rh_status_oci_insert(ohci_rh_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_oci_insert(ohci_rh_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ohci_rh_status_t )(_fieldval)) << 1)));
}

static inline uint8_t ohci_rh_status_drwe_extract(ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_drwe_extract(ohci_rh_status_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline ohci_rh_status_t ohci_rh_status_drwe_insert(ohci_rh_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_drwe_insert(ohci_rh_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((ohci_rh_status_t )(_fieldval)) << 15)));
}

static inline uint8_t ohci_rh_status_lpsc_extract(ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_lpsc_extract(ohci_rh_status_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ohci_rh_status_t ohci_rh_status_lpsc_insert(ohci_rh_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_lpsc_insert(ohci_rh_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ohci_rh_status_t )(_fieldval)) << 16)));
}

static inline uint8_t ohci_rh_status_ocic_extract(ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_ocic_extract(ohci_rh_status_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ohci_rh_status_t ohci_rh_status_ocic_insert(ohci_rh_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_ocic_insert(ohci_rh_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ohci_rh_status_t )(_fieldval)) << 17)));
}

static inline uint8_t ohci_rh_status_crwe_extract(ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_crwe_extract(ohci_rh_status_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline ohci_rh_status_t ohci_rh_status_crwe_insert(ohci_rh_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_crwe_insert(ohci_rh_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((ohci_rh_status_t )(_fieldval)) << 31)));
}

static inline int ohci_rh_status_prtval(char *_s, size_t _size, ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline int ohci_rh_status_prtval(char *_s, size_t _size, ohci_rh_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lps =\t%" PRIx8 "\t(Clear global power)\n", ohci_rh_status_lps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oci =\t%" PRIx8 "\t(Overcurrent indicator)\n", ohci_rh_status_oci_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drwe =\t%" PRIx8 "\t(Device remote wakeup enable)\n", ohci_rh_status_drwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpsc =\t%" PRIx8 "\t(Set globl power)\n", ohci_rh_status_lpsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocic =\t%" PRIx8 "\t(Overcurrent indicator change)\n", ohci_rh_status_ocic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crwe =\t%" PRIx8 "\t(Clear remote wakeup enable)\n", ohci_rh_status_crwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_rh_portstat_t
 * Description: Implicit type of Root hub port status register array
 * Fields:
 *   ccs	(size 1, offset 0, init 0):	NOATTR	Current connection status
 *   pes	(size 1, offset 1, init 0):	NOATTR	Port enable status
 *   pss	(size 1, offset 2, init 0):	NOATTR	Port suspend status
 *   poci	(size 1, offset 3, init 0):	NOATTR	Port overcurrent indicator
 *   prs	(size 1, offset 4, init 0):	NOATTR	Port reset status
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 *   pps	(size 1, offset 8, init 0):	NOATTR	Port power status
 *   lsda	(size 1, offset 9, init 0):	NOATTR	Low-speed device attached
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   csc	(size 1, offset 16, init 0):	NOATTR	Connect status change
 *   pesc	(size 1, offset 17, init 0):	NOATTR	Port enable status change
 *   pssc	(size 1, offset 18, init 0):	NOATTR	Port suspend status change
 *   ocic	(size 1, offset 19, init 0):	NOATTR	Port overcurrent indicator change
 *   prsc	(size 1, offset 20, init 0):	NOATTR	Port reset status change
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
typedef uint32_t ohci_rh_portstat_t;
#define ohci_rh_portstat_default 0x0
static inline uint8_t ohci_rh_portstat_ccs_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_ccs_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_ccs_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_ccs_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ohci_rh_portstat_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_rh_portstat_pes_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pes_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_pes_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_pes_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ohci_rh_portstat_t )(_fieldval)) << 1)));
}

static inline uint8_t ohci_rh_portstat_pss_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pss_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_pss_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_pss_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ohci_rh_portstat_t )(_fieldval)) << 2)));
}

static inline uint8_t ohci_rh_portstat_poci_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_poci_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_poci_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_poci_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ohci_rh_portstat_t )(_fieldval)) << 3)));
}

static inline uint8_t ohci_rh_portstat_prs_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_prs_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_prs_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_prs_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ohci_rh_portstat_t )(_fieldval)) << 4)));
}

static inline uint8_t ohci_rh_portstat_pps_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pps_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_pps_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_pps_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ohci_rh_portstat_t )(_fieldval)) << 8)));
}

static inline uint8_t ohci_rh_portstat_lsda_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_lsda_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_lsda_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_lsda_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ohci_rh_portstat_t )(_fieldval)) << 9)));
}

static inline uint8_t ohci_rh_portstat_csc_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_csc_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_csc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_csc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ohci_rh_portstat_t )(_fieldval)) << 16)));
}

static inline uint8_t ohci_rh_portstat_pesc_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pesc_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_pesc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_pesc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ohci_rh_portstat_t )(_fieldval)) << 17)));
}

static inline uint8_t ohci_rh_portstat_pssc_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pssc_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_pssc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_pssc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ohci_rh_portstat_t )(_fieldval)) << 18)));
}

static inline uint8_t ohci_rh_portstat_ocic_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_ocic_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_ocic_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_ocic_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((ohci_rh_portstat_t )(_fieldval)) << 19)));
}

static inline uint8_t ohci_rh_portstat_prsc_extract(ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_prsc_extract(ohci_rh_portstat_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_prsc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_prsc_insert(ohci_rh_portstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((ohci_rh_portstat_t )(_fieldval)) << 20)));
}

static inline int ohci_rh_portstat_prtval(char *_s, size_t _size, ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline int ohci_rh_portstat_prtval(char *_s, size_t _size, ohci_rh_portstat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current connection status)\n", ohci_rh_portstat_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pes =\t%" PRIx8 "\t(Port enable status)\n", ohci_rh_portstat_pes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t%" PRIx8 "\t(Port suspend status)\n", ohci_rh_portstat_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " poci =\t%" PRIx8 "\t(Port overcurrent indicator)\n", ohci_rh_portstat_poci_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prs =\t%" PRIx8 "\t(Port reset status)\n", ohci_rh_portstat_prs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pps =\t%" PRIx8 "\t(Port power status)\n", ohci_rh_portstat_pps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsda =\t%" PRIx8 "\t(Low-speed device attached)\n", ohci_rh_portstat_lsda_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Connect status change)\n", ohci_rh_portstat_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pesc =\t%" PRIx8 "\t(Port enable status change)\n", ohci_rh_portstat_pesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pssc =\t%" PRIx8 "\t(Port suspend status change)\n", ohci_rh_portstat_pssc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocic =\t%" PRIx8 "\t(Port overcurrent indicator change)\n", ohci_rh_portstat_ocic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prsc =\t%" PRIx8 "\t(Port reset status change)\n", ohci_rh_portstat_prsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: ohci_rh_portctrl_t
 * Description: Implicit type of Root hub port control register array
 * Fields:
 *   cpe	(size 1, offset 0, init 0):	NOATTR	Clear port enable
 *   spe	(size 1, offset 1, init 0):	NOATTR	Set port enable
 *   sps	(size 1, offset 2, init 0):	NOATTR	Set port suspend
 *   css	(size 1, offset 3, init 0):	NOATTR	Clear suspend status
 *   spr	(size 1, offset 4, init 0):	NOATTR	Set port reset
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 *   spp	(size 1, offset 8, init 0):	NOATTR	Set port power
 *   cpp	(size 1, offset 9, init 0):	NOATTR	Clear port power
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   csc	(size 1, offset 16, init 0):	NOATTR	Clear connect status change
 *   pesc	(size 1, offset 17, init 0):	NOATTR	Clear port enable status change
 *   pssc	(size 1, offset 18, init 0):	NOATTR	Clear port suspend status change
 *   ocic	(size 1, offset 19, init 0):	NOATTR	Clear port overcurrent indicator change
 *   prsc	(size 1, offset 20, init 0):	NOATTR	Clear port reset status change
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
typedef uint32_t ohci_rh_portctrl_t;
#define ohci_rh_portctrl_default 0x0
static inline uint8_t ohci_rh_portctrl_cpe_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_cpe_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_cpe_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_cpe_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((ohci_rh_portctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t ohci_rh_portctrl_spe_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_spe_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_spe_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_spe_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((ohci_rh_portctrl_t )(_fieldval)) << 1)));
}

static inline uint8_t ohci_rh_portctrl_sps_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_sps_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_sps_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_sps_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((ohci_rh_portctrl_t )(_fieldval)) << 2)));
}

static inline uint8_t ohci_rh_portctrl_css_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_css_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_css_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_css_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((ohci_rh_portctrl_t )(_fieldval)) << 3)));
}

static inline uint8_t ohci_rh_portctrl_spr_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_spr_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_spr_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_spr_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((ohci_rh_portctrl_t )(_fieldval)) << 4)));
}

static inline uint8_t ohci_rh_portctrl_spp_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_spp_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_spp_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_spp_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((ohci_rh_portctrl_t )(_fieldval)) << 8)));
}

static inline uint8_t ohci_rh_portctrl_cpp_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_cpp_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_cpp_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_cpp_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((ohci_rh_portctrl_t )(_fieldval)) << 9)));
}

static inline uint8_t ohci_rh_portctrl_csc_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_csc_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_csc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_csc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((ohci_rh_portctrl_t )(_fieldval)) << 16)));
}

static inline uint8_t ohci_rh_portctrl_pesc_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_pesc_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_pesc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_pesc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((ohci_rh_portctrl_t )(_fieldval)) << 17)));
}

static inline uint8_t ohci_rh_portctrl_pssc_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_pssc_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_pssc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_pssc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((ohci_rh_portctrl_t )(_fieldval)) << 18)));
}

static inline uint8_t ohci_rh_portctrl_ocic_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_ocic_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_ocic_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_ocic_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((ohci_rh_portctrl_t )(_fieldval)) << 19)));
}

static inline uint8_t ohci_rh_portctrl_prsc_extract(ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_prsc_extract(ohci_rh_portctrl_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_prsc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_prsc_insert(ohci_rh_portctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((ohci_rh_portctrl_t )(_fieldval)) << 20)));
}

static inline int ohci_rh_portctrl_prtval(char *_s, size_t _size, ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline int ohci_rh_portctrl_prtval(char *_s, size_t _size, ohci_rh_portctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpe =\t%" PRIx8 "\t(Clear port enable)\n", ohci_rh_portctrl_cpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spe =\t%" PRIx8 "\t(Set port enable)\n", ohci_rh_portctrl_spe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sps =\t%" PRIx8 "\t(Set port suspend)\n", ohci_rh_portctrl_sps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " css =\t%" PRIx8 "\t(Clear suspend status)\n", ohci_rh_portctrl_css_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spr =\t%" PRIx8 "\t(Set port reset)\n", ohci_rh_portctrl_spr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spp =\t%" PRIx8 "\t(Set port power)\n", ohci_rh_portctrl_spp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpp =\t%" PRIx8 "\t(Clear port power)\n", ohci_rh_portctrl_cpp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Clear connect status change)\n", ohci_rh_portctrl_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pesc =\t%" PRIx8 "\t(Clear port enable status change)\n", ohci_rh_portctrl_pesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pssc =\t%" PRIx8 "\t(Clear port suspend status change)\n", ohci_rh_portctrl_pssc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocic =\t%" PRIx8 "\t(Clear port overcurrent indicator change)\n", ohci_rh_portctrl_ocic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prsc =\t%" PRIx8 "\t(Clear port reset status change)\n", ohci_rh_portctrl_prsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    ohci_rh_status_t rh_status_shadow;
    ohci_rh_portctrl_t rh_portctrl_shadow[256];
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum ohci_initials {
    ohci_revision_initial = 0x0,
    ohci_control_initial = 0x0,
    ohci_cmdstatus_initial = 0x0,
    ohci_intstatus_initial = 0x0,
    ohci_intenable_initial = 0x0,
    ohci_intdisable_initial = 0x0,
    ohci_hcca_initial = 0x0,
    ohci_period_cur_initial = 0x0,
    ohci_ctrl_head_initial = 0x0,
    ohci_ctrl_cur_initial = 0x0,
    ohci_bulk_head_initial = 0x0,
    ohci_bulk_cur_initial = 0x0,
    ohci_done_head_initial = 0x0,
    ohci_fm_interval_initial = 0x0,
    ohci_fm_remain_initial = 0x0,
    ohci_fm_num_initial = 0x0,
    ohci_period_start_initial = 0x0,
    ohci_hclsthreshold_initial = 0x0,
    ohci_rh_descra_initial = 0x0,
    ohci_rh_descrb_initial = 0x0,
    ohci_rh_status_initial = 0x0,
    ohci_rh_portstat_initial = 0x0,
    ohci_rh_portctrl_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void ohci_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void ohci_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register revision: Revision
 * Type: ohci.revision (Implicit type of Revision register)
 *   rev	(size 8, offset 0, init 0):	RO	BCD rep. of interface version
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline ohci_revision_t ohci_revision_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_revision_t ohci_revision_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline ohci_revision_t ohci_revision_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_revision_t ohci_revision_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void ohci_revision_rawwr(__DN(t) *_dev, ohci_revision_t _regval) __attribute__ ((always_inline));
static inline void ohci_revision_rawwr(__DN(t) *_dev, ohci_revision_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

// Register revision is not writeable
static inline int ohci_revision_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_revision_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_revision_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register revision (Revision): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rev =\t%" PRIx8 "\t(BCD rep. of interface version)\n", ohci_revision_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t ohci_revision_rev_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_revision_rev_rdf(__DN(t) *_dev)
{
    ohci_revision_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(ohci_revision_rev_extract(_regval));
}

/*
 * Register control: Control
 * Type: ohci.control (Implicit type of Control register)
 *   cbsr	(size 2, offset 0, init 0):	RW	Control/bulk service ratio
 *   pe	(size 1, offset 2, init 0):	RW	Periodic list enable
 *   ie	(size 1, offset 3, init 0):	RW	Isochronous enable
 *   cle	(size 1, offset 4, init 0):	RW	Control list enable
 *   ble	(size 1, offset 5, init 0):	RW	Bulk list enable
 *   hcfs	(size 2, offset 6, init 0):	RW	Host controller functional state
 *   ir	(size 1, offset 8, init 0):	RW	Interrupt routing
 *   rwc	(size 1, offset 9, init 0):	RW	Remote wakeup connected
 *   rwe	(size 1, offset 10, init 0):	RW	Remote wakeup enabled
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
static inline ohci_control_t ohci_control_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline ohci_control_t ohci_control_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_control_t ohci_control_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void ohci_control_rawwr(__DN(t) *_dev, ohci_control_t _regval) __attribute__ ((always_inline));
static inline void ohci_control_rawwr(__DN(t) *_dev, ohci_control_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void ohci_control_wr(__DN(t) *_dev, ohci_control_t _regval) __attribute__ ((always_inline));
static inline void ohci_control_wr(__DN(t) *_dev, ohci_control_t _regval)
{
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff800 & mackerel_read_addr_32(_dev->base, 0x4)));
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int ohci_control_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_control_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register control (Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cbsr =\t%" PRIx8 "\t(Control/bulk service ratio)\n", ohci_control_cbsr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pe =\t%" PRIx8 "\t(Periodic list enable)\n", ohci_control_pe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ie =\t%" PRIx8 "\t(Isochronous enable)\n", ohci_control_ie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cle =\t%" PRIx8 "\t(Control list enable)\n", ohci_control_cle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ble =\t%" PRIx8 "\t(Bulk list enable)\n", ohci_control_ble_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcfs =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_state_prtval(_s + _r, _avail, ohci_control_hcfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Host controller functional state)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ir =\t%" PRIx8 "\t(Interrupt routing)\n", ohci_control_ir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rwc =\t%" PRIx8 "\t(Remote wakeup connected)\n", ohci_control_rwc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rwe =\t%" PRIx8 "\t(Remote wakeup enabled)\n", ohci_control_rwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t ohci_control_cbsr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_cbsr_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_cbsr_extract(_regval));
}

static inline uint8_t ohci_control_pe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_pe_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_pe_extract(_regval));
}

static inline uint8_t ohci_control_ie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_ie_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_ie_extract(_regval));
}

static inline uint8_t ohci_control_cle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_cle_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_cle_extract(_regval));
}

static inline uint8_t ohci_control_ble_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_ble_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_ble_extract(_regval));
}

static inline ohci_state_t ohci_control_hcfs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_state_t ohci_control_hcfs_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_hcfs_extract(_regval));
}

static inline uint8_t ohci_control_ir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_ir_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_ir_extract(_regval));
}

static inline uint8_t ohci_control_rwc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_rwc_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_rwc_extract(_regval));
}

static inline uint8_t ohci_control_rwe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_control_rwe_rdf(__DN(t) *_dev)
{
    ohci_control_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(ohci_control_rwe_extract(_regval));
}

static inline void ohci_control_cbsr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_cbsr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x3 & (((ohci_control_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_pe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_pe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x4 & (((ohci_control_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_ie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_ie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x8 & (((ohci_control_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_cle_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_cle_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x10 & (((ohci_control_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_ble_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_ble_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x20 & (((ohci_control_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_hcfs_wrf(__DN(t) *_dev, ohci_state_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_hcfs_wrf(__DN(t) *_dev, ohci_state_t _fieldval)
{
    ohci_control_t _regval = 0xc0 & (((ohci_control_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffff3f & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_ir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_ir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x100 & (((ohci_control_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_rwc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_rwc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x200 & (((ohci_control_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void ohci_control_rwe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_control_rwe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_control_t _regval = 0x400 & (((ohci_control_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register cmdstatus: 08 CommandStatus
 * Type: ohci.cmdstatus (Implicit type of 08 CommandStatus register)
 *   hcr	(size 1, offset 0, init 0):	RW	Host controller reset
 *   clf	(size 1, offset 1, init 0):	RW	Control list filled
 *   blf	(size 1, offset 2, init 0):	RW	Bulk list filled
 *   ocr	(size 1, offset 3, init 0):	RW	Ownership change request
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   soc	(size 2, offset 16, init 0):	RO	Scheduling overrun count
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
static inline ohci_cmdstatus_t ohci_cmdstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_cmdstatus_t ohci_cmdstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline ohci_cmdstatus_t ohci_cmdstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_cmdstatus_t ohci_cmdstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void ohci_cmdstatus_rawwr(__DN(t) *_dev, ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline void ohci_cmdstatus_rawwr(__DN(t) *_dev, ohci_cmdstatus_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline void ohci_cmdstatus_wr(__DN(t) *_dev, ohci_cmdstatus_t _regval) __attribute__ ((always_inline));
static inline void ohci_cmdstatus_wr(__DN(t) *_dev, ohci_cmdstatus_t _regval)
{
    _regval = (_regval & 0x3000f);
    // No MB1 fields present
    _regval = (_regval | (0xfffcfff0 & mackerel_read_addr_32(_dev->base, 0x8)));
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

static inline int ohci_cmdstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_cmdstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_cmdstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cmdstatus (08 CommandStatus): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcr =\t%" PRIx8 "\t(Host controller reset)\n", ohci_cmdstatus_hcr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clf =\t%" PRIx8 "\t(Control list filled)\n", ohci_cmdstatus_clf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " blf =\t%" PRIx8 "\t(Bulk list filled)\n", ohci_cmdstatus_blf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocr =\t%" PRIx8 "\t(Ownership change request)\n", ohci_cmdstatus_ocr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " soc =\t%" PRIx8 "\t(Scheduling overrun count)\n", ohci_cmdstatus_soc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline uint8_t ohci_cmdstatus_hcr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_hcr_rdf(__DN(t) *_dev)
{
    ohci_cmdstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(ohci_cmdstatus_hcr_extract(_regval));
}

static inline uint8_t ohci_cmdstatus_clf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_clf_rdf(__DN(t) *_dev)
{
    ohci_cmdstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(ohci_cmdstatus_clf_extract(_regval));
}

static inline uint8_t ohci_cmdstatus_blf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_blf_rdf(__DN(t) *_dev)
{
    ohci_cmdstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(ohci_cmdstatus_blf_extract(_regval));
}

static inline uint8_t ohci_cmdstatus_ocr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_ocr_rdf(__DN(t) *_dev)
{
    ohci_cmdstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(ohci_cmdstatus_ocr_extract(_regval));
}

static inline uint8_t ohci_cmdstatus_soc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_cmdstatus_soc_rdf(__DN(t) *_dev)
{
    ohci_cmdstatus_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(ohci_cmdstatus_soc_extract(_regval));
}

static inline void ohci_cmdstatus_hcr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_cmdstatus_hcr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_cmdstatus_t _regval = 0x1 & (((ohci_cmdstatus_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffcfffe & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void ohci_cmdstatus_clf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_cmdstatus_clf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_cmdstatus_t _regval = 0x2 & (((ohci_cmdstatus_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffcfffd & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void ohci_cmdstatus_blf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_cmdstatus_blf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_cmdstatus_t _regval = 0x4 & (((ohci_cmdstatus_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffcfffb & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

static inline void ohci_cmdstatus_ocr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_cmdstatus_ocr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_cmdstatus_t _regval = 0x8 & (((ohci_cmdstatus_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffcfff7 & mackerel_read_addr_32(_dev->base, 0x8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
    // No shadow register to write to
}

/*
 * Register intstatus: Interrupt status
 * Type: ohci.interrupt (Interrupts)
 *   so	(size 1, offset 0, init 0):	RW	Scheduling overrun
 *   wdh	(size 1, offset 1, init 0):	RW	Writeback done head
 *   sf	(size 1, offset 2, init 0):	RW	Start of frame
 *   rd	(size 1, offset 3, init 0):	RW	Resume detected
 *   ue	(size 1, offset 4, init 0):	RW	Unrecoverable error
 *   fno	(size 1, offset 5, init 0):	RW	Frame number overflow
 *   rhsc	(size 1, offset 6, init 0):	RW	Root hub status change
 *   _anon7	(size 23, offset 7, init 0):	RSVD	_
 *   oc	(size 1, offset 30, init 0):	RW	Ownership change
 *   mie	(size 1, offset 31, init 0):	RW	Master interrupt enable
 */
static inline ohci_interrupt_t ohci_intstatus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_intstatus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline ohci_interrupt_t ohci_intstatus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_intstatus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc));
}

static inline void ohci_intstatus_rawwr(__DN(t) *_dev, ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline void ohci_intstatus_rawwr(__DN(t) *_dev, ohci_interrupt_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline void ohci_intstatus_wr(__DN(t) *_dev, ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline void ohci_intstatus_wr(__DN(t) *_dev, ohci_interrupt_t _regval)
{
    _regval = (_regval & 0xc000007f);
    // No MB1 fields present
    _regval = (_regval | (0x3fffff80 & mackerel_read_addr_32(_dev->base, 0xc)));
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
}

static inline int ohci_intstatus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_intstatus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register intstatus (Interrupt status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " so =\t%" PRIx8 "\t(Scheduling overrun)\n", ohci_interrupt_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdh =\t%" PRIx8 "\t(Writeback done head)\n", ohci_interrupt_wdh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sf =\t%" PRIx8 "\t(Start of frame)\n", ohci_interrupt_sf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(Resume detected)\n", ohci_interrupt_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ue =\t%" PRIx8 "\t(Unrecoverable error)\n", ohci_interrupt_ue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fno =\t%" PRIx8 "\t(Frame number overflow)\n", ohci_interrupt_fno_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhsc =\t%" PRIx8 "\t(Root hub status change)\n", ohci_interrupt_rhsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oc =\t%" PRIx8 "\t(Ownership change)\n", ohci_interrupt_oc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mie =\t%" PRIx8 "\t(Master interrupt enable)\n", ohci_interrupt_mie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ohci_intstatus_so_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_so_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_so_extract(_regval));
}

static inline uint8_t ohci_intstatus_wdh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_wdh_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_wdh_extract(_regval));
}

static inline uint8_t ohci_intstatus_sf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_sf_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_sf_extract(_regval));
}

static inline uint8_t ohci_intstatus_rd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_rd_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_rd_extract(_regval));
}

static inline uint8_t ohci_intstatus_ue_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_ue_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_ue_extract(_regval));
}

static inline uint8_t ohci_intstatus_fno_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_fno_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_fno_extract(_regval));
}

static inline uint8_t ohci_intstatus_rhsc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_rhsc_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_rhsc_extract(_regval));
}

static inline uint8_t ohci_intstatus_oc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_oc_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_oc_extract(_regval));
}

static inline uint8_t ohci_intstatus_mie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intstatus_mie_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0xc);
    return(ohci_interrupt_mie_extract(_regval));
}

static inline void ohci_intstatus_so_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_so_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x1 & (((ohci_interrupt_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_wdh_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_wdh_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x2 & (((ohci_interrupt_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_sf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_sf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x4 & (((ohci_interrupt_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_rd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_rd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x8 & (((ohci_interrupt_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_ue_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_ue_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x10 & (((ohci_interrupt_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_fno_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_fno_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x20 & (((ohci_interrupt_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_rhsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_rhsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x40 & (((ohci_interrupt_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_oc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_oc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x40000000 & (((ohci_interrupt_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

static inline void ohci_intstatus_mie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intstatus_mie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x80000000 & (((ohci_interrupt_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xc)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc, _regval);
    // No shadow register to write to
}

/*
 * Register intenable: Interrupt enable
 * Type: ohci.interrupt (Interrupts)
 *   so	(size 1, offset 0, init 0):	RW	Scheduling overrun
 *   wdh	(size 1, offset 1, init 0):	RW	Writeback done head
 *   sf	(size 1, offset 2, init 0):	RW	Start of frame
 *   rd	(size 1, offset 3, init 0):	RW	Resume detected
 *   ue	(size 1, offset 4, init 0):	RW	Unrecoverable error
 *   fno	(size 1, offset 5, init 0):	RW	Frame number overflow
 *   rhsc	(size 1, offset 6, init 0):	RW	Root hub status change
 *   _anon7	(size 23, offset 7, init 0):	RSVD	_
 *   oc	(size 1, offset 30, init 0):	RW	Ownership change
 *   mie	(size 1, offset 31, init 0):	RW	Master interrupt enable
 */
static inline ohci_interrupt_t ohci_intenable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_intenable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline ohci_interrupt_t ohci_intenable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_intenable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void ohci_intenable_rawwr(__DN(t) *_dev, ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline void ohci_intenable_rawwr(__DN(t) *_dev, ohci_interrupt_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void ohci_intenable_wr(__DN(t) *_dev, ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline void ohci_intenable_wr(__DN(t) *_dev, ohci_interrupt_t _regval)
{
    _regval = (_regval & 0xc000007f);
    // No MB1 fields present
    _regval = (_regval | (0x3fffff80 & mackerel_read_addr_32(_dev->base, 0x10)));
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int ohci_intenable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_intenable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register intenable (Interrupt enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " so =\t%" PRIx8 "\t(Scheduling overrun)\n", ohci_interrupt_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdh =\t%" PRIx8 "\t(Writeback done head)\n", ohci_interrupt_wdh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sf =\t%" PRIx8 "\t(Start of frame)\n", ohci_interrupt_sf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(Resume detected)\n", ohci_interrupt_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ue =\t%" PRIx8 "\t(Unrecoverable error)\n", ohci_interrupt_ue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fno =\t%" PRIx8 "\t(Frame number overflow)\n", ohci_interrupt_fno_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhsc =\t%" PRIx8 "\t(Root hub status change)\n", ohci_interrupt_rhsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oc =\t%" PRIx8 "\t(Ownership change)\n", ohci_interrupt_oc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mie =\t%" PRIx8 "\t(Master interrupt enable)\n", ohci_interrupt_mie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ohci_intenable_so_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_so_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_so_extract(_regval));
}

static inline uint8_t ohci_intenable_wdh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_wdh_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_wdh_extract(_regval));
}

static inline uint8_t ohci_intenable_sf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_sf_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_sf_extract(_regval));
}

static inline uint8_t ohci_intenable_rd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_rd_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_rd_extract(_regval));
}

static inline uint8_t ohci_intenable_ue_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_ue_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_ue_extract(_regval));
}

static inline uint8_t ohci_intenable_fno_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_fno_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_fno_extract(_regval));
}

static inline uint8_t ohci_intenable_rhsc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_rhsc_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_rhsc_extract(_regval));
}

static inline uint8_t ohci_intenable_oc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_oc_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_oc_extract(_regval));
}

static inline uint8_t ohci_intenable_mie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intenable_mie_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(ohci_interrupt_mie_extract(_regval));
}

static inline void ohci_intenable_so_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_so_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x1 & (((ohci_interrupt_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_wdh_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_wdh_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x2 & (((ohci_interrupt_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_sf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_sf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x4 & (((ohci_interrupt_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_rd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_rd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x8 & (((ohci_interrupt_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_ue_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_ue_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x10 & (((ohci_interrupt_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_fno_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_fno_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x20 & (((ohci_interrupt_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_rhsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_rhsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x40 & (((ohci_interrupt_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_oc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_oc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x40000000 & (((ohci_interrupt_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void ohci_intenable_mie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intenable_mie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x80000000 & (((ohci_interrupt_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register intdisable: Interrupt disable
 * Type: ohci.interrupt (Interrupts)
 *   so	(size 1, offset 0, init 0):	RW	Scheduling overrun
 *   wdh	(size 1, offset 1, init 0):	RW	Writeback done head
 *   sf	(size 1, offset 2, init 0):	RW	Start of frame
 *   rd	(size 1, offset 3, init 0):	RW	Resume detected
 *   ue	(size 1, offset 4, init 0):	RW	Unrecoverable error
 *   fno	(size 1, offset 5, init 0):	RW	Frame number overflow
 *   rhsc	(size 1, offset 6, init 0):	RW	Root hub status change
 *   _anon7	(size 23, offset 7, init 0):	RSVD	_
 *   oc	(size 1, offset 30, init 0):	RW	Ownership change
 *   mie	(size 1, offset 31, init 0):	RW	Master interrupt enable
 */
static inline ohci_interrupt_t ohci_intdisable_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_intdisable_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline ohci_interrupt_t ohci_intdisable_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_interrupt_t ohci_intdisable_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void ohci_intdisable_rawwr(__DN(t) *_dev, ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline void ohci_intdisable_rawwr(__DN(t) *_dev, ohci_interrupt_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void ohci_intdisable_wr(__DN(t) *_dev, ohci_interrupt_t _regval) __attribute__ ((always_inline));
static inline void ohci_intdisable_wr(__DN(t) *_dev, ohci_interrupt_t _regval)
{
    _regval = (_regval & 0xc000007f);
    // No MB1 fields present
    _regval = (_regval | (0x3fffff80 & mackerel_read_addr_32(_dev->base, 0x14)));
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int ohci_intdisable_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_intdisable_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register intdisable (Interrupt disable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " so =\t%" PRIx8 "\t(Scheduling overrun)\n", ohci_interrupt_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wdh =\t%" PRIx8 "\t(Writeback done head)\n", ohci_interrupt_wdh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sf =\t%" PRIx8 "\t(Start of frame)\n", ohci_interrupt_sf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd =\t%" PRIx8 "\t(Resume detected)\n", ohci_interrupt_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ue =\t%" PRIx8 "\t(Unrecoverable error)\n", ohci_interrupt_ue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fno =\t%" PRIx8 "\t(Frame number overflow)\n", ohci_interrupt_fno_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rhsc =\t%" PRIx8 "\t(Root hub status change)\n", ohci_interrupt_rhsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oc =\t%" PRIx8 "\t(Ownership change)\n", ohci_interrupt_oc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mie =\t%" PRIx8 "\t(Master interrupt enable)\n", ohci_interrupt_mie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ohci_intdisable_so_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_so_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_so_extract(_regval));
}

static inline uint8_t ohci_intdisable_wdh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_wdh_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_wdh_extract(_regval));
}

static inline uint8_t ohci_intdisable_sf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_sf_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_sf_extract(_regval));
}

static inline uint8_t ohci_intdisable_rd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_rd_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_rd_extract(_regval));
}

static inline uint8_t ohci_intdisable_ue_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_ue_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_ue_extract(_regval));
}

static inline uint8_t ohci_intdisable_fno_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_fno_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_fno_extract(_regval));
}

static inline uint8_t ohci_intdisable_rhsc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_rhsc_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_rhsc_extract(_regval));
}

static inline uint8_t ohci_intdisable_oc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_oc_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_oc_extract(_regval));
}

static inline uint8_t ohci_intdisable_mie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_intdisable_mie_rdf(__DN(t) *_dev)
{
    ohci_interrupt_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(ohci_interrupt_mie_extract(_regval));
}

static inline void ohci_intdisable_so_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_so_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x1 & (((ohci_interrupt_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_wdh_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_wdh_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x2 & (((ohci_interrupt_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_sf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_sf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x4 & (((ohci_interrupt_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_rd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_rd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x8 & (((ohci_interrupt_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_ue_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_ue_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x10 & (((ohci_interrupt_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_fno_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_fno_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x20 & (((ohci_interrupt_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_rhsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_rhsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x40 & (((ohci_interrupt_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_oc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_oc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x40000000 & (((ohci_interrupt_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void ohci_intdisable_mie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_intdisable_mie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_interrupt_t _regval = 0x80000000 & (((ohci_interrupt_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register hcca: Host controller communication area
 * Type: ohci.hcca (Implicit type of Host controller communication area register)
 *   _anon0	(size 8, offset 0, init 0):	MBZ	_
 *   hcca	(size 24, offset 8, init 0):	RW	Physical address
 */
static inline ohci_hcca_t ohci_hcca_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_hcca_t ohci_hcca_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline ohci_hcca_t ohci_hcca_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_hcca_t ohci_hcca_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void ohci_hcca_rawwr(__DN(t) *_dev, ohci_hcca_t _regval) __attribute__ ((always_inline));
static inline void ohci_hcca_rawwr(__DN(t) *_dev, ohci_hcca_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void ohci_hcca_wr(__DN(t) *_dev, ohci_hcca_t _regval) __attribute__ ((always_inline));
static inline void ohci_hcca_wr(__DN(t) *_dev, ohci_hcca_t _regval)
{
    _regval = (_regval & 0xffffff00);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int ohci_hcca_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_hcca_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_hcca_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hcca (Host controller communication area): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hcca =\t%" PRIx32 "\t(Physical address)\n", ohci_hcca_hcca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ohci_hcca_hcca_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ohci_hcca_hcca_rdf(__DN(t) *_dev)
{
    ohci_hcca_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(ohci_hcca_hcca_extract(_regval));
}

static inline void ohci_hcca_hcca_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_hcca_hcca_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ohci_hcca_t _regval = 0xffffff00 & (((ohci_hcca_t )(_fieldval)) << 8);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffffff00);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register period_cur: Cur. isochronous or int. ED
 * Type: ohci.physptr (Physical address pointer)
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   addr	(size 28, offset 4, init 0):	RO	Address
 */
static inline ohci_physptr_t ohci_period_cur_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_period_cur_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline ohci_physptr_t ohci_period_cur_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_period_cur_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void ohci_period_cur_rawwr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_period_cur_rawwr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

// Register period_cur is not writeable
static inline int ohci_period_cur_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_period_cur_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register period_cur (Cur. isochronous or int. ED): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address)\n", ohci_physptr_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ohci_period_cur_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ohci_period_cur_addr_rdf(__DN(t) *_dev)
{
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(ohci_physptr_addr_extract(_regval));
}

/*
 * Register ctrl_head: First ED of control list
 * Type: ohci.physptr (Physical address pointer)
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   addr	(size 28, offset 4, init 0):	RW	Address
 */
static inline ohci_physptr_t ohci_ctrl_head_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_ctrl_head_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline ohci_physptr_t ohci_ctrl_head_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_ctrl_head_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void ohci_ctrl_head_rawwr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_ctrl_head_rawwr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void ohci_ctrl_head_wr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_ctrl_head_wr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int ohci_ctrl_head_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_ctrl_head_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl_head (First ED of control list): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address)\n", ohci_physptr_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ohci_ctrl_head_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ohci_ctrl_head_addr_rdf(__DN(t) *_dev)
{
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(ohci_physptr_addr_extract(_regval));
}

static inline void ohci_ctrl_head_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_ctrl_head_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ohci_physptr_t _regval = 0xfffffff0 & (((ohci_physptr_t )(_fieldval)) << 4);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register ctrl_cur: Current ED of control list
 * Type: ohci.physptr (Physical address pointer)
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   addr	(size 28, offset 4, init 0):	RW	Address
 */
static inline ohci_physptr_t ohci_ctrl_cur_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_ctrl_cur_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline ohci_physptr_t ohci_ctrl_cur_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_ctrl_cur_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void ohci_ctrl_cur_rawwr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_ctrl_cur_rawwr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void ohci_ctrl_cur_wr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_ctrl_cur_wr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int ohci_ctrl_cur_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_ctrl_cur_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl_cur (Current ED of control list): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address)\n", ohci_physptr_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ohci_ctrl_cur_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ohci_ctrl_cur_addr_rdf(__DN(t) *_dev)
{
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(ohci_physptr_addr_extract(_regval));
}

static inline void ohci_ctrl_cur_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_ctrl_cur_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ohci_physptr_t _regval = 0xfffffff0 & (((ohci_physptr_t )(_fieldval)) << 4);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register bulk_head: First ED of bulk list
 * Type: ohci.physptr (Physical address pointer)
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   addr	(size 28, offset 4, init 0):	RW	Address
 */
static inline ohci_physptr_t ohci_bulk_head_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_bulk_head_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline ohci_physptr_t ohci_bulk_head_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_bulk_head_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void ohci_bulk_head_rawwr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_bulk_head_rawwr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void ohci_bulk_head_wr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_bulk_head_wr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int ohci_bulk_head_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_bulk_head_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bulk_head (First ED of bulk list): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address)\n", ohci_physptr_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ohci_bulk_head_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ohci_bulk_head_addr_rdf(__DN(t) *_dev)
{
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(ohci_physptr_addr_extract(_regval));
}

static inline void ohci_bulk_head_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_bulk_head_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ohci_physptr_t _regval = 0xfffffff0 & (((ohci_physptr_t )(_fieldval)) << 4);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register bulk_cur: Current ED of bulk list
 * Type: ohci.physptr (Physical address pointer)
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   addr	(size 28, offset 4, init 0):	RW	Address
 */
static inline ohci_physptr_t ohci_bulk_cur_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_bulk_cur_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline ohci_physptr_t ohci_bulk_cur_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_bulk_cur_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void ohci_bulk_cur_rawwr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_bulk_cur_rawwr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void ohci_bulk_cur_wr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_bulk_cur_wr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int ohci_bulk_cur_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_bulk_cur_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bulk_cur (Current ED of bulk list): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address)\n", ohci_physptr_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ohci_bulk_cur_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ohci_bulk_cur_addr_rdf(__DN(t) *_dev)
{
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    return(ohci_physptr_addr_extract(_regval));
}

static inline void ohci_bulk_cur_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_bulk_cur_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    ohci_physptr_t _regval = 0xfffffff0 & (((ohci_physptr_t )(_fieldval)) << 4);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfffffff0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
    // No shadow register to write to
}

/*
 * Register done_head: Done head pointer
 * Type: ohci.physptr (Physical address pointer)
 *   _anon0	(size 4, offset 0, init 0):	MBZ	_
 *   addr	(size 28, offset 4, init 0):	RO	Address
 */
static inline ohci_physptr_t ohci_done_head_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_done_head_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline ohci_physptr_t ohci_done_head_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_physptr_t ohci_done_head_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void ohci_done_head_rawwr(__DN(t) *_dev, ohci_physptr_t _regval) __attribute__ ((always_inline));
static inline void ohci_done_head_rawwr(__DN(t) *_dev, ohci_physptr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

// Register done_head is not writeable
static inline int ohci_done_head_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_done_head_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register done_head (Done head pointer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Address)\n", ohci_physptr_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t ohci_done_head_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t ohci_done_head_addr_rdf(__DN(t) *_dev)
{
    ohci_physptr_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(ohci_physptr_addr_extract(_regval));
}

/*
 * Register fm_interval: Frame interval
 * Type: ohci.fm_interval (Implicit type of Frame interval register)
 *   fi	(size 14, offset 0, init 0):	RW	Frame interval (dflt 0x2edf)
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 *   fsmps	(size 15, offset 16, init 0):	RW	FS largest data packet
 *   fit	(size 1, offset 31, init 0):	RW	Frame interval toggle
 */
static inline ohci_fm_interval_t ohci_fm_interval_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_fm_interval_t ohci_fm_interval_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline ohci_fm_interval_t ohci_fm_interval_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_fm_interval_t ohci_fm_interval_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline void ohci_fm_interval_rawwr(__DN(t) *_dev, ohci_fm_interval_t _regval) __attribute__ ((always_inline));
static inline void ohci_fm_interval_rawwr(__DN(t) *_dev, ohci_fm_interval_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void ohci_fm_interval_wr(__DN(t) *_dev, ohci_fm_interval_t _regval) __attribute__ ((always_inline));
static inline void ohci_fm_interval_wr(__DN(t) *_dev, ohci_fm_interval_t _regval)
{
    _regval = (_regval & 0xffff3fff);
    // No MB1 fields present
    _regval = (_regval | (0xc000 & mackerel_read_addr_32(_dev->base, 0x34)));
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int ohci_fm_interval_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_fm_interval_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_fm_interval_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fm_interval (Frame interval): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fi =\t%" PRIx16 "\t(Frame interval (dflt 0x2edf))\n", ohci_fm_interval_fi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fsmps =\t%" PRIx16 "\t(FS largest data packet)\n", ohci_fm_interval_fsmps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fit =\t%" PRIx8 "\t(Frame interval toggle)\n", ohci_fm_interval_fit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t ohci_fm_interval_fi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_interval_fi_rdf(__DN(t) *_dev)
{
    ohci_fm_interval_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(ohci_fm_interval_fi_extract(_regval));
}

static inline uint16_t ohci_fm_interval_fsmps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_interval_fsmps_rdf(__DN(t) *_dev)
{
    ohci_fm_interval_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(ohci_fm_interval_fsmps_extract(_regval));
}

static inline uint8_t ohci_fm_interval_fit_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_fm_interval_fit_rdf(__DN(t) *_dev)
{
    ohci_fm_interval_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(ohci_fm_interval_fit_extract(_regval));
}

static inline void ohci_fm_interval_fi_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_fm_interval_fi_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ohci_fm_interval_t _regval = 0x3fff & (((ohci_fm_interval_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffc000 & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void ohci_fm_interval_fsmps_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_fm_interval_fsmps_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ohci_fm_interval_t _regval = 0x7fff0000 & (((ohci_fm_interval_t )(_fieldval)) << 16);
    _regval = (_regval | (0x8000ffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void ohci_fm_interval_fit_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_fm_interval_fit_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_fm_interval_t _regval = 0x80000000 & (((ohci_fm_interval_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

/*
 * Register fm_remain: Frame remaining
 * Type: ohci.fm_remain (Implicit type of Frame remaining register)
 *   fr	(size 14, offset 0, init 0):	RO	Bit time remaining in current frame
 *   _anon14	(size 17, offset 14, init 0):	RSVD	_
 *   frt	(size 1, offset 31, init 0):	RO	Frame remaining toggle
 */
static inline ohci_fm_remain_t ohci_fm_remain_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_fm_remain_t ohci_fm_remain_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline ohci_fm_remain_t ohci_fm_remain_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_fm_remain_t ohci_fm_remain_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void ohci_fm_remain_rawwr(__DN(t) *_dev, ohci_fm_remain_t _regval) __attribute__ ((always_inline));
static inline void ohci_fm_remain_rawwr(__DN(t) *_dev, ohci_fm_remain_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

// Register fm_remain is not writeable
static inline int ohci_fm_remain_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_fm_remain_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_fm_remain_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fm_remain (Frame remaining): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fr =\t%" PRIx16 "\t(Bit time remaining in current frame)\n", ohci_fm_remain_fr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frt =\t%" PRIx8 "\t(Frame remaining toggle)\n", ohci_fm_remain_frt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t ohci_fm_remain_fr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_remain_fr_rdf(__DN(t) *_dev)
{
    ohci_fm_remain_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(ohci_fm_remain_fr_extract(_regval));
}

static inline uint8_t ohci_fm_remain_frt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_fm_remain_frt_rdf(__DN(t) *_dev)
{
    ohci_fm_remain_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    return(ohci_fm_remain_frt_extract(_regval));
}

/*
 * Register fm_num: Frame number
 * Type: ohci.fm_num (Implicit type of Frame number register)
 *   fn	(size 16, offset 0, init 0):	RO	Frame number (16-bit counter)
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline ohci_fm_num_t ohci_fm_num_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_fm_num_t ohci_fm_num_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline ohci_fm_num_t ohci_fm_num_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_fm_num_t ohci_fm_num_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline void ohci_fm_num_rawwr(__DN(t) *_dev, ohci_fm_num_t _regval) __attribute__ ((always_inline));
static inline void ohci_fm_num_rawwr(__DN(t) *_dev, ohci_fm_num_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

// Register fm_num is not writeable
static inline int ohci_fm_num_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_fm_num_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_fm_num_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fm_num (Frame number): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fn =\t%" PRIx16 "\t(Frame number (16-bit counter))\n", ohci_fm_num_fn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t ohci_fm_num_fn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_fm_num_fn_rdf(__DN(t) *_dev)
{
    ohci_fm_num_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(ohci_fm_num_fn_extract(_regval));
}

/*
 * Register period_start: Period start
 * Type: ohci.period_start (Implicit type of Period start register)
 *   ps	(size 14, offset 0, init 0):	RW	Start time for processing periodic list
 *   _anon14	(size 18, offset 14, init 0):	RSVD	_
 */
static inline ohci_period_start_t ohci_period_start_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_period_start_t ohci_period_start_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline ohci_period_start_t ohci_period_start_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_period_start_t ohci_period_start_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40));
}

static inline void ohci_period_start_rawwr(__DN(t) *_dev, ohci_period_start_t _regval) __attribute__ ((always_inline));
static inline void ohci_period_start_rawwr(__DN(t) *_dev, ohci_period_start_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline void ohci_period_start_wr(__DN(t) *_dev, ohci_period_start_t _regval) __attribute__ ((always_inline));
static inline void ohci_period_start_wr(__DN(t) *_dev, ohci_period_start_t _regval)
{
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    _regval = (_regval | (0xffffc000 & mackerel_read_addr_32(_dev->base, 0x40)));
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
}

static inline int ohci_period_start_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_period_start_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_period_start_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register period_start (Period start): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ps =\t%" PRIx16 "\t(Start time for processing periodic list)\n", ohci_period_start_ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint16_t ohci_period_start_ps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_period_start_ps_rdf(__DN(t) *_dev)
{
    ohci_period_start_t _regval = mackerel_read_addr_32(_dev->base, 0x40);
    return(ohci_period_start_ps_extract(_regval));
}

static inline void ohci_period_start_ps_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_period_start_ps_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ohci_period_start_t _regval = 0x3fff & (((ohci_period_start_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffc000 & mackerel_read_addr_32(_dev->base, 0x40)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x40, _regval);
    // No shadow register to write to
}

/*
 * Register hclsthreshold: LS threshold
 * Type: ohci.hclsthreshold (Implicit type of LS threshold register)
 *   lst	(size 11, offset 0, init 0):	RW	Low-speed threshold (should be 0x0628)
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
static inline ohci_hclsthreshold_t ohci_hclsthreshold_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_hclsthreshold_t ohci_hclsthreshold_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline ohci_hclsthreshold_t ohci_hclsthreshold_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_hclsthreshold_t ohci_hclsthreshold_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x44));
}

static inline void ohci_hclsthreshold_rawwr(__DN(t) *_dev, ohci_hclsthreshold_t _regval) __attribute__ ((always_inline));
static inline void ohci_hclsthreshold_rawwr(__DN(t) *_dev, ohci_hclsthreshold_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline void ohci_hclsthreshold_wr(__DN(t) *_dev, ohci_hclsthreshold_t _regval) __attribute__ ((always_inline));
static inline void ohci_hclsthreshold_wr(__DN(t) *_dev, ohci_hclsthreshold_t _regval)
{
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff800 & mackerel_read_addr_32(_dev->base, 0x44)));
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
}

static inline int ohci_hclsthreshold_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_hclsthreshold_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_hclsthreshold_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hclsthreshold (LS threshold): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lst =\t%" PRIx16 "\t(Low-speed threshold (should be 0x0628))\n", ohci_hclsthreshold_lst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint16_t ohci_hclsthreshold_lst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_hclsthreshold_lst_rdf(__DN(t) *_dev)
{
    ohci_hclsthreshold_t _regval = mackerel_read_addr_32(_dev->base, 0x44);
    return(ohci_hclsthreshold_lst_extract(_regval));
}

static inline void ohci_hclsthreshold_lst_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_hclsthreshold_lst_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ohci_hclsthreshold_t _regval = 0x7ff & (((ohci_hclsthreshold_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff800 & mackerel_read_addr_32(_dev->base, 0x44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x44, _regval);
    // No shadow register to write to
}

/*
 * Register rh_descra: Root hub descriptor a
 * Type: ohci.rh_descra (Implicit type of Root hub descriptor a register)
 *   ndp	(size 8, offset 0, init 0):	RO	Number of downstream ports
 *   psm	(size 1, offset 8, init 0):	RW	Power switching mode
 *   nps	(size 1, offset 9, init 0):	RW	No power switching
 *   dt	(size 1, offset 10, init 0):	RO	Device type
 *   ocpm	(size 1, offset 11, init 0):	RW	Overcurrent protection mode
 *   nocp	(size 1, offset 12, init 0):	RW	No overcurrent protection
 *   _anon13	(size 11, offset 13, init 0):	RSVD	_
 *   potpgt	(size 8, offset 24, init 0):	RW	Power-on to power-good time (* 2ms)
 */
static inline ohci_rh_descra_t ohci_rh_descra_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline ohci_rh_descra_t ohci_rh_descra_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_rh_descra_t ohci_rh_descra_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x48));
}

static inline void ohci_rh_descra_rawwr(__DN(t) *_dev, ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_descra_rawwr(__DN(t) *_dev, ohci_rh_descra_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline void ohci_rh_descra_wr(__DN(t) *_dev, ohci_rh_descra_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_descra_wr(__DN(t) *_dev, ohci_rh_descra_t _regval)
{
    _regval = (_regval & 0xff001fff);
    // No MB1 fields present
    _regval = (_regval | (0xffe000 & mackerel_read_addr_32(_dev->base, 0x48)));
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
}

static inline int ohci_rh_descra_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_rh_descra_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rh_descra (Root hub descriptor a): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ndp =\t%" PRIx8 "\t(Number of downstream ports)\n", ohci_rh_descra_ndp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " psm =\t%" PRIx8 "\t(Power switching mode)\n", ohci_rh_descra_psm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nps =\t%" PRIx8 "\t(No power switching)\n", ohci_rh_descra_nps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dt =\t%" PRIx8 "\t(Device type)\n", ohci_rh_descra_dt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocpm =\t%" PRIx8 "\t(Overcurrent protection mode)\n", ohci_rh_descra_ocpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nocp =\t%" PRIx8 "\t(No overcurrent protection)\n", ohci_rh_descra_nocp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " potpgt =\t%" PRIx8 "\t(Power-on to power-good time (* 2ms))\n", ohci_rh_descra_potpgt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ohci_rh_descra_ndp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_ndp_rdf(__DN(t) *_dev)
{
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(ohci_rh_descra_ndp_extract(_regval));
}

static inline uint8_t ohci_rh_descra_psm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_psm_rdf(__DN(t) *_dev)
{
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(ohci_rh_descra_psm_extract(_regval));
}

static inline uint8_t ohci_rh_descra_nps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_nps_rdf(__DN(t) *_dev)
{
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(ohci_rh_descra_nps_extract(_regval));
}

static inline uint8_t ohci_rh_descra_dt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_dt_rdf(__DN(t) *_dev)
{
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(ohci_rh_descra_dt_extract(_regval));
}

static inline uint8_t ohci_rh_descra_ocpm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_ocpm_rdf(__DN(t) *_dev)
{
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(ohci_rh_descra_ocpm_extract(_regval));
}

static inline uint8_t ohci_rh_descra_nocp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_nocp_rdf(__DN(t) *_dev)
{
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(ohci_rh_descra_nocp_extract(_regval));
}

static inline uint8_t ohci_rh_descra_potpgt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_descra_potpgt_rdf(__DN(t) *_dev)
{
    ohci_rh_descra_t _regval = mackerel_read_addr_32(_dev->base, 0x48);
    return(ohci_rh_descra_potpgt_extract(_regval));
}

static inline void ohci_rh_descra_psm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_descra_psm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_descra_t _regval = 0x100 & (((ohci_rh_descra_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffa00 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void ohci_rh_descra_nps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_descra_nps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_descra_t _regval = 0x200 & (((ohci_rh_descra_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff900 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void ohci_rh_descra_ocpm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_descra_ocpm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_descra_t _regval = 0x800 & (((ohci_rh_descra_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff300 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void ohci_rh_descra_nocp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_descra_nocp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_descra_t _regval = 0x1000 & (((ohci_rh_descra_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffeb00 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

static inline void ohci_rh_descra_potpgt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_descra_potpgt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_descra_t _regval = 0xff000000 & (((ohci_rh_descra_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfffb00 & mackerel_read_addr_32(_dev->base, 0x48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x48, _regval);
    // No shadow register to write to
}

/*
 * Register rh_descrb: Root hub descriptor b
 * Type: ohci.rh_descrb (Implicit type of Root hub descriptor b register)
 *   dr	(size 16, offset 0, init 0):	RW	Device removal
 *   ppcm	(size 16, offset 16, init 0):	RW	Port power control mask
 */
static inline ohci_rh_descrb_t ohci_rh_descrb_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_rh_descrb_t ohci_rh_descrb_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline ohci_rh_descrb_t ohci_rh_descrb_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_rh_descrb_t ohci_rh_descrb_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline void ohci_rh_descrb_rawwr(__DN(t) *_dev, ohci_rh_descrb_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_descrb_rawwr(__DN(t) *_dev, ohci_rh_descrb_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline void ohci_rh_descrb_wr(__DN(t) *_dev, ohci_rh_descrb_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_descrb_wr(__DN(t) *_dev, ohci_rh_descrb_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline int ohci_rh_descrb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_rh_descrb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_rh_descrb_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rh_descrb (Root hub descriptor b): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dr =\t%" PRIx16 "\t(Device removal)\n", ohci_rh_descrb_dr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ppcm =\t%" PRIx16 "\t(Port power control mask)\n", ohci_rh_descrb_ppcm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t ohci_rh_descrb_dr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_rh_descrb_dr_rdf(__DN(t) *_dev)
{
    ohci_rh_descrb_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(ohci_rh_descrb_dr_extract(_regval));
}

static inline uint16_t ohci_rh_descrb_ppcm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t ohci_rh_descrb_ppcm_rdf(__DN(t) *_dev)
{
    ohci_rh_descrb_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(ohci_rh_descrb_ppcm_extract(_regval));
}

static inline void ohci_rh_descrb_dr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_descrb_dr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ohci_rh_descrb_t _regval = 0xffff & (((ohci_rh_descrb_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void ohci_rh_descrb_ppcm_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_descrb_ppcm_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    ohci_rh_descrb_t _regval = 0xffff0000 & (((ohci_rh_descrb_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

/*
 * Register rh_status: Root hub status
 * Type: ohci.rh_status (Implicit type of Root hub status register)
 *   lps	(size 1, offset 0, init 0):	WO	Clear global power
 *   oci	(size 1, offset 1, init 0):	RO	Overcurrent indicator
 *   _anon2	(size 13, offset 2, init 0):	RSVD	_
 *   drwe	(size 1, offset 15, init 0):	RWC	Device remote wakeup enable
 *   lpsc	(size 1, offset 16, init 0):	WO	Set globl power
 *   ocic	(size 1, offset 17, init 0):	RWC	Overcurrent indicator change
 *   _anon18	(size 13, offset 18, init 0):	RSVD	_
 *   crwe	(size 1, offset 31, init 0):	WO	Clear remote wakeup enable
 */
static inline ohci_rh_status_t ohci_rh_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline ohci_rh_status_t ohci_rh_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline ohci_rh_status_t ohci_rh_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x50));
}

static inline void ohci_rh_status_rawwr(__DN(t) *_dev, ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_status_rawwr(__DN(t) *_dev, ohci_rh_status_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline void ohci_rh_status_wr(__DN(t) *_dev, ohci_rh_status_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_status_wr(__DN(t) *_dev, ohci_rh_status_t _regval)
{
    _regval = (_regval & 0x80038003);
    // No MB1 fields present
    _regval = (_regval | (0x7ffc7ffc & mackerel_read_addr_32(_dev->base, 0x50)));
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
}

static inline int ohci_rh_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_rh_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_rh_status_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rh_status (Root hub status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lps =\t%" PRIx8 "\t(Clear global power)\n", ohci_rh_status_lps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " oci =\t%" PRIx8 "\t(Overcurrent indicator)\n", ohci_rh_status_oci_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drwe =\t%" PRIx8 "\t(Device remote wakeup enable)\n", ohci_rh_status_drwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpsc =\t%" PRIx8 "\t(Set globl power)\n", ohci_rh_status_lpsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocic =\t%" PRIx8 "\t(Overcurrent indicator change)\n", ohci_rh_status_ocic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crwe =\t%" PRIx8 "\t(Clear remote wakeup enable)\n", ohci_rh_status_crwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t ohci_rh_status_oci_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_oci_rdf(__DN(t) *_dev)
{
    ohci_rh_status_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(ohci_rh_status_oci_extract(_regval));
}

static inline uint8_t ohci_rh_status_drwe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_drwe_rdf(__DN(t) *_dev)
{
    ohci_rh_status_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(ohci_rh_status_drwe_extract(_regval));
}

static inline uint8_t ohci_rh_status_ocic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_ocic_rdf(__DN(t) *_dev)
{
    ohci_rh_status_t _regval = mackerel_read_addr_32(_dev->base, 0x50);
    return(ohci_rh_status_ocic_extract(_regval));
}

static inline uint8_t ohci_rh_status_lps_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_lps_rd_shadow(__DN(t) *_dev)
{
    return(ohci_rh_status_lps_extract(_dev->rh_status_shadow));
}

static inline uint8_t ohci_rh_status_lpsc_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_lpsc_rd_shadow(__DN(t) *_dev)
{
    return(ohci_rh_status_lpsc_extract(_dev->rh_status_shadow));
}

static inline uint8_t ohci_rh_status_crwe_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_status_crwe_rd_shadow(__DN(t) *_dev)
{
    return(ohci_rh_status_crwe_extract(_dev->rh_status_shadow));
}

static inline void ohci_rh_status_lps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_status_lps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_status_t _regval = 0x1 & (((ohci_rh_status_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7ffc7ffc & mackerel_read_addr_32(_dev->base, 0x50)));
    _regval = (_regval | (0x80010000 & (_dev->rh_status_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    _dev->rh_status_shadow = _regval;
}

static inline void ohci_rh_status_drwe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_status_drwe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_status_t _regval = 0x8000 & (((ohci_rh_status_t )(_fieldval)) << 15);
    _regval = (_regval | (0x7ffc7ffc & mackerel_read_addr_32(_dev->base, 0x50)));
    _regval = (_regval | (0x80010001 & (_dev->rh_status_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    _dev->rh_status_shadow = _regval;
}

static inline void ohci_rh_status_lpsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_status_lpsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_status_t _regval = 0x10000 & (((ohci_rh_status_t )(_fieldval)) << 16);
    _regval = (_regval | (0x7ffc7ffc & mackerel_read_addr_32(_dev->base, 0x50)));
    _regval = (_regval | (0x80000001 & (_dev->rh_status_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    _dev->rh_status_shadow = _regval;
}

static inline void ohci_rh_status_ocic_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_status_ocic_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_status_t _regval = 0x20000 & (((ohci_rh_status_t )(_fieldval)) << 17);
    _regval = (_regval | (0x7ffc7ffc & mackerel_read_addr_32(_dev->base, 0x50)));
    _regval = (_regval | (0x80010001 & (_dev->rh_status_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    _dev->rh_status_shadow = _regval;
}

static inline void ohci_rh_status_crwe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_status_crwe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    ohci_rh_status_t _regval = 0x80000000 & (((ohci_rh_status_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7ffc7ffc & mackerel_read_addr_32(_dev->base, 0x50)));
    _regval = (_regval | (0x10001 & (_dev->rh_status_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x50, _regval);
    _dev->rh_status_shadow = _regval;
}

/*
 * Register array rh_portstat: Root hub port status
 * Type: ohci.rh_portstat (Implicit type of Root hub port status register array)
 *   ccs	(size 1, offset 0, init 0):	RO	Current connection status
 *   pes	(size 1, offset 1, init 0):	RO	Port enable status
 *   pss	(size 1, offset 2, init 0):	RO	Port suspend status
 *   poci	(size 1, offset 3, init 0):	RO	Port overcurrent indicator
 *   prs	(size 1, offset 4, init 0):	RO	Port reset status
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 *   pps	(size 1, offset 8, init 0):	RO	Port power status
 *   lsda	(size 1, offset 9, init 0):	RO	Low-speed device attached
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   csc	(size 1, offset 16, init 0):	RO	Connect status change
 *   pesc	(size 1, offset 17, init 0):	RO	Port enable status change
 *   pssc	(size 1, offset 18, init 0):	RO	Port suspend status change
 *   ocic	(size 1, offset 19, init 0):	RO	Port overcurrent indicator change
 *   prsc	(size 1, offset 20, init 0):	RO	Port reset status change
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
static const size_t ohci_rh_portstat_length = 256;
static inline ohci_rh_portstat_t ohci_rh_portstat_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8))));
}

static inline ohci_rh_portstat_t ohci_rh_portstat_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ohci_rh_portstat_t ohci_rh_portstat_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8))));
}

static inline void ohci_rh_portstat_rawwr(__DN(t) *_dev, int _i, ohci_rh_portstat_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_portstat_rawwr(__DN(t) *_dev, int _i, ohci_rh_portstat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
}

// Register rh_portstat is not writeable
static inline int ohci_rh_portstat_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int ohci_rh_portstat_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rh_portstat", _i, "Root hub port status");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ccs =\t%" PRIx8 "\t(Current connection status)\n", ohci_rh_portstat_ccs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pes =\t%" PRIx8 "\t(Port enable status)\n", ohci_rh_portstat_pes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pss =\t%" PRIx8 "\t(Port suspend status)\n", ohci_rh_portstat_pss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " poci =\t%" PRIx8 "\t(Port overcurrent indicator)\n", ohci_rh_portstat_poci_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prs =\t%" PRIx8 "\t(Port reset status)\n", ohci_rh_portstat_prs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pps =\t%" PRIx8 "\t(Port power status)\n", ohci_rh_portstat_pps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsda =\t%" PRIx8 "\t(Low-speed device attached)\n", ohci_rh_portstat_lsda_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Connect status change)\n", ohci_rh_portstat_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pesc =\t%" PRIx8 "\t(Port enable status change)\n", ohci_rh_portstat_pesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pssc =\t%" PRIx8 "\t(Port suspend status change)\n", ohci_rh_portstat_pssc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocic =\t%" PRIx8 "\t(Port overcurrent indicator change)\n", ohci_rh_portstat_ocic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prsc =\t%" PRIx8 "\t(Port reset status change)\n", ohci_rh_portstat_prsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    return(_r);
}

static inline int ohci_rh_portstat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_rh_portstat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 256; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = ohci_rh_portstat_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t ohci_rh_portstat_ccs_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_ccs_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_ccs_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_pes_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pes_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_pes_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_pss_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pss_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_pss_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_poci_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_poci_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_poci_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_prs_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_prs_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_prs_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_pps_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pps_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_pps_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_lsda_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_lsda_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_lsda_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_csc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_csc_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_csc_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_pesc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pesc_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_pesc_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_pssc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_pssc_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_pssc_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_ocic_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_ocic_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_ocic_extract(_regval));
}

static inline uint8_t ohci_rh_portstat_prsc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portstat_prsc_rdf(__DN(t) *_dev, int _i)
{
    ohci_rh_portstat_t _regval = mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)));
    return(ohci_rh_portstat_prsc_extract(_regval));
}

/*
 * Register array rh_portctrl: Root hub port control
 * Type: ohci.rh_portctrl (Implicit type of Root hub port control register array)
 *   cpe	(size 1, offset 0, init 0):	WO	Clear port enable
 *   spe	(size 1, offset 1, init 0):	WO	Set port enable
 *   sps	(size 1, offset 2, init 0):	WO	Set port suspend
 *   css	(size 1, offset 3, init 0):	WO	Clear suspend status
 *   spr	(size 1, offset 4, init 0):	WO	Set port reset
 *   _anon5	(size 3, offset 5, init 0):	RSVD	_
 *   spp	(size 1, offset 8, init 0):	WO	Set port power
 *   cpp	(size 1, offset 9, init 0):	WO	Clear port power
 *   _anon10	(size 6, offset 10, init 0):	RSVD	_
 *   csc	(size 1, offset 16, init 0):	WO	Clear connect status change
 *   pesc	(size 1, offset 17, init 0):	WO	Clear port enable status change
 *   pssc	(size 1, offset 18, init 0):	WO	Clear port suspend status change
 *   ocic	(size 1, offset 19, init 0):	WO	Clear port overcurrent indicator change
 *   prsc	(size 1, offset 20, init 0):	WO	Clear port reset status change
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
static const size_t ohci_rh_portctrl_length = 256;
static inline ohci_rh_portctrl_t ohci_rh_portctrl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8))));
}

static inline ohci_rh_portctrl_t ohci_rh_portctrl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline ohci_rh_portctrl_t ohci_rh_portctrl_rd(__DN(t) *_dev, int _i)
{
    return((_dev->rh_portctrl_shadow)[_i]);
}

static inline void ohci_rh_portctrl_rawwr(__DN(t) *_dev, int _i, ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_rawwr(__DN(t) *_dev, int _i, ohci_rh_portctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
}

static inline void ohci_rh_portctrl_wr(__DN(t) *_dev, int _i, ohci_rh_portctrl_t _regval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_wr(__DN(t) *_dev, int _i, ohci_rh_portctrl_t _regval)
{
    _regval = (_regval & 0x1f031f);
    // No MB1 fields present
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
}

static inline int ohci_rh_portctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int ohci_rh_portctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    ohci_rh_portctrl_t _regval = (_dev->rh_portctrl_shadow)[_i];
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rh_portctrl", _i, "Root hub port control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpe =\t%" PRIx8 "\t(Clear port enable)\n", ohci_rh_portctrl_cpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spe =\t%" PRIx8 "\t(Set port enable)\n", ohci_rh_portctrl_spe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sps =\t%" PRIx8 "\t(Set port suspend)\n", ohci_rh_portctrl_sps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " css =\t%" PRIx8 "\t(Clear suspend status)\n", ohci_rh_portctrl_css_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spr =\t%" PRIx8 "\t(Set port reset)\n", ohci_rh_portctrl_spr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spp =\t%" PRIx8 "\t(Set port power)\n", ohci_rh_portctrl_spp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpp =\t%" PRIx8 "\t(Clear port power)\n", ohci_rh_portctrl_cpp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " csc =\t%" PRIx8 "\t(Clear connect status change)\n", ohci_rh_portctrl_csc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pesc =\t%" PRIx8 "\t(Clear port enable status change)\n", ohci_rh_portctrl_pesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pssc =\t%" PRIx8 "\t(Clear port suspend status change)\n", ohci_rh_portctrl_pssc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocic =\t%" PRIx8 "\t(Clear port overcurrent indicator change)\n", ohci_rh_portctrl_ocic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prsc =\t%" PRIx8 "\t(Clear port reset status change)\n", ohci_rh_portctrl_prsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    return(_r);
}

static inline int ohci_rh_portctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_rh_portctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 256; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = ohci_rh_portctrl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t ohci_rh_portctrl_cpe_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_cpe_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_cpe_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_spe_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_spe_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_spe_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_sps_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_sps_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_sps_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_css_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_css_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_css_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_spr_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_spr_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_spr_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_spp_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_spp_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_spp_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_cpp_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_cpp_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_cpp_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_csc_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_csc_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_csc_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_pesc_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_pesc_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_pesc_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_pssc_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_pssc_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_pssc_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_ocic_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_ocic_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_ocic_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline uint8_t ohci_rh_portctrl_prsc_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t ohci_rh_portctrl_prsc_rd_shadow(__DN(t) *_dev, int _i)
{
    return(ohci_rh_portctrl_prsc_extract((_dev->rh_portctrl_shadow)[_i]));
}

static inline void ohci_rh_portctrl_cpe_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_cpe_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x1 & (((ohci_rh_portctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1f031e & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_spe_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_spe_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x2 & (((ohci_rh_portctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1f031d & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_sps_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_sps_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x4 & (((ohci_rh_portctrl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1f031b & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_css_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_css_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x8 & (((ohci_rh_portctrl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1f0317 & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_spr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_spr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x10 & (((ohci_rh_portctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1f030f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_spp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_spp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x100 & (((ohci_rh_portctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1f021f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_cpp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_cpp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x200 & (((ohci_rh_portctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1f011f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_csc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x10000 & (((ohci_rh_portctrl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1e031f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_pesc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_pesc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x20000 & (((ohci_rh_portctrl_t )(_fieldval)) << 17);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1d031f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_pssc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_pssc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x40000 & (((ohci_rh_portctrl_t )(_fieldval)) << 18);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x1b031f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_ocic_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_ocic_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x80000 & (((ohci_rh_portctrl_t )(_fieldval)) << 19);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0x17031f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline void ohci_rh_portctrl_prsc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void ohci_rh_portctrl_prsc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    ohci_rh_portctrl_t _regval = 0x100000 & (((ohci_rh_portctrl_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffe0fce0 & mackerel_read_addr_32(_dev->base, 0x54 + (_i * (32 / 8)))));
    _regval = (_regval | (0xf031f & ((_dev->rh_portctrl_shadow)[_i])));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x54 + (_i * (32 / 8)), _regval);
    (_dev->rh_portctrl_shadow)[_i] = _regval;
}

static inline int ohci_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int ohci_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device ohci (OHCI USB controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_revision_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_control_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_cmdstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_intstatus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_intenable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_intdisable_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_hcca_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_period_cur_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_ctrl_head_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_ctrl_cur_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_bulk_head_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_bulk_cur_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_done_head_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_fm_interval_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_fm_remain_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_fm_num_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_period_start_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_hclsthreshold_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_rh_descra_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_rh_descrb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_rh_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_rh_portstat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = ohci_rh_portctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device ohci\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __ohci_DEV_H
