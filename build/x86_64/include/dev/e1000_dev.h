#ifndef __e1000_DEV_H
#define __e1000_DEV_H 1
/*
 * DEVICE DEFINITION: Intel e1000 Gigabit Ethernet
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) e1000 ## _ ## x
/*
 * Constants defn: e1000.linkspeed (Link speed)
 *  - no width specified
 */
typedef uint8_t e1000_linkspeed_t;
#define e1000_mb10 ((e1000_linkspeed_t)0x0)
#define e1000_mb100 ((e1000_linkspeed_t)0x1)
#define e1000_mb1000 ((e1000_linkspeed_t)0x2)
#define e1000_mb_notused ((e1000_linkspeed_t)0x3)

static inline char *e1000_linkspeed_describe(e1000_linkspeed_t _e) __attribute__ ((always_inline));
static inline char *e1000_linkspeed_describe(e1000_linkspeed_t _e)
{
    switch (_e) {
    case e1000_mb10:
        return("mb10: 10Mb/s");
    case e1000_mb100:
        return("mb100: 100Mb/s");
    case e1000_mb1000:
        return("mb1000: 1Gb/s");
    case e1000_mb_notused:
        return("mb_notused: 1Gb/s");
    default:
        return(NULL);
    }
}

static inline int e1000_linkspeed_prtval(char *_s, size_t _size, e1000_linkspeed_t _e) __attribute__ ((always_inline));
static inline int e1000_linkspeed_prtval(char *_s, size_t _size, e1000_linkspeed_t _e)
{
    char *d = e1000_linkspeed_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_linkspeed_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.lanid (LAN ID)
 *  - no width specified
 */
typedef uint8_t e1000_lanid_t;
#define e1000_lan_a ((e1000_lanid_t)0x0)
#define e1000_lan_b ((e1000_lanid_t)0x1)
#define e1000_lan_not_u1 ((e1000_lanid_t)0x2)
#define e1000_lan_not_u2 ((e1000_lanid_t)0x3)

static inline char *e1000_lanid_describe(e1000_lanid_t _e) __attribute__ ((always_inline));
static inline char *e1000_lanid_describe(e1000_lanid_t _e)
{
    switch (_e) {
    case e1000_lan_a:
        return("lan_a: LAN A");
    case e1000_lan_b:
        return("lan_b: LAN B");
    case e1000_lan_not_u1:
        return("lan_not_u1: LAN ID not used");
    case e1000_lan_not_u2:
        return("lan_not_u2: LAN ID not used");
    default:
        return(NULL);
    }
}

static inline int e1000_lanid_prtval(char *_s, size_t _size, e1000_lanid_t _e) __attribute__ ((always_inline));
static inline int e1000_lanid_prtval(char *_s, size_t _size, e1000_lanid_t _e)
{
    char *d = e1000_lanid_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_lanid_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.mac_mask (LAN MAC MASK)
 *  - no width specified
 */
typedef uint16_t e1000_mac_mask_t;
#define e1000_lan_b_mask ((e1000_mac_mask_t)0x100)

static inline char *e1000_mac_mask_describe(e1000_mac_mask_t _e) __attribute__ ((always_inline));
static inline char *e1000_mac_mask_describe(e1000_mac_mask_t _e)
{
    switch (_e) {
    case e1000_lan_b_mask:
        return("lan_b_mask: LAN B mask");
    default:
        return(NULL);
    }
}

static inline int e1000_mac_mask_prtval(char *_s, size_t _size, e1000_mac_mask_t _e) __attribute__ ((always_inline));
static inline int e1000_mac_mask_prtval(char *_s, size_t _size, e1000_mac_mask_t _e)
{
    char *d = e1000_mac_mask_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_mac_mask_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.flashenable (Flash write enable control)
 *  - no width specified
 */
typedef uint8_t e1000_flashenable_t;
#define e1000_flash_erase ((e1000_flashenable_t)0x0)
#define e1000_flash_wr_disable ((e1000_flashenable_t)0x1)
#define e1000_flash_wr_enable ((e1000_flashenable_t)0x2)

static inline char *e1000_flashenable_describe(e1000_flashenable_t _e) __attribute__ ((always_inline));
static inline char *e1000_flashenable_describe(e1000_flashenable_t _e)
{
    switch (_e) {
    case e1000_flash_erase:
        return("flash_erase: Flash erase");
    case e1000_flash_wr_disable:
        return("flash_wr_disable: Flash writes discarded");
    case e1000_flash_wr_enable:
        return("flash_wr_enable: Flash writed enabled");
    default:
        return(NULL);
    }
}

static inline int e1000_flashenable_prtval(char *_s, size_t _size, e1000_flashenable_t _e) __attribute__ ((always_inline));
static inline int e1000_flashenable_prtval(char *_s, size_t _size, e1000_flashenable_t _e)
{
    char *d = e1000_flashenable_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_flashenable_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.eeaddrsize (EEPROM address size)
 *  - no width specified
 */
typedef uint8_t e1000_eeaddrsize_t;
#define e1000_bits8or9 ((e1000_eeaddrsize_t)0x0)
#define e1000_bits16 ((e1000_eeaddrsize_t)0x1)

static inline char *e1000_eeaddrsize_describe(e1000_eeaddrsize_t _e) __attribute__ ((always_inline));
static inline char *e1000_eeaddrsize_describe(e1000_eeaddrsize_t _e)
{
    switch (_e) {
    case e1000_bits8or9:
        return("bits8or9: 8- and 9-bit");
    case e1000_bits16:
        return("bits16: 16-bit");
    default:
        return(NULL);
    }
}

static inline int e1000_eeaddrsize_prtval(char *_s, size_t _size, e1000_eeaddrsize_t _e) __attribute__ ((always_inline));
static inline int e1000_eeaddrsize_prtval(char *_s, size_t _size, e1000_eeaddrsize_t _e)
{
    char *d = e1000_eeaddrsize_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_eeaddrsize_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.nvmtype (Non-volatile memory type)
 *  - no width specified
 */
typedef uint8_t e1000_nvmtype_t;
#define e1000_eeprom ((e1000_nvmtype_t)0x0)
#define e1000_saflash ((e1000_nvmtype_t)0x1)
#define e1000_spiflash ((e1000_nvmtype_t)0x2)
#define e1000_sio ((e1000_nvmtype_t)0x3)

static inline char *e1000_nvmtype_describe(e1000_nvmtype_t _e) __attribute__ ((always_inline));
static inline char *e1000_nvmtype_describe(e1000_nvmtype_t _e)
{
    switch (_e) {
    case e1000_eeprom:
        return("eeprom: EEPROM");
    case e1000_saflash:
        return("saflash: Stand-alone Flash");
    case e1000_spiflash:
        return("spiflash: Shared SPI Flash");
    case e1000_sio:
        return("sio: SIO");
    default:
        return(NULL);
    }
}

static inline int e1000_nvmtype_prtval(char *_s, size_t _size, e1000_nvmtype_t _e) __attribute__ ((always_inline));
static inline int e1000_nvmtype_prtval(char *_s, size_t _size, e1000_nvmtype_t _e)
{
    char *d = e1000_nvmtype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_nvmtype_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.linkmode (Link mode)
 *  - no width specified
 */
typedef uint8_t e1000_linkmode_t;
#define e1000_glci ((e1000_linkmode_t)0x0)
#define e1000_l82573 ((e1000_linkmode_t)0x2)
#define e1000_serdes ((e1000_linkmode_t)0x3)

static inline char *e1000_linkmode_describe(e1000_linkmode_t _e) __attribute__ ((always_inline));
static inline char *e1000_linkmode_describe(e1000_linkmode_t _e)
{
    switch (_e) {
    case e1000_glci:
        return("glci: Direct coper or GLCI");
    case e1000_l82573:
        return("l82573: Must be set for 82573E/V/L");
    case e1000_serdes:
        return("serdes: Internal SerDes (TBI) or SerDes mode");
    default:
        return(NULL);
    }
}

static inline int e1000_linkmode_prtval(char *_s, size_t _size, e1000_linkmode_t _e) __attribute__ ((always_inline));
static inline int e1000_linkmode_prtval(char *_s, size_t _size, e1000_linkmode_t _e)
{
    char *d = e1000_linkmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_linkmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.phyop (PHY register opcode)
 *  - no width specified
 */
typedef uint8_t e1000_phyop_t;
#define e1000_mdi_write ((e1000_phyop_t)0x1)
#define e1000_mdi_read ((e1000_phyop_t)0x2)

static inline char *e1000_phyop_describe(e1000_phyop_t _e) __attribute__ ((always_inline));
static inline char *e1000_phyop_describe(e1000_phyop_t _e)
{
    switch (_e) {
    case e1000_mdi_write:
        return("mdi_write: MDI Write");
    case e1000_mdi_read:
        return("mdi_read: MDI Read");
    default:
        return(NULL);
    }
}

static inline int e1000_phyop_prtval(char *_s, size_t _size, e1000_phyop_t _e) __attribute__ ((always_inline));
static inline int e1000_phyop_prtval(char *_s, size_t _size, e1000_phyop_t _e)
{
    char *d = e1000_phyop_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_phyop_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.fca (Flow control address)
 *  - no width specified
 */
typedef uint32_t e1000_fca_t;
#define e1000_fca_lo ((e1000_fca_t)0xc28001)
#define e1000_fca_hi ((e1000_fca_t)0x100)

static inline char *e1000_fca_describe(e1000_fca_t _e) __attribute__ ((always_inline));
static inline char *e1000_fca_describe(e1000_fca_t _e)
{
    switch (_e) {
    case e1000_fca_lo:
        return("fca_lo: fca_lo");
    case e1000_fca_hi:
        return("fca_hi: fca_hi");
    default:
        return(NULL);
    }
}

static inline int e1000_fca_prtval(char *_s, size_t _size, e1000_fca_t _e) __attribute__ ((always_inline));
static inline int e1000_fca_prtval(char *_s, size_t _size, e1000_fca_t _e)
{
    char *d = e1000_fca_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_fca_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.fctval (Flow control type)
 *  - no width specified
 */
typedef uint16_t e1000_fctval_t;
#define e1000_fct_val ((e1000_fctval_t)0x8808)

static inline char *e1000_fctval_describe(e1000_fctval_t _e) __attribute__ ((always_inline));
static inline char *e1000_fctval_describe(e1000_fctval_t _e)
{
    switch (_e) {
    case e1000_fct_val:
        return("fct_val: fct_val");
    default:
        return(NULL);
    }
}

static inline int e1000_fctval_prtval(char *_s, size_t _size, e1000_fctval_t _e) __attribute__ ((always_inline));
static inline int e1000_fctval_prtval(char *_s, size_t _size, e1000_fctval_t _e)
{
    char *d = e1000_fctval_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_fctval_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.vet_val (VLAN ether type value)
 *  - no width specified
 */
typedef uint16_t e1000_vet_val_t;
#define e1000_vlan_type ((e1000_vet_val_t)0x8100)

static inline char *e1000_vet_val_describe(e1000_vet_val_t _e) __attribute__ ((always_inline));
static inline char *e1000_vet_val_describe(e1000_vet_val_t _e)
{
    switch (_e) {
    case e1000_vlan_type:
        return("vlan_type: vlan_type");
    default:
        return(NULL);
    }
}

static inline int e1000_vet_val_prtval(char *_s, size_t _size, e1000_vet_val_t _e) __attribute__ ((always_inline));
static inline int e1000_vet_val_prtval(char *_s, size_t _size, e1000_vet_val_t _e)
{
    char *d = e1000_vet_val_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_vet_val_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.ledmode (LED output mode)
 *  - no width specified
 */
typedef uint8_t e1000_ledmode_t;
#define e1000_link_10_100 ((e1000_ledmode_t)0x0)
#define e1000_link_100_1000 ((e1000_ledmode_t)0x1)
#define e1000_link_up ((e1000_ledmode_t)0x2)
#define e1000_filter_activity ((e1000_ledmode_t)0x3)
#define e1000_link_activity ((e1000_ledmode_t)0x4)
#define e1000_link_10 ((e1000_ledmode_t)0x5)
#define e1000_link_100 ((e1000_ledmode_t)0x6)
#define e1000_link_1000 ((e1000_ledmode_t)0x7)
#define e1000_full_duplex ((e1000_ledmode_t)0x9)
#define e1000_collision ((e1000_ledmode_t)0xa)
#define e1000_activity ((e1000_ledmode_t)0xb)
#define e1000_bus_size ((e1000_ledmode_t)0xc)
#define e1000_paused ((e1000_ledmode_t)0xd)
#define e1000_led_on ((e1000_ledmode_t)0xe)
#define e1000_led_off ((e1000_ledmode_t)0xf)

static inline char *e1000_ledmode_describe(e1000_ledmode_t _e) __attribute__ ((always_inline));
static inline char *e1000_ledmode_describe(e1000_ledmode_t _e)
{
    switch (_e) {
    case e1000_link_10_100:
        return("link_10_100: Either 10 or 100 Mbs link established");
    case e1000_link_100_1000:
        return("link_100_1000: Either 100 or 1000 Mbs link established");
    case e1000_link_up:
        return("link_up: Any speed link established");
    case e1000_filter_activity:
        return("filter_activity: Packets passing MAC filtering");
    case e1000_link_activity:
        return("link_activity: No transmit or receive activity");
    case e1000_link_10:
        return("link_10: 10 Mbs link established");
    case e1000_link_100:
        return("link_100: 100 Mbs link established");
    case e1000_link_1000:
        return("link_1000: 1000 Mbs link established");
    case e1000_full_duplex:
        return("full_duplex: Link configured for full-duplex");
    case e1000_collision:
        return("collision: Collision is observed");
    case e1000_activity:
        return("activity: Link established and packets sent or revd");
    case e1000_bus_size:
        return("bus_size: Controller detects 1 PCIe lane conn.");
    case e1000_paused:
        return("paused: Transmitter is flow controlled");
    case e1000_led_on:
        return("led_on: Always on");
    case e1000_led_off:
        return("led_off: Always off");
    default:
        return(NULL);
    }
}

static inline int e1000_ledmode_prtval(char *_s, size_t _size, e1000_ledmode_t _e) __attribute__ ((always_inline));
static inline int e1000_ledmode_prtval(char *_s, size_t _size, e1000_ledmode_t _e)
{
    char *d = e1000_ledmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_ledmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.blmode (LED blink mode)
 *  - no width specified
 */
typedef uint8_t e1000_blmode_t;
#define e1000_ms200 ((e1000_blmode_t)0x0)
#define e1000_ms83 ((e1000_blmode_t)0x1)

static inline char *e1000_blmode_describe(e1000_blmode_t _e) __attribute__ ((always_inline));
static inline char *e1000_blmode_describe(e1000_blmode_t _e)
{
    switch (_e) {
    case e1000_ms200:
        return("ms200: 200ms on, 200ms off");
    case e1000_ms83:
        return("ms83: 83ms on, 83 ms off");
    default:
        return(NULL);
    }
}

static inline int e1000_blmode_prtval(char *_s, size_t _size, e1000_blmode_t _e) __attribute__ ((always_inline));
static inline int e1000_blmode_prtval(char *_s, size_t _size, e1000_blmode_t _e)
{
    char *d = e1000_blmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_blmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.lbmode (Loopback mode)
 *  - no width specified
 */
typedef uint8_t e1000_lbmode_t;
#define e1000_lb_normal ((e1000_lbmode_t)0x0)
#define e1000_lb_mac ((e1000_lbmode_t)0x1)

static inline char *e1000_lbmode_describe(e1000_lbmode_t _e) __attribute__ ((always_inline));
static inline char *e1000_lbmode_describe(e1000_lbmode_t _e)
{
    switch (_e) {
    case e1000_lb_normal:
        return("lb_normal: Normal operation");
    case e1000_lb_mac:
        return("lb_mac: MAC loopback");
    default:
        return(NULL);
    }
}

static inline int e1000_lbmode_prtval(char *_s, size_t _size, e1000_lbmode_t _e) __attribute__ ((always_inline));
static inline int e1000_lbmode_prtval(char *_s, size_t _size, e1000_lbmode_t _e)
{
    char *d = e1000_lbmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_lbmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.rxthresh (Received desc. threshold size)
 *  - no width specified
 */
typedef uint8_t e1000_rxthresh_t;
#define e1000_rdlen_2 ((e1000_rxthresh_t)0x0)
#define e1000_rdlen_4 ((e1000_rxthresh_t)0x1)
#define e1000_rdlen_8 ((e1000_rxthresh_t)0x2)

static inline char *e1000_rxthresh_describe(e1000_rxthresh_t _e) __attribute__ ((always_inline));
static inline char *e1000_rxthresh_describe(e1000_rxthresh_t _e)
{
    switch (_e) {
    case e1000_rdlen_2:
        return("rdlen_2: 1/2 RDLEN");
    case e1000_rdlen_4:
        return("rdlen_4: 1/4 RDLEN");
    case e1000_rdlen_8:
        return("rdlen_8: 1/8 RDLEN");
    default:
        return(NULL);
    }
}

static inline int e1000_rxthresh_prtval(char *_s, size_t _size, e1000_rxthresh_t _e) __attribute__ ((always_inline));
static inline int e1000_rxthresh_prtval(char *_s, size_t _size, e1000_rxthresh_t _e)
{
    char *d = e1000_rxthresh_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_rxthresh_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.dtype (Descriptor type)
 *  - no width specified
 */
typedef uint8_t e1000_dtype_t;
#define e1000_dt_legacy ((e1000_dtype_t)0x0)
#define e1000_dt_split ((e1000_dtype_t)0x1)

static inline char *e1000_dtype_describe(e1000_dtype_t _e) __attribute__ ((always_inline));
static inline char *e1000_dtype_describe(e1000_dtype_t _e)
{
    switch (_e) {
    case e1000_dt_legacy:
        return("dt_legacy: Legacy descriptor type");
    case e1000_dt_split:
        return("dt_split: Packet split descriptor type");
    default:
        return(NULL);
    }
}

static inline int e1000_dtype_prtval(char *_s, size_t _size, e1000_dtype_t _e) __attribute__ ((always_inline));
static inline int e1000_dtype_prtval(char *_s, size_t _size, e1000_dtype_t _e)
{
    char *d = e1000_dtype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_dtype_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.rxbsize (Receive buffer size)
 *  - no width specified
 */
typedef uint8_t e1000_rxbsize_t;
#define e1000_rxb2048 ((e1000_rxbsize_t)0x0)
#define e1000_rxb1024 ((e1000_rxbsize_t)0x1)
#define e1000_rxb512 ((e1000_rxbsize_t)0x2)
#define e1000_rxb256 ((e1000_rxbsize_t)0x3)

static inline char *e1000_rxbsize_describe(e1000_rxbsize_t _e) __attribute__ ((always_inline));
static inline char *e1000_rxbsize_describe(e1000_rxbsize_t _e)
{
    switch (_e) {
    case e1000_rxb2048:
        return("rxb2048: 2048 bytes");
    case e1000_rxb1024:
        return("rxb1024: 1024 or 16384 bytes");
    case e1000_rxb512:
        return("rxb512: 512 or 8192 bytes");
    case e1000_rxb256:
        return("rxb256: 256 or 4096 bytes");
    default:
        return(NULL);
    }
}

static inline int e1000_rxbsize_prtval(char *_s, size_t _size, e1000_rxbsize_t _e) __attribute__ ((always_inline));
static inline int e1000_rxbsize_prtval(char *_s, size_t _size, e1000_rxbsize_t _e)
{
    char *d = e1000_rxbsize_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_rxbsize_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.threshgran (Threshold granularity)
 *  - no width specified
 */
typedef uint8_t e1000_threshgran_t;
#define e1000_gran_cache ((e1000_threshgran_t)0x0)
#define e1000_gran_desc ((e1000_threshgran_t)0x1)

static inline char *e1000_threshgran_describe(e1000_threshgran_t _e) __attribute__ ((always_inline));
static inline char *e1000_threshgran_describe(e1000_threshgran_t _e)
{
    switch (_e) {
    case e1000_gran_cache:
        return("gran_cache: Cache line granularity");
    case e1000_gran_desc:
        return("gran_desc: Descriptor granularity");
    default:
        return(NULL);
    }
}

static inline int e1000_threshgran_prtval(char *_s, size_t _size, e1000_threshgran_t _e) __attribute__ ((always_inline));
static inline int e1000_threshgran_prtval(char *_s, size_t _size, e1000_threshgran_t _e)
{
    char *d = e1000_threshgran_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_threshgran_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.coldist (Recommended collision distances)
 *  - no width specified
 */
typedef uint16_t e1000_coldist_t;
#define e1000_cd_half ((e1000_coldist_t)0x200)
#define e1000_cd_full ((e1000_coldist_t)0x3f)
#define e1000_cd_esb ((e1000_coldist_t)0x40)

static inline char *e1000_coldist_describe(e1000_coldist_t _e) __attribute__ ((always_inline));
static inline char *e1000_coldist_describe(e1000_coldist_t _e)
{
    switch (_e) {
    case e1000_cd_half:
        return("cd_half: 512 byte-times");
    case e1000_cd_full:
        return("cd_full: 64 byte-times");
    case e1000_cd_esb:
        return("cd_esb: 64 byte-times (for 631xESB/632xESB)");
    default:
        return(NULL);
    }
}

static inline int e1000_coldist_prtval(char *_s, size_t _size, e1000_coldist_t _e) __attribute__ ((always_inline));
static inline int e1000_coldist_prtval(char *_s, size_t _size, e1000_coldist_t _e)
{
    char *d = e1000_coldist_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_coldist_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.addrsel (Address select)
 *  - no width specified
 */
typedef uint8_t e1000_addrsel_t;
#define e1000_as_dest ((e1000_addrsel_t)0x0)
#define e1000_as_src ((e1000_addrsel_t)0x1)

static inline char *e1000_addrsel_describe(e1000_addrsel_t _e) __attribute__ ((always_inline));
static inline char *e1000_addrsel_describe(e1000_addrsel_t _e)
{
    switch (_e) {
    case e1000_as_dest:
        return("as_dest: Destination");
    case e1000_as_src:
        return("as_src: Source");
    default:
        return(NULL);
    }
}

static inline int e1000_addrsel_prtval(char *_s, size_t _size, e1000_addrsel_t _e) __attribute__ ((always_inline));
static inline int e1000_addrsel_prtval(char *_s, size_t _size, e1000_addrsel_t _e)
{
    char *d = e1000_addrsel_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_addrsel_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.mrqen (Multiple rx queue enable)
 *  - no width specified
 */
typedef uint8_t e1000_mrqen_t;
#define e1000_mrq_dis ((e1000_mrqen_t)0x0)
#define e1000_mrq_rss ((e1000_mrqen_t)0x1)

static inline char *e1000_mrqen_describe(e1000_mrqen_t _e) __attribute__ ((always_inline));
static inline char *e1000_mrqen_describe(e1000_mrqen_t _e)
{
    switch (_e) {
    case e1000_mrq_dis:
        return("mrq_dis: Multiple queues disabled");
    case e1000_mrq_rss:
        return("mrq_rss: Multiple queues enabled by MSFT RSS");
    default:
        return(NULL);
    }
}

static inline int e1000_mrqen_prtval(char *_s, size_t _size, e1000_mrqen_t _e) __attribute__ ((always_inline));
static inline int e1000_mrqen_prtval(char *_s, size_t _size, e1000_mrqen_t _e)
{
    char *d = e1000_mrqen_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_mrqen_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.fps (Function power state)
 *  - no width specified
 */
typedef uint8_t e1000_fps_t;
#define e1000_fps_dr ((e1000_fps_t)0x0)
#define e1000_fps_d0u ((e1000_fps_t)0x1)
#define e1000_fps_d0a ((e1000_fps_t)0x2)
#define e1000_fps_d3 ((e1000_fps_t)0x3)

static inline char *e1000_fps_describe(e1000_fps_t _e) __attribute__ ((always_inline));
static inline char *e1000_fps_describe(e1000_fps_t _e)
{
    switch (_e) {
    case e1000_fps_dr:
        return("fps_dr: DR");
    case e1000_fps_d0u:
        return("fps_d0u: D0u");
    case e1000_fps_d0a:
        return("fps_d0a: Doa");
    case e1000_fps_d3:
        return("fps_d3: D3");
    default:
        return(NULL);
    }
}

static inline int e1000_fps_prtval(char *_s, size_t _size, e1000_fps_t _e) __attribute__ ((always_inline));
static inline int e1000_fps_prtval(char *_s, size_t _size, e1000_fps_t _e)
{
    char *d = e1000_fps_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_fps_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.fwmode (Firmware mode)
 *  - no width specified
 */
typedef uint8_t e1000_fwmode_t;
#define e1000_nomng ((e1000_fwmode_t)0x0)
#define e1000_ptmode ((e1000_fwmode_t)0x2)
#define e1000_hieo ((e1000_fwmode_t)0x4)

static inline char *e1000_fwmode_describe(e1000_fwmode_t _e) __attribute__ ((always_inline));
static inline char *e1000_fwmode_describe(e1000_fwmode_t _e)
{
    switch (_e) {
    case e1000_nomng:
        return("nomng: No MNG");
    case e1000_ptmode:
        return("ptmode: PT mode");
    case e1000_hieo:
        return("hieo: Host interface firmware");
    default:
        return(NULL);
    }
}

static inline int e1000_fwmode_prtval(char *_s, size_t _size, e1000_fwmode_t _e) __attribute__ ((always_inline));
static inline int e1000_fwmode_prtval(char *_s, size_t _size, e1000_fwmode_t _e)
{
    char *d = e1000_fwmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_fwmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.pcierr (PCIe external error indication)
 *  - no width specified
 */
typedef uint8_t e1000_pcierr_t;
#define e1000_pe_none ((e1000_pcierr_t)0x0)
#define e1000_pe_mschk ((e1000_pcierr_t)0x1)
#define e1000_pe_prot ((e1000_pcierr_t)0x2)
#define e1000_pe_clkoff ((e1000_pcierr_t)0x3)
#define e1000_pe_flchk ((e1000_pcierr_t)0x4)
#define e1000_pe_pschk ((e1000_pcierr_t)0x5)
#define e1000_pe_lschk ((e1000_pcierr_t)0x6)
#define e1000_pe_dschk ((e1000_pcierr_t)0x7)
#define e1000_pe_inval ((e1000_pcierr_t)0x8)
#define e1000_pe_tlbe ((e1000_pcierr_t)0x9)
#define e1000_pe_eerd ((e1000_pcierr_t)0xa)
#define e1000_pe_hwver ((e1000_pcierr_t)0xb)
#define e1000_pe_sfrd ((e1000_pcierr_t)0xc)
#define e1000_pe_unspec ((e1000_pcierr_t)0xd)
#define e1000_pe_auth ((e1000_pcierr_t)0xe)
#define e1000_pe_pfrd ((e1000_pcierr_t)0xf)
#define e1000_pe_ifep ((e1000_pcierr_t)0x10)

static inline char *e1000_pcierr_describe(e1000_pcierr_t _e) __attribute__ ((always_inline));
static inline char *e1000_pcierr_describe(e1000_pcierr_t _e)
{
    switch (_e) {
    case e1000_pe_none:
        return("pe_none: No error");
    case e1000_pe_mschk:
        return("pe_mschk: Bad checksum in manageability sections");
    case e1000_pe_prot:
        return("pe_prot: EEPROM protection disabled");
    case e1000_pe_clkoff:
        return("pe_clkoff: Clock off command executed");
    case e1000_pe_flchk:
        return("pe_flchk: Bad checksum in flash header");
    case e1000_pe_pschk:
        return("pe_pschk: Bad checksum in patch section");
    case e1000_pe_lschk:
        return("pe_lschk: Bad checksum in loader section");
    case e1000_pe_dschk:
        return("pe_dschk: Bad checksum in diagnostic section");
    case e1000_pe_inval:
        return("pe_inval: Invalid firmware mode");
    case e1000_pe_tlbe:
        return("pe_tlbe: TLB table exceeded");
    case e1000_pe_eerd:
        return("pe_eerd: EEPROM read failed");
    case e1000_pe_hwver:
        return("pe_hwver: Bad hardware version in patch load");
    case e1000_pe_sfrd:
        return("pe_sfrd: SFlash read failed");
    case e1000_pe_unspec:
        return("pe_unspec: Unspecified error");
    case e1000_pe_auth:
        return("pe_auth: Flash authentication failed");
    case e1000_pe_pfrd:
        return("pe_pfrd: PFlash read failed");
    case e1000_pe_ifep:
        return("pe_ifep: Invalid Flash entry point");
    default:
        return(NULL);
    }
}

static inline int e1000_pcierr_prtval(char *_s, size_t _size, e1000_pcierr_t _e) __attribute__ ((always_inline));
static inline int e1000_pcierr_prtval(char *_s, size_t _size, e1000_pcierr_t _e)
{
    char *d = e1000_pcierr_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_pcierr_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e1000.rsstype (RSS computation type)
 *  - no width specified
 */
typedef uint8_t e1000_rsstype_t;
#define e1000_no_rss ((e1000_rsstype_t)0x0)
#define e1000_tcp_v4 ((e1000_rsstype_t)0x1)
#define e1000_ipv4 ((e1000_rsstype_t)0x2)
#define e1000_tcp_v6 ((e1000_rsstype_t)0x3)
#define e1000_ipv6 ((e1000_rsstype_t)0x5)

static inline char *e1000_rsstype_describe(e1000_rsstype_t _e) __attribute__ ((always_inline));
static inline char *e1000_rsstype_describe(e1000_rsstype_t _e)
{
    switch (_e) {
    case e1000_no_rss:
        return("no_rss: No RS computation");
    case e1000_tcp_v4:
        return("tcp_v4: IPv4 with TCP hash");
    case e1000_ipv4:
        return("ipv4: IPv4 hash");
    case e1000_tcp_v6:
        return("tcp_v6: IPv6 with TCP hash");
    case e1000_ipv6:
        return("ipv6: IPv6 hash");
    default:
        return(NULL);
    }
}

static inline int e1000_rsstype_prtval(char *_s, size_t _size, e1000_rsstype_t _e) __attribute__ ((always_inline));
static inline int e1000_rsstype_prtval(char *_s, size_t _size, e1000_rsstype_t _e)
{
    char *d = e1000_rsstype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e1000_rsstype_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: e1000_ctrl_t
 * Description: Implicit type of Device control register
 * Fields:
 *   fd	(size 1, offset 0, init 0):	RW	full-duplex
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   gio_md	(size 1, offset 2, init 0):	RW	GIO master disable
 *   lrst	(size 1, offset 3, init 0):	RW	Link reset
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   asde	(size 1, offset 5, init 0):	RW	Auto-Speed Detection Enable
 *   slu	(size 1, offset 6, init 0):	RW	Set link up
 *   ilos	(size 1, offset 7, init 0):	RW	Invert Loss-of-Signal (LOS)
 *   speed	(size 2, offset 8, init 0):	RW	Speed selection
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   frcspd	(size 1, offset 11, init 0):	RW	Force speed
 *   frcdplx	(size 1, offset 12, init 0):	RW	Force duplex
 *   _anon13	(size 5, offset 13, init 0):	MBZ	_
 *   sdp0_data	(size 1, offset 18, init 0):	RW	SDP0 data value, or dock/undock status
 *   sdp1_data	(size 1, offset 19, init 0):	RW	SDP1 data value
 *   advd3wuc	(size 1, offset 20, init 0):	RW	D3cold wakeup capability
 *   en_phy_pwr_mgmt	(size 1, offset 21, init 0):	RW	PHY Power-Management Enable
 *   sdp0_iodir	(size 1, offset 22, init 0):	RW	SDP0 pin I/O directionality
 *   sdp1_iodir	(size 1, offset 23, init 0):	RW	SDP1 pin I/O directionality
 *   _anon24	(size 2, offset 24, init 0):	MBZ	_
 *   rst	(size 1, offset 26, init 0):	RW	Device reset
 *   rfce	(size 1, offset 27, init 0):	RW	Receive flow control enable
 *   tfce	(size 1, offset 28, init 0):	RW	Transmit flow control enable
 *   _anon29	(size 1, offset 29, init 0):	MBZ	_
 *   vme	(size 1, offset 30, init 0):	RW	VLAN mode enable
 *   phy_rst	(size 1, offset 31, init 0):	RW	PHY reset
 */
typedef uint32_t e1000_ctrl_t;
#define e1000_ctrl_default 0x0
static inline uint8_t e1000_ctrl_fd_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_fd_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_ctrl_t e1000_ctrl_fd_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_fd_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_ctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_ctrl_gio_md_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_gio_md_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_ctrl_t e1000_ctrl_gio_md_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_gio_md_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_ctrl_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_ctrl_lrst_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_lrst_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_ctrl_t e1000_ctrl_lrst_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_lrst_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_ctrl_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_ctrl_asde_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_asde_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_ctrl_t e1000_ctrl_asde_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_asde_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_ctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_ctrl_slu_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_slu_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_ctrl_t e1000_ctrl_slu_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_slu_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_ctrl_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_ctrl_ilos_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_ilos_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_ctrl_t e1000_ctrl_ilos_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_ilos_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_ctrl_t )(_fieldval)) << 7)));
}

static inline e1000_linkspeed_t e1000_ctrl_speed_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_ctrl_speed_extract(e1000_ctrl_t _regval)
{
    return((e1000_linkspeed_t )((_regval & 0x300) >> 8));
}

static inline e1000_ctrl_t e1000_ctrl_speed_insert(e1000_ctrl_t _regval, e1000_linkspeed_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_speed_insert(e1000_ctrl_t _regval, e1000_linkspeed_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((e1000_ctrl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_ctrl_frcspd_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_frcspd_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e1000_ctrl_t e1000_ctrl_frcspd_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_frcspd_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e1000_ctrl_t )(_fieldval)) << 11)));
}

static inline uint8_t e1000_ctrl_frcdplx_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_frcdplx_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e1000_ctrl_t e1000_ctrl_frcdplx_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_frcdplx_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e1000_ctrl_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_ctrl_sdp0_data_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp0_data_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_ctrl_t e1000_ctrl_sdp0_data_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_sdp0_data_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_ctrl_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_ctrl_sdp1_data_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp1_data_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_ctrl_t e1000_ctrl_sdp1_data_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_sdp1_data_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_ctrl_t )(_fieldval)) << 19)));
}

static inline uint8_t e1000_ctrl_advd3wuc_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_advd3wuc_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_ctrl_t e1000_ctrl_advd3wuc_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_advd3wuc_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_ctrl_t )(_fieldval)) << 20)));
}

static inline uint8_t e1000_ctrl_en_phy_pwr_mgmt_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_en_phy_pwr_mgmt_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e1000_ctrl_t e1000_ctrl_en_phy_pwr_mgmt_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_en_phy_pwr_mgmt_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_ctrl_t )(_fieldval)) << 21)));
}

static inline uint8_t e1000_ctrl_sdp0_iodir_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp0_iodir_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e1000_ctrl_t e1000_ctrl_sdp0_iodir_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_sdp0_iodir_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e1000_ctrl_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_ctrl_sdp1_iodir_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp1_iodir_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e1000_ctrl_t e1000_ctrl_sdp1_iodir_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_sdp1_iodir_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e1000_ctrl_t )(_fieldval)) << 23)));
}

static inline uint8_t e1000_ctrl_rst_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_rst_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e1000_ctrl_t e1000_ctrl_rst_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_rst_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e1000_ctrl_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_ctrl_rfce_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_rfce_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_ctrl_t e1000_ctrl_rfce_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_rfce_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_ctrl_t )(_fieldval)) << 27)));
}

static inline uint8_t e1000_ctrl_tfce_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_tfce_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_ctrl_t e1000_ctrl_tfce_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_tfce_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_ctrl_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_ctrl_vme_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_vme_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_ctrl_t e1000_ctrl_vme_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_vme_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_ctrl_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_ctrl_phy_rst_extract(e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_phy_rst_extract(e1000_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_ctrl_t e1000_ctrl_phy_rst_insert(e1000_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_phy_rst_insert(e1000_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_ctrl_t )(_fieldval)) << 31)));
}

static inline int e1000_ctrl_prtval(char *_s, size_t _size, e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline int e1000_ctrl_prtval(char *_s, size_t _size, e1000_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fd =\t%" PRIx8 "\t(full-duplex)\n", e1000_ctrl_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_md =\t%" PRIx8 "\t(GIO master disable)\n", e1000_ctrl_gio_md_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrst =\t%" PRIx8 "\t(Link reset)\n", e1000_ctrl_lrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asde =\t%" PRIx8 "\t(Auto-Speed Detection Enable)\n", e1000_ctrl_asde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slu =\t%" PRIx8 "\t(Set link up)\n", e1000_ctrl_slu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ilos =\t%" PRIx8 "\t(Invert Loss-of-Signal (LOS))\n", e1000_ctrl_ilos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_ctrl_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Speed selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcspd =\t%" PRIx8 "\t(Force speed)\n", e1000_ctrl_frcspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcdplx =\t%" PRIx8 "\t(Force duplex)\n", e1000_ctrl_frcdplx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_data =\t%" PRIx8 "\t(SDP0 data value, or dock/undock status)\n", e1000_ctrl_sdp0_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_data =\t%" PRIx8 "\t(SDP1 data value)\n", e1000_ctrl_sdp1_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " advd3wuc =\t%" PRIx8 "\t(D3cold wakeup capability)\n", e1000_ctrl_advd3wuc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_phy_pwr_mgmt =\t%" PRIx8 "\t(PHY Power-Management Enable)\n", e1000_ctrl_en_phy_pwr_mgmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_iodir =\t%" PRIx8 "\t(SDP0 pin I/O directionality)\n", e1000_ctrl_sdp0_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_iodir =\t%" PRIx8 "\t(SDP1 pin I/O directionality)\n", e1000_ctrl_sdp1_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e1000_ctrl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfce =\t%" PRIx8 "\t(Receive flow control enable)\n", e1000_ctrl_rfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfce =\t%" PRIx8 "\t(Transmit flow control enable)\n", e1000_ctrl_tfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN mode enable)\n", e1000_ctrl_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_rst =\t%" PRIx8 "\t(PHY reset)\n", e1000_ctrl_phy_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ctrldup_t
 * Description: Implicit type of Device Control Duplicate (Shadow) register
 * Fields:
 *   fd	(size 1, offset 0, init 0):	RW	full-duplex
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   gio_md	(size 1, offset 2, init 0):	RW	GIO master disable
 *   lrst	(size 1, offset 3, init 0):	RW	Link reset
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   asde	(size 1, offset 5, init 0):	RW	Auto-Speed Detection Enable
 *   slu	(size 1, offset 6, init 0):	RW	Set link up
 *   ilos	(size 1, offset 7, init 0):	RW	Invert Loss-of-Signal (LOS)
 *   speed	(size 2, offset 8, init 0):	RW	Speed selection
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   frcspd	(size 1, offset 11, init 0):	RW	Force speed
 *   frcdplx	(size 1, offset 12, init 0):	RW	Force duplex
 *   _anon13	(size 5, offset 13, init 0):	MBZ	_
 *   sdp0_data	(size 1, offset 18, init 0):	RW	SDP0 data value, or dock/undock status
 *   sdp1_data	(size 1, offset 19, init 0):	RW	SDP1 data value
 *   advd3wuc	(size 1, offset 20, init 0):	RW	D3cold wakeup capability
 *   en_phy_pwr_mgmt	(size 1, offset 21, init 0):	RW	PHY Power-Management Enable
 *   sdp0_iodir	(size 1, offset 22, init 0):	RW	SDP0 pin I/O directionality
 *   sdp1_iodir	(size 1, offset 23, init 0):	RW	SDP1 pin I/O directionality
 *   _anon24	(size 2, offset 24, init 0):	MBZ	_
 *   rst	(size 1, offset 26, init 0):	RW	Device reset
 *   rfce	(size 1, offset 27, init 0):	RW	Receive flow control enable
 *   tfce	(size 1, offset 28, init 0):	RW	Transmit flow control enable
 *   _anon29	(size 1, offset 29, init 0):	MBZ	_
 *   vme	(size 1, offset 30, init 0):	RW	VLAN mode enable
 *   phy_rst	(size 1, offset 31, init 0):	RW	PHY reset
 */
typedef uint32_t e1000_ctrldup_t;
#define e1000_ctrldup_default 0x0
static inline uint8_t e1000_ctrldup_fd_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_fd_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_ctrldup_t e1000_ctrldup_fd_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_fd_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_ctrldup_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_ctrldup_gio_md_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_gio_md_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_ctrldup_t e1000_ctrldup_gio_md_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_gio_md_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_ctrldup_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_ctrldup_lrst_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_lrst_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_ctrldup_t e1000_ctrldup_lrst_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_lrst_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_ctrldup_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_ctrldup_asde_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_asde_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_ctrldup_t e1000_ctrldup_asde_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_asde_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_ctrldup_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_ctrldup_slu_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_slu_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_ctrldup_t e1000_ctrldup_slu_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_slu_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_ctrldup_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_ctrldup_ilos_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_ilos_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_ctrldup_t e1000_ctrldup_ilos_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_ilos_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_ctrldup_t )(_fieldval)) << 7)));
}

static inline e1000_linkspeed_t e1000_ctrldup_speed_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_ctrldup_speed_extract(e1000_ctrldup_t _regval)
{
    return((e1000_linkspeed_t )((_regval & 0x300) >> 8));
}

static inline e1000_ctrldup_t e1000_ctrldup_speed_insert(e1000_ctrldup_t _regval, e1000_linkspeed_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_speed_insert(e1000_ctrldup_t _regval, e1000_linkspeed_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((e1000_ctrldup_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_ctrldup_frcspd_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_frcspd_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e1000_ctrldup_t e1000_ctrldup_frcspd_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_frcspd_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e1000_ctrldup_t )(_fieldval)) << 11)));
}

static inline uint8_t e1000_ctrldup_frcdplx_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_frcdplx_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e1000_ctrldup_t e1000_ctrldup_frcdplx_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_frcdplx_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e1000_ctrldup_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_ctrldup_sdp0_data_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp0_data_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_ctrldup_t e1000_ctrldup_sdp0_data_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_sdp0_data_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_ctrldup_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_ctrldup_sdp1_data_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp1_data_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_ctrldup_t e1000_ctrldup_sdp1_data_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_sdp1_data_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_ctrldup_t )(_fieldval)) << 19)));
}

static inline uint8_t e1000_ctrldup_advd3wuc_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_advd3wuc_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_ctrldup_t e1000_ctrldup_advd3wuc_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_advd3wuc_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_ctrldup_t )(_fieldval)) << 20)));
}

static inline uint8_t e1000_ctrldup_en_phy_pwr_mgmt_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_en_phy_pwr_mgmt_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e1000_ctrldup_t e1000_ctrldup_en_phy_pwr_mgmt_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_en_phy_pwr_mgmt_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_ctrldup_t )(_fieldval)) << 21)));
}

static inline uint8_t e1000_ctrldup_sdp0_iodir_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp0_iodir_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e1000_ctrldup_t e1000_ctrldup_sdp0_iodir_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_sdp0_iodir_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e1000_ctrldup_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_ctrldup_sdp1_iodir_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp1_iodir_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e1000_ctrldup_t e1000_ctrldup_sdp1_iodir_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_sdp1_iodir_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e1000_ctrldup_t )(_fieldval)) << 23)));
}

static inline uint8_t e1000_ctrldup_rst_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_rst_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e1000_ctrldup_t e1000_ctrldup_rst_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_rst_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e1000_ctrldup_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_ctrldup_rfce_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_rfce_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_ctrldup_t e1000_ctrldup_rfce_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_rfce_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_ctrldup_t )(_fieldval)) << 27)));
}

static inline uint8_t e1000_ctrldup_tfce_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_tfce_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_ctrldup_t e1000_ctrldup_tfce_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_tfce_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_ctrldup_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_ctrldup_vme_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_vme_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_ctrldup_t e1000_ctrldup_vme_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_vme_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_ctrldup_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_ctrldup_phy_rst_extract(e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_phy_rst_extract(e1000_ctrldup_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_ctrldup_t e1000_ctrldup_phy_rst_insert(e1000_ctrldup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_phy_rst_insert(e1000_ctrldup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_ctrldup_t )(_fieldval)) << 31)));
}

static inline int e1000_ctrldup_prtval(char *_s, size_t _size, e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline int e1000_ctrldup_prtval(char *_s, size_t _size, e1000_ctrldup_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fd =\t%" PRIx8 "\t(full-duplex)\n", e1000_ctrldup_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_md =\t%" PRIx8 "\t(GIO master disable)\n", e1000_ctrldup_gio_md_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrst =\t%" PRIx8 "\t(Link reset)\n", e1000_ctrldup_lrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asde =\t%" PRIx8 "\t(Auto-Speed Detection Enable)\n", e1000_ctrldup_asde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slu =\t%" PRIx8 "\t(Set link up)\n", e1000_ctrldup_slu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ilos =\t%" PRIx8 "\t(Invert Loss-of-Signal (LOS))\n", e1000_ctrldup_ilos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_ctrldup_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Speed selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcspd =\t%" PRIx8 "\t(Force speed)\n", e1000_ctrldup_frcspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcdplx =\t%" PRIx8 "\t(Force duplex)\n", e1000_ctrldup_frcdplx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_data =\t%" PRIx8 "\t(SDP0 data value, or dock/undock status)\n", e1000_ctrldup_sdp0_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_data =\t%" PRIx8 "\t(SDP1 data value)\n", e1000_ctrldup_sdp1_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " advd3wuc =\t%" PRIx8 "\t(D3cold wakeup capability)\n", e1000_ctrldup_advd3wuc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_phy_pwr_mgmt =\t%" PRIx8 "\t(PHY Power-Management Enable)\n", e1000_ctrldup_en_phy_pwr_mgmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_iodir =\t%" PRIx8 "\t(SDP0 pin I/O directionality)\n", e1000_ctrldup_sdp0_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_iodir =\t%" PRIx8 "\t(SDP1 pin I/O directionality)\n", e1000_ctrldup_sdp1_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e1000_ctrldup_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfce =\t%" PRIx8 "\t(Receive flow control enable)\n", e1000_ctrldup_rfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfce =\t%" PRIx8 "\t(Transmit flow control enable)\n", e1000_ctrldup_tfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN mode enable)\n", e1000_ctrldup_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_rst =\t%" PRIx8 "\t(PHY reset)\n", e1000_ctrldup_phy_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_status_t
 * Description: Implicit type of Device status register
 * Fields:
 *   fd	(size 1, offset 0, init 0):	RO	Link full duplex configuration
 *   lu	(size 1, offset 1, init 0):	RO	Link up
 *   func_id	(size 2, offset 2, init 0):	RO	Function ID
 *   txoff	(size 1, offset 4, init 0):	RO	Transmission paused
 *   tbimode	(size 1, offset 5, init 0):	RO	TBI mode
 *   speed	(size 2, offset 6, init 0):	RO	Link speed setting
 *   asdv	(size 2, offset 8, init 0):	RO	Auto speed detection value
 *   phyra	(size 1, offset 10, init 0):	RO	PHY reset asserted
 *   pci66	(size 1, offset 11, init 0):	RO	PCI Bus speed indication
 *   bus64	(size 1, offset 12, init 0):	RO	PCI Bus Width indication
 *   pcix_mode	(size 1, offset 13, init 0):	RO	PCI-X Mode indication
 *   pcixspd	(size 2, offset 14, init 0):	RO	PCI-X Bus Speed Indication
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   gio_mes	(size 1, offset 19, init 0):	RO	GIO master enable status
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t e1000_status_t;
#define e1000_status_default 0x0
static inline uint8_t e1000_status_fd_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_fd_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_status_t e1000_status_fd_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_fd_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_status_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_status_lu_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_lu_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_status_t e1000_status_lu_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_lu_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_status_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_status_func_id_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_func_id_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0xc) >> 2));
}

static inline e1000_status_t e1000_status_func_id_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_func_id_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((e1000_status_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_status_txoff_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_txoff_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_status_t e1000_status_txoff_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_txoff_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_status_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_status_tbimode_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_tbimode_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_status_t e1000_status_tbimode_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_tbimode_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_status_t )(_fieldval)) << 5)));
}

static inline e1000_linkspeed_t e1000_status_speed_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_status_speed_extract(e1000_status_t _regval)
{
    return((e1000_linkspeed_t )((_regval & 0xc0) >> 6));
}

static inline e1000_status_t e1000_status_speed_insert(e1000_status_t _regval, e1000_linkspeed_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_speed_insert(e1000_status_t _regval, e1000_linkspeed_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((e1000_status_t )(_fieldval)) << 6)));
}

static inline e1000_linkspeed_t e1000_status_asdv_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_status_asdv_extract(e1000_status_t _regval)
{
    return((e1000_linkspeed_t )((_regval & 0x300) >> 8));
}

static inline e1000_status_t e1000_status_asdv_insert(e1000_status_t _regval, e1000_linkspeed_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_asdv_insert(e1000_status_t _regval, e1000_linkspeed_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((e1000_status_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_status_phyra_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_phyra_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_status_t e1000_status_phyra_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_phyra_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_status_t )(_fieldval)) << 10)));
}

static inline uint8_t e1000_status_pci66_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_pci66_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e1000_status_t e1000_status_pci66_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_pci66_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e1000_status_t )(_fieldval)) << 11)));
}

static inline uint8_t e1000_status_bus64_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_bus64_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e1000_status_t e1000_status_bus64_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_bus64_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e1000_status_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_status_pcix_mode_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_pcix_mode_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e1000_status_t e1000_status_pcix_mode_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_pcix_mode_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e1000_status_t )(_fieldval)) << 13)));
}

static inline uint8_t e1000_status_pcixspd_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_pcixspd_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline e1000_status_t e1000_status_pcixspd_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_pcixspd_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((e1000_status_t )(_fieldval)) << 14)));
}

static inline uint8_t e1000_status_gio_mes_extract(e1000_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_status_gio_mes_extract(e1000_status_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_status_t e1000_status_gio_mes_insert(e1000_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_gio_mes_insert(e1000_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_status_t )(_fieldval)) << 19)));
}

static inline int e1000_status_prtval(char *_s, size_t _size, e1000_status_t _regval) __attribute__ ((always_inline));
static inline int e1000_status_prtval(char *_s, size_t _size, e1000_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fd =\t%" PRIx8 "\t(Link full duplex configuration)\n", e1000_status_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lu =\t%" PRIx8 "\t(Link up)\n", e1000_status_lu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " func_id =\t%" PRIx8 "\t(Function ID)\n", e1000_status_func_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txoff =\t%" PRIx8 "\t(Transmission paused)\n", e1000_status_txoff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tbimode =\t%" PRIx8 "\t(TBI mode)\n", e1000_status_tbimode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_status_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link speed setting)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asdv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_status_asdv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto speed detection value)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phyra =\t%" PRIx8 "\t(PHY reset asserted)\n", e1000_status_phyra_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci66 =\t%" PRIx8 "\t(PCI Bus speed indication)\n", e1000_status_pci66_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bus64 =\t%" PRIx8 "\t(PCI Bus Width indication)\n", e1000_status_bus64_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcix_mode =\t%" PRIx8 "\t(PCI-X Mode indication)\n", e1000_status_pcix_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcixspd =\t%" PRIx8 "\t(PCI-X Bus Speed Indication)\n", e1000_status_pcixspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_mes =\t%" PRIx8 "\t(GIO master enable status)\n", e1000_status_gio_mes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_eecd_t
 * Description: Implicit type of EEPROM/Flash control register
 * Fields:
 *   ee_sk	(size 1, offset 0, init 0):	RW	Clock input to EEPROM
 *   ee_cs	(size 1, offset 1, init 0):	RW	Chip select to EEPROM
 *   ee_di	(size 1, offset 2, init 0):	RW	Data input to EEPROM
 *   ee_do	(size 1, offset 3, init 0):	RW	Data output bit from EEPROM
 *   fwe	(size 2, offset 4, init 0):	RW	Flash write enable control
 *   ee_req	(size 1, offset 6, init 0):	RW	Request EEPROM access
 *   ee_gnt	(size 1, offset 7, init 0):	RW	Grant EEPROM access
 *   ee_pres	(size 1, offset 8, init 0):	RW	EEPROM present
 *   ee_size_n	(size 1, offset 9, init 0):	RW	EEPROM size for NM93C46 compatible EEPROM
 *   ee_size_m	(size 1, offset 10, init 0):	RW	EEPROM size for Microwire EEPROMs
 *   _anon11	(size 2, offset 11, init 0):	MBZ	_
 *   ee_type	(size 1, offset 13, init 0):	RW	EEPROM Type. (82541xx and 82547GI/EI)
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
typedef uint32_t e1000_eecd_t;
#define e1000_eecd_default 0x0
static inline uint8_t e1000_eecd_ee_sk_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_sk_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_eecd_t e1000_eecd_ee_sk_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_sk_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_eecd_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_eecd_ee_cs_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_cs_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_eecd_t e1000_eecd_ee_cs_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_cs_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_eecd_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_eecd_ee_di_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_di_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_eecd_t e1000_eecd_ee_di_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_di_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_eecd_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_eecd_ee_do_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_do_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_eecd_t e1000_eecd_ee_do_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_do_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_eecd_t )(_fieldval)) << 3)));
}

static inline e1000_flashenable_t e1000_eecd_fwe_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline e1000_flashenable_t e1000_eecd_fwe_extract(e1000_eecd_t _regval)
{
    return((e1000_flashenable_t )((_regval & 0x30) >> 4));
}

static inline e1000_eecd_t e1000_eecd_fwe_insert(e1000_eecd_t _regval, e1000_flashenable_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_fwe_insert(e1000_eecd_t _regval, e1000_flashenable_t _fieldval)
{
    return((_regval & 0xffffffcf) | (0x30 & (((e1000_eecd_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_eecd_ee_req_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_req_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_eecd_t e1000_eecd_ee_req_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_req_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_eecd_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_eecd_ee_gnt_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_gnt_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_eecd_t e1000_eecd_ee_gnt_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_gnt_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_eecd_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_eecd_ee_pres_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_pres_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e1000_eecd_t e1000_eecd_ee_pres_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_pres_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e1000_eecd_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_eecd_ee_size_n_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_size_n_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e1000_eecd_t e1000_eecd_ee_size_n_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_size_n_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e1000_eecd_t )(_fieldval)) << 9)));
}

static inline uint8_t e1000_eecd_ee_size_m_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_size_m_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_eecd_t e1000_eecd_ee_size_m_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_size_m_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_eecd_t )(_fieldval)) << 10)));
}

static inline uint8_t e1000_eecd_ee_type_extract(e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_type_extract(e1000_eecd_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e1000_eecd_t e1000_eecd_ee_type_insert(e1000_eecd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_ee_type_insert(e1000_eecd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e1000_eecd_t )(_fieldval)) << 13)));
}

static inline int e1000_eecd_prtval(char *_s, size_t _size, e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline int e1000_eecd_prtval(char *_s, size_t _size, e1000_eecd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_sk =\t%" PRIx8 "\t(Clock input to EEPROM)\n", e1000_eecd_ee_sk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_cs =\t%" PRIx8 "\t(Chip select to EEPROM)\n", e1000_eecd_ee_cs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_di =\t%" PRIx8 "\t(Data input to EEPROM)\n", e1000_eecd_ee_di_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_do =\t%" PRIx8 "\t(Data output bit from EEPROM)\n", e1000_eecd_ee_do_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_flashenable_prtval(_s + _r, _avail, e1000_eecd_fwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Flash write enable control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_req =\t%" PRIx8 "\t(Request EEPROM access)\n", e1000_eecd_ee_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_gnt =\t%" PRIx8 "\t(Grant EEPROM access)\n", e1000_eecd_ee_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_pres =\t%" PRIx8 "\t(EEPROM present)\n", e1000_eecd_ee_pres_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_size_n =\t%" PRIx8 "\t(EEPROM size for NM93C46 compatible EEPROM)\n", e1000_eecd_ee_size_n_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_size_m =\t%" PRIx8 "\t(EEPROM size for Microwire EEPROMs)\n", e1000_eecd_ee_size_m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_type =\t%" PRIx8 "\t(EEPROM Type. (82541xx and 82547GI/EI))\n", e1000_eecd_ee_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_eerd_nm_t
 * Description: Implicit type of EEPROM read register
 * Fields:
 *   start	(size 1, offset 0, init 0):	RW	Start read
 *   _anon1	(size 3, offset 1, init 0):	MBZ	_
 *   done	(size 1, offset 4, init 0):	RO	Read done
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   addr	(size 8, offset 8, init 0):	RW	Read address
 *   data	(size 16, offset 16, init 0):	RW	Read data
 */
typedef uint32_t e1000_eerd_nm_t;
#define e1000_eerd_nm_default 0x0
static inline uint8_t e1000_eerd_nm_start_extract(e1000_eerd_nm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_nm_start_extract(e1000_eerd_nm_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_eerd_nm_t e1000_eerd_nm_start_insert(e1000_eerd_nm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_nm_t e1000_eerd_nm_start_insert(e1000_eerd_nm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_eerd_nm_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_eerd_nm_done_extract(e1000_eerd_nm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_nm_done_extract(e1000_eerd_nm_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_eerd_nm_t e1000_eerd_nm_done_insert(e1000_eerd_nm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_nm_t e1000_eerd_nm_done_insert(e1000_eerd_nm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_eerd_nm_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_eerd_nm_addr_extract(e1000_eerd_nm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_nm_addr_extract(e1000_eerd_nm_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_eerd_nm_t e1000_eerd_nm_addr_insert(e1000_eerd_nm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_nm_t e1000_eerd_nm_addr_insert(e1000_eerd_nm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_eerd_nm_t )(_fieldval)) << 8)));
}

static inline uint16_t e1000_eerd_nm_data_extract(e1000_eerd_nm_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_eerd_nm_data_extract(e1000_eerd_nm_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e1000_eerd_nm_t e1000_eerd_nm_data_insert(e1000_eerd_nm_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_nm_t e1000_eerd_nm_data_insert(e1000_eerd_nm_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e1000_eerd_nm_t )(_fieldval)) << 16)));
}

static inline int e1000_eerd_nm_prtval(char *_s, size_t _size, e1000_eerd_nm_t _regval) __attribute__ ((always_inline));
static inline int e1000_eerd_nm_prtval(char *_s, size_t _size, e1000_eerd_nm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start read)\n", e1000_eerd_nm_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read done)\n", e1000_eerd_nm_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx8 "\t(Read address)\n", e1000_eerd_nm_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Read data)\n", e1000_eerd_nm_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_eerd_ms_t
 * Description: Implicit type of EEPROM read 82541xx and 82547GI/EI register
 * Fields:
 *   start	(size 1, offset 0, init 0):	RW	Start read
 *   done	(size 1, offset 1, init 0):	RO	Read done
 *   addr	(size 14, offset 2, init 0):	RW	Read address
 *   data	(size 16, offset 16, init 0):	RW	Read data
 */
typedef uint32_t e1000_eerd_ms_t;
#define e1000_eerd_ms_default 0x0
static inline uint8_t e1000_eerd_ms_start_extract(e1000_eerd_ms_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_ms_start_extract(e1000_eerd_ms_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_eerd_ms_t e1000_eerd_ms_start_insert(e1000_eerd_ms_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_ms_t e1000_eerd_ms_start_insert(e1000_eerd_ms_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_eerd_ms_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_eerd_ms_done_extract(e1000_eerd_ms_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_ms_done_extract(e1000_eerd_ms_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_eerd_ms_t e1000_eerd_ms_done_insert(e1000_eerd_ms_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_ms_t e1000_eerd_ms_done_insert(e1000_eerd_ms_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_eerd_ms_t )(_fieldval)) << 1)));
}

static inline uint16_t e1000_eerd_ms_addr_extract(e1000_eerd_ms_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_eerd_ms_addr_extract(e1000_eerd_ms_t _regval)
{
    return((uint16_t )((_regval & 0xfffc) >> 2));
}

static inline e1000_eerd_ms_t e1000_eerd_ms_addr_insert(e1000_eerd_ms_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_ms_t e1000_eerd_ms_addr_insert(e1000_eerd_ms_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0003) | (0xfffc & (((e1000_eerd_ms_t )(_fieldval)) << 2)));
}

static inline uint16_t e1000_eerd_ms_data_extract(e1000_eerd_ms_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_eerd_ms_data_extract(e1000_eerd_ms_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e1000_eerd_ms_t e1000_eerd_ms_data_insert(e1000_eerd_ms_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eerd_ms_t e1000_eerd_ms_data_insert(e1000_eerd_ms_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e1000_eerd_ms_t )(_fieldval)) << 16)));
}

static inline int e1000_eerd_ms_prtval(char *_s, size_t _size, e1000_eerd_ms_t _regval) __attribute__ ((always_inline));
static inline int e1000_eerd_ms_prtval(char *_s, size_t _size, e1000_eerd_ms_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start read)\n", e1000_eerd_ms_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read done)\n", e1000_eerd_ms_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Read address)\n", e1000_eerd_ms_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Read data)\n", e1000_eerd_ms_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ctrlext_t
 * Description: Implicit type of Extended device control register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   sdp2_gpien	(size 1, offset 2, init 0):	RW	General-purpose interrupt detection for SDP2
 *   sdp3_gpien	(size 1, offset 3, init 0):	RW	General-purpose interrupt detection for SDP3
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   sdp2_data	(size 1, offset 6, init 0):	RW	SDP2 data value
 *   sdp3_data	(size 1, offset 7, init 0):	RW	SDP3 data value
 *   _anon8	(size 2, offset 8, init 0):	MBZ	_
 *   sdp2_iodir	(size 1, offset 10, init 0):	RW	SDP2 pin directionality
 *   sdp3_iodir	(size 1, offset 11, init 0):	RW	SDP3 pin directionality
 *   asdchk	(size 1, offset 12, init 0):	RW	Auto-speed-detection check
 *   ee_rst	(size 1, offset 13, init 0):	RW	EEPROM reset
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   spd_byps	(size 1, offset 15, init 0):	RW	Speed select bypass
 *   _anon16	(size 1, offset 16, init 0):	RSVD	_
 *   rodis	(size 1, offset 17, init 0):	RW	Relaxed ordering disabled
 *   serdeslpe	(size 1, offset 18, init 0):	RW	SERDES low power enable
 *   dmadge	(size 1, offset 19, init 0):	RW	DMA dynamic gating enable
 *   phypde	(size 1, offset 20, init 0):	RW	PHY power down enable
 *   _anon21	(size 1, offset 21, init 0):	RSVD	_
 *   link_mode	(size 2, offset 22, init 0):	RW	Link mode
 *   pb_paren	(size 1, offset 24, init 0):	RW	Packet buffer parity error detection enable
 *   df_paren	(size 1, offset 25, init 0):	RW	Descriptor FIFO parity error detection enable
 *   _anon26	(size 1, offset 26, init 0):	MBZ	_
 *   iame	(size 1, offset 27, init 0):	RW	Interrupt acknowledge auto-mask enable
 *   drv_load	(size 1, offset 28, init 0):	RW	Driver loaded
 *   int_tca	(size 1, offset 29, init 0):	RW	Timers clear enable
 *   host_paren	(size 1, offset 30, init 0):	RW	Host data FIFO parity enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e1000_ctrlext_t;
#define e1000_ctrlext_default 0x0
static inline uint8_t e1000_ctrlext_sdp2_gpien_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp2_gpien_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_ctrlext_t e1000_ctrlext_sdp2_gpien_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_sdp2_gpien_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_ctrlext_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_ctrlext_sdp3_gpien_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp3_gpien_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_ctrlext_t e1000_ctrlext_sdp3_gpien_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_sdp3_gpien_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_ctrlext_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_ctrlext_sdp2_data_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp2_data_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_ctrlext_t e1000_ctrlext_sdp2_data_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_sdp2_data_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_ctrlext_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_ctrlext_sdp3_data_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp3_data_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_ctrlext_t e1000_ctrlext_sdp3_data_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_sdp3_data_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_ctrlext_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_ctrlext_sdp2_iodir_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp2_iodir_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_ctrlext_t e1000_ctrlext_sdp2_iodir_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_sdp2_iodir_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_ctrlext_t )(_fieldval)) << 10)));
}

static inline uint8_t e1000_ctrlext_sdp3_iodir_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp3_iodir_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e1000_ctrlext_t e1000_ctrlext_sdp3_iodir_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_sdp3_iodir_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e1000_ctrlext_t )(_fieldval)) << 11)));
}

static inline uint8_t e1000_ctrlext_asdchk_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_asdchk_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e1000_ctrlext_t e1000_ctrlext_asdchk_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_asdchk_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e1000_ctrlext_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_ctrlext_ee_rst_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_ee_rst_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e1000_ctrlext_t e1000_ctrlext_ee_rst_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_ee_rst_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e1000_ctrlext_t )(_fieldval)) << 13)));
}

static inline uint8_t e1000_ctrlext_spd_byps_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_spd_byps_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_ctrlext_t e1000_ctrlext_spd_byps_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_spd_byps_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_ctrlext_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_ctrlext_rodis_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_rodis_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e1000_ctrlext_t e1000_ctrlext_rodis_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_rodis_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e1000_ctrlext_t )(_fieldval)) << 17)));
}

static inline uint8_t e1000_ctrlext_serdeslpe_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_serdeslpe_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_ctrlext_t e1000_ctrlext_serdeslpe_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_serdeslpe_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_ctrlext_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_ctrlext_dmadge_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_dmadge_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_ctrlext_t e1000_ctrlext_dmadge_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_dmadge_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_ctrlext_t )(_fieldval)) << 19)));
}

static inline uint8_t e1000_ctrlext_phypde_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_phypde_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_ctrlext_t e1000_ctrlext_phypde_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_phypde_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_ctrlext_t )(_fieldval)) << 20)));
}

static inline e1000_linkmode_t e1000_ctrlext_link_mode_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline e1000_linkmode_t e1000_ctrlext_link_mode_extract(e1000_ctrlext_t _regval)
{
    return((e1000_linkmode_t )((_regval & 0xc00000) >> 22));
}

static inline e1000_ctrlext_t e1000_ctrlext_link_mode_insert(e1000_ctrlext_t _regval, e1000_linkmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_link_mode_insert(e1000_ctrlext_t _regval, e1000_linkmode_t _fieldval)
{
    return((_regval & 0xff3fffff) | (0xc00000 & (((e1000_ctrlext_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_ctrlext_pb_paren_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_pb_paren_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e1000_ctrlext_t e1000_ctrlext_pb_paren_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_pb_paren_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e1000_ctrlext_t )(_fieldval)) << 24)));
}

static inline uint8_t e1000_ctrlext_df_paren_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_df_paren_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e1000_ctrlext_t e1000_ctrlext_df_paren_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_df_paren_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e1000_ctrlext_t )(_fieldval)) << 25)));
}

static inline uint8_t e1000_ctrlext_iame_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_iame_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_ctrlext_t e1000_ctrlext_iame_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_iame_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_ctrlext_t )(_fieldval)) << 27)));
}

static inline uint8_t e1000_ctrlext_drv_load_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_drv_load_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_ctrlext_t e1000_ctrlext_drv_load_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_drv_load_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_ctrlext_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_ctrlext_int_tca_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_int_tca_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_ctrlext_t e1000_ctrlext_int_tca_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_int_tca_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_ctrlext_t )(_fieldval)) << 29)));
}

static inline uint8_t e1000_ctrlext_host_paren_extract(e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_host_paren_extract(e1000_ctrlext_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_ctrlext_t e1000_ctrlext_host_paren_insert(e1000_ctrlext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_host_paren_insert(e1000_ctrlext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_ctrlext_t )(_fieldval)) << 30)));
}

static inline int e1000_ctrlext_prtval(char *_s, size_t _size, e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline int e1000_ctrlext_prtval(char *_s, size_t _size, e1000_ctrlext_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_gpien =\t%" PRIx8 "\t(General-purpose interrupt detection for SDP2)\n", e1000_ctrlext_sdp2_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_gpien =\t%" PRIx8 "\t(General-purpose interrupt detection for SDP3)\n", e1000_ctrlext_sdp3_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_data =\t%" PRIx8 "\t(SDP2 data value)\n", e1000_ctrlext_sdp2_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_data =\t%" PRIx8 "\t(SDP3 data value)\n", e1000_ctrlext_sdp3_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_iodir =\t%" PRIx8 "\t(SDP2 pin directionality)\n", e1000_ctrlext_sdp2_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_iodir =\t%" PRIx8 "\t(SDP3 pin directionality)\n", e1000_ctrlext_sdp3_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asdchk =\t%" PRIx8 "\t(Auto-speed-detection check)\n", e1000_ctrlext_asdchk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_rst =\t%" PRIx8 "\t(EEPROM reset)\n", e1000_ctrlext_ee_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd_byps =\t%" PRIx8 "\t(Speed select bypass)\n", e1000_ctrlext_spd_byps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rodis =\t%" PRIx8 "\t(Relaxed ordering disabled)\n", e1000_ctrlext_rodis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " serdeslpe =\t%" PRIx8 "\t(SERDES low power enable)\n", e1000_ctrlext_serdeslpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmadge =\t%" PRIx8 "\t(DMA dynamic gating enable)\n", e1000_ctrlext_dmadge_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phypde =\t%" PRIx8 "\t(PHY power down enable)\n", e1000_ctrlext_phypde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " link_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkmode_prtval(_s + _r, _avail, e1000_ctrlext_link_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pb_paren =\t%" PRIx8 "\t(Packet buffer parity error detection enable)\n", e1000_ctrlext_pb_paren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " df_paren =\t%" PRIx8 "\t(Descriptor FIFO parity error detection enable)\n", e1000_ctrlext_df_paren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iame =\t%" PRIx8 "\t(Interrupt acknowledge auto-mask enable)\n", e1000_ctrlext_iame_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drv_load =\t%" PRIx8 "\t(Driver loaded)\n", e1000_ctrlext_drv_load_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_tca =\t%" PRIx8 "\t(Timers clear enable)\n", e1000_ctrlext_int_tca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " host_paren =\t%" PRIx8 "\t(Host data FIFO parity enable)\n", e1000_ctrlext_host_paren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_fla_t
 * Description: Implicit type of Flash access register
 * Fields:
 *   fl_sk	(size 1, offset 0, init 0):	RW	Clock input to Flash
 *   fl_ce	(size 1, offset 1, init 0):	RW	Chip select to Flash
 *   fl_si	(size 1, offset 2, init 0):	RW	Data input to Flash
 *   fl_so	(size 1, offset 3, init 0):	RW	Data output bit from Flash
 *   fl_req	(size 1, offset 4, init 0):	RW	Request Flash access
 *   fl_gnt	(size 1, offset 5, init 0):	RW	Grant Flash access
 *   fl_addr_sz	(size 1, offset 6, init 0):	RW	Flash address size
 *   _anon7	(size 2, offset 7, init 0):	RSVD	_
 *   sw_wr_done	(size 1, offset 9, init 0):	RW	Last write done
 *   rd_status	(size 1, offset 10, init 0):	RW	Flash status
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 *   ide_bo	(size 14, offset 16, init 0):	RW	Base address of IDE Boot expansion ROM
 *   fl_busy	(size 1, offset 30, init 0):	RW	Flash busy
 *   fl_er	(size 1, offset 31, init 0):	RW	Flash erase command
 */
typedef uint32_t e1000_fla_t;
#define e1000_fla_default 0x0
static inline uint8_t e1000_fla_fl_sk_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_sk_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_fla_t e1000_fla_fl_sk_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_sk_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_fla_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_fla_fl_ce_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_ce_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_fla_t e1000_fla_fl_ce_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_ce_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_fla_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_fla_fl_si_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_si_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_fla_t e1000_fla_fl_si_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_si_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_fla_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_fla_fl_so_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_so_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_fla_t e1000_fla_fl_so_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_so_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_fla_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_fla_fl_req_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_req_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_fla_t e1000_fla_fl_req_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_req_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_fla_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_fla_fl_gnt_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_gnt_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_fla_t e1000_fla_fl_gnt_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_gnt_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_fla_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_fla_fl_addr_sz_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_addr_sz_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_fla_t e1000_fla_fl_addr_sz_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_addr_sz_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_fla_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_fla_sw_wr_done_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_sw_wr_done_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e1000_fla_t e1000_fla_sw_wr_done_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_sw_wr_done_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e1000_fla_t )(_fieldval)) << 9)));
}

static inline uint8_t e1000_fla_rd_status_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_rd_status_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_fla_t e1000_fla_rd_status_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_rd_status_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_fla_t )(_fieldval)) << 10)));
}

static inline uint16_t e1000_fla_ide_bo_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_fla_ide_bo_extract(e1000_fla_t _regval)
{
    return((uint16_t )((_regval & 0x3fff0000) >> 16));
}

static inline e1000_fla_t e1000_fla_ide_bo_insert(e1000_fla_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_ide_bo_insert(e1000_fla_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xc000ffff) | (0x3fff0000 & (((e1000_fla_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_fla_fl_busy_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_busy_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_fla_t e1000_fla_fl_busy_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_busy_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_fla_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_fla_fl_er_extract(e1000_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_er_extract(e1000_fla_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_fla_t e1000_fla_fl_er_insert(e1000_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_fl_er_insert(e1000_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_fla_t )(_fieldval)) << 31)));
}

static inline int e1000_fla_prtval(char *_s, size_t _size, e1000_fla_t _regval) __attribute__ ((always_inline));
static inline int e1000_fla_prtval(char *_s, size_t _size, e1000_fla_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_sk =\t%" PRIx8 "\t(Clock input to Flash)\n", e1000_fla_fl_sk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_ce =\t%" PRIx8 "\t(Chip select to Flash)\n", e1000_fla_fl_ce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_si =\t%" PRIx8 "\t(Data input to Flash)\n", e1000_fla_fl_si_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_so =\t%" PRIx8 "\t(Data output bit from Flash)\n", e1000_fla_fl_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_req =\t%" PRIx8 "\t(Request Flash access)\n", e1000_fla_fl_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_gnt =\t%" PRIx8 "\t(Grant Flash access)\n", e1000_fla_fl_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_addr_sz =\t%" PRIx8 "\t(Flash address size)\n", e1000_fla_fl_addr_sz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_wr_done =\t%" PRIx8 "\t(Last write done)\n", e1000_fla_sw_wr_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd_status =\t%" PRIx8 "\t(Flash status)\n", e1000_fla_rd_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ide_bo =\t%" PRIx16 "\t(Base address of IDE Boot expansion ROM)\n", e1000_fla_ide_bo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_busy =\t%" PRIx8 "\t(Flash busy)\n", e1000_fla_fl_busy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_er =\t%" PRIx8 "\t(Flash erase command)\n", e1000_fla_fl_er_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_mdic_t
 * Description: Implicit type of MDI control register
 * Fields:
 *   data	(size 16, offset 0, init 0):	RW	Data
 *   regadd	(size 5, offset 16, init 0):	RW	PHY register address
 *   phyadd	(size 5, offset 21, init 0):	RW	PHY address
 *   op	(size 2, offset 26, init 0):	RW	Opcode
 *   r	(size 1, offset 28, init 0):	RW	Ready bit
 *   i	(size 1, offset 29, init 0):	RW	Interript enable
 *   e	(size 1, offset 30, init 0):	RW	Error
 *   _anon31	(size 1, offset 31, init 0):	MBZ	_
 */
typedef uint32_t e1000_mdic_t;
#define e1000_mdic_default 0x0
static inline uint16_t e1000_mdic_data_extract(e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_mdic_data_extract(e1000_mdic_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_mdic_t e1000_mdic_data_insert(e1000_mdic_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_data_insert(e1000_mdic_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_mdic_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_mdic_regadd_extract(e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_regadd_extract(e1000_mdic_t _regval)
{
    return((uint8_t )((_regval & 0x1f0000) >> 16));
}

static inline e1000_mdic_t e1000_mdic_regadd_insert(e1000_mdic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_regadd_insert(e1000_mdic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe0ffff) | (0x1f0000 & (((e1000_mdic_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_mdic_phyadd_extract(e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_phyadd_extract(e1000_mdic_t _regval)
{
    return((uint8_t )((_regval & 0x3e00000) >> 21));
}

static inline e1000_mdic_t e1000_mdic_phyadd_insert(e1000_mdic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_phyadd_insert(e1000_mdic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfc1fffff) | (0x3e00000 & (((e1000_mdic_t )(_fieldval)) << 21)));
}

static inline e1000_phyop_t e1000_mdic_op_extract(e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline e1000_phyop_t e1000_mdic_op_extract(e1000_mdic_t _regval)
{
    return((e1000_phyop_t )((_regval & 0xc000000) >> 26));
}

static inline e1000_mdic_t e1000_mdic_op_insert(e1000_mdic_t _regval, e1000_phyop_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_op_insert(e1000_mdic_t _regval, e1000_phyop_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((e1000_mdic_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_mdic_r_extract(e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_r_extract(e1000_mdic_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_mdic_t e1000_mdic_r_insert(e1000_mdic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_r_insert(e1000_mdic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_mdic_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_mdic_i_extract(e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_i_extract(e1000_mdic_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_mdic_t e1000_mdic_i_insert(e1000_mdic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_i_insert(e1000_mdic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_mdic_t )(_fieldval)) << 29)));
}

static inline uint8_t e1000_mdic_e_extract(e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_e_extract(e1000_mdic_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_mdic_t e1000_mdic_e_insert(e1000_mdic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_e_insert(e1000_mdic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_mdic_t )(_fieldval)) << 30)));
}

static inline int e1000_mdic_prtval(char *_s, size_t _size, e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline int e1000_mdic_prtval(char *_s, size_t _size, e1000_mdic_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Data)\n", e1000_mdic_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " regadd =\t%" PRIx8 "\t(PHY register address)\n", e1000_mdic_regadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phyadd =\t%" PRIx8 "\t(PHY address)\n", e1000_mdic_phyadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " op =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_phyop_prtval(_s + _r, _avail, e1000_mdic_op_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Opcode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx8 "\t(Ready bit)\n", e1000_mdic_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i =\t%" PRIx8 "\t(Interript enable)\n", e1000_mdic_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " e =\t%" PRIx8 "\t(Error)\n", e1000_mdic_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_serdesctl_t
 * Description: Implicit type of SERDES ANA register
 * Fields:
 *   data	(size 8, offset 0, init 0):	RW	Data to SerDes
 *   addr	(size 8, offset 8, init 0):	RW	Address to SerDes
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Done
 */
typedef uint32_t e1000_serdesctl_t;
#define e1000_serdesctl_default 0x0
static inline uint8_t e1000_serdesctl_data_extract(e1000_serdesctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_serdesctl_data_extract(e1000_serdesctl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e1000_serdesctl_t e1000_serdesctl_data_insert(e1000_serdesctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_serdesctl_t e1000_serdesctl_data_insert(e1000_serdesctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e1000_serdesctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_serdesctl_addr_extract(e1000_serdesctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_serdesctl_addr_extract(e1000_serdesctl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_serdesctl_t e1000_serdesctl_addr_insert(e1000_serdesctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_serdesctl_t e1000_serdesctl_addr_insert(e1000_serdesctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_serdesctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_serdesctl_done_extract(e1000_serdesctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_serdesctl_done_extract(e1000_serdesctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_serdesctl_t e1000_serdesctl_done_insert(e1000_serdesctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_serdesctl_t e1000_serdesctl_done_insert(e1000_serdesctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_serdesctl_t )(_fieldval)) << 31)));
}

static inline int e1000_serdesctl_prtval(char *_s, size_t _size, e1000_serdesctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_serdesctl_prtval(char *_s, size_t _size, e1000_serdesctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to SerDes)\n", e1000_serdesctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx8 "\t(Address to SerDes)\n", e1000_serdesctl_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done)\n", e1000_serdesctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_kumctrlsta_t
 * Description: Implicit type of GLCI control and status register
 * Fields:
 *   data	(size 16, offset 0, init 0):	RW	Data
 *   offset	(size 5, offset 16, init 0):	RW	Offset of internal register
 *   ren	(size 1, offset 21, init 0):	RW	Read enable (1=read)
 *   _anon22	(size 10, offset 22, init 0):	RSVD	_
 */
typedef uint32_t e1000_kumctrlsta_t;
#define e1000_kumctrlsta_default 0x0
static inline uint16_t e1000_kumctrlsta_data_extract(e1000_kumctrlsta_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_kumctrlsta_data_extract(e1000_kumctrlsta_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_kumctrlsta_t e1000_kumctrlsta_data_insert(e1000_kumctrlsta_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_kumctrlsta_t e1000_kumctrlsta_data_insert(e1000_kumctrlsta_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_kumctrlsta_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_kumctrlsta_offset_extract(e1000_kumctrlsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_kumctrlsta_offset_extract(e1000_kumctrlsta_t _regval)
{
    return((uint8_t )((_regval & 0x1f0000) >> 16));
}

static inline e1000_kumctrlsta_t e1000_kumctrlsta_offset_insert(e1000_kumctrlsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_kumctrlsta_t e1000_kumctrlsta_offset_insert(e1000_kumctrlsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe0ffff) | (0x1f0000 & (((e1000_kumctrlsta_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_kumctrlsta_ren_extract(e1000_kumctrlsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_kumctrlsta_ren_extract(e1000_kumctrlsta_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e1000_kumctrlsta_t e1000_kumctrlsta_ren_insert(e1000_kumctrlsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_kumctrlsta_t e1000_kumctrlsta_ren_insert(e1000_kumctrlsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_kumctrlsta_t )(_fieldval)) << 21)));
}

static inline int e1000_kumctrlsta_prtval(char *_s, size_t _size, e1000_kumctrlsta_t _regval) __attribute__ ((always_inline));
static inline int e1000_kumctrlsta_prtval(char *_s, size_t _size, e1000_kumctrlsta_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Data)\n", e1000_kumctrlsta_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset =\t%" PRIx8 "\t(Offset of internal register)\n", e1000_kumctrlsta_offset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ren =\t%" PRIx8 "\t(Read enable (1=read))\n", e1000_kumctrlsta_ren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_mdphya_t
 * Description: Implicit type of MDC/MDIO PHY address register
 * Fields:
 *   phya	(size 5, offset 0, init 0):	RW	PHY address
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t e1000_mdphya_t;
#define e1000_mdphya_default 0x0
static inline uint8_t e1000_mdphya_phya_extract(e1000_mdphya_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mdphya_phya_extract(e1000_mdphya_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline e1000_mdphya_t e1000_mdphya_phya_insert(e1000_mdphya_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mdphya_t e1000_mdphya_phya_insert(e1000_mdphya_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((e1000_mdphya_t )(_fieldval)) << 0)));
}

static inline int e1000_mdphya_prtval(char *_s, size_t _size, e1000_mdphya_t _regval) __attribute__ ((always_inline));
static inline int e1000_mdphya_prtval(char *_s, size_t _size, e1000_mdphya_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phya =\t%" PRIx8 "\t(PHY address)\n", e1000_mdphya_phya_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ufuse3_t
 * Description: Implicit type of ULT Fuse register 3 register
 * Fields:
 *   drred	(size 15, offset 0, init 0):	RO	Data RAM redundancy fuses
 *   crred	(size 13, offset 15, init 0):	RO	Code RAM redundancy fuses
 *   enad	(size 1, offset 28, init 0):	RO	Enable Data RAM redundancy fuses
 *   enac	(size 1, offset 29, init 0):	RO	Enable Code RAM redundancy fuses
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
typedef uint32_t e1000_ufuse3_t;
#define e1000_ufuse3_default 0x0
static inline uint16_t e1000_ufuse3_drred_extract(e1000_ufuse3_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_ufuse3_drred_extract(e1000_ufuse3_t _regval)
{
    return((uint16_t )((_regval & 0x7fff) >> 0));
}

static inline e1000_ufuse3_t e1000_ufuse3_drred_insert(e1000_ufuse3_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ufuse3_t e1000_ufuse3_drred_insert(e1000_ufuse3_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff8000) | (0x7fff & (((e1000_ufuse3_t )(_fieldval)) << 0)));
}

static inline uint16_t e1000_ufuse3_crred_extract(e1000_ufuse3_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_ufuse3_crred_extract(e1000_ufuse3_t _regval)
{
    return((uint16_t )((_regval & 0xfff8000) >> 15));
}

static inline e1000_ufuse3_t e1000_ufuse3_crred_insert(e1000_ufuse3_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ufuse3_t e1000_ufuse3_crred_insert(e1000_ufuse3_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xf0007fff) | (0xfff8000 & (((e1000_ufuse3_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_ufuse3_enad_extract(e1000_ufuse3_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ufuse3_enad_extract(e1000_ufuse3_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_ufuse3_t e1000_ufuse3_enad_insert(e1000_ufuse3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ufuse3_t e1000_ufuse3_enad_insert(e1000_ufuse3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_ufuse3_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_ufuse3_enac_extract(e1000_ufuse3_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ufuse3_enac_extract(e1000_ufuse3_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_ufuse3_t e1000_ufuse3_enac_insert(e1000_ufuse3_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ufuse3_t e1000_ufuse3_enac_insert(e1000_ufuse3_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_ufuse3_t )(_fieldval)) << 29)));
}

static inline int e1000_ufuse3_prtval(char *_s, size_t _size, e1000_ufuse3_t _regval) __attribute__ ((always_inline));
static inline int e1000_ufuse3_prtval(char *_s, size_t _size, e1000_ufuse3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drred =\t%" PRIx16 "\t(Data RAM redundancy fuses)\n", e1000_ufuse3_drred_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crred =\t%" PRIx16 "\t(Code RAM redundancy fuses)\n", e1000_ufuse3_crred_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enad =\t%" PRIx8 "\t(Enable Data RAM redundancy fuses)\n", e1000_ufuse3_enad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enac =\t%" PRIx8 "\t(Enable Code RAM redundancy fuses)\n", e1000_ufuse3_enac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_fcttv_t
 * Description: Implicit type of Flow control transmit timer value register
 * Fields:
 *   ttv	(size 16, offset 0, init 0):	RW	Transmit timer value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t e1000_fcttv_t;
#define e1000_fcttv_default 0x0
static inline uint16_t e1000_fcttv_ttv_extract(e1000_fcttv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_fcttv_ttv_extract(e1000_fcttv_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_fcttv_t e1000_fcttv_ttv_insert(e1000_fcttv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fcttv_t e1000_fcttv_ttv_insert(e1000_fcttv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_fcttv_t )(_fieldval)) << 0)));
}

static inline int e1000_fcttv_prtval(char *_s, size_t _size, e1000_fcttv_t _regval) __attribute__ ((always_inline));
static inline int e1000_fcttv_prtval(char *_s, size_t _size, e1000_fcttv_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ttv =\t%" PRIx16 "\t(Transmit timer value)\n", e1000_fcttv_ttv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_txcw_t
 * Description: Implicit type of Transmit config word register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   txcw_fd	(size 1, offset 5, init 0):	RW	TXCW full-duplex
 *   txcw_hd	(size 1, offset 6, init 0):	RW	TXCW half-duplex
 *   txcw_pause	(size 2, offset 7, init 0):	RW	TXCW pause
 *   _anon9	(size 3, offset 9, init 0):	MBZ	_
 *   txcw_rfi	(size 2, offset 12, init 0):	RW	TXCW remote fault indication
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   txcw_npr	(size 1, offset 15, init 0):	RW	TXCW next page request
 *   _anon16	(size 14, offset 16, init 0):	MBZ	_
 *   txconfig	(size 1, offset 30, init 0):	RW	Transmit config control bit
 *   ane	(size 1, offset 31, init 0):	RW	Auto-negotiation enable
 */
typedef uint32_t e1000_txcw_t;
#define e1000_txcw_default 0x0
static inline uint8_t e1000_txcw_txcw_fd_extract(e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_fd_extract(e1000_txcw_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_txcw_t e1000_txcw_txcw_fd_insert(e1000_txcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_txcw_fd_insert(e1000_txcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_txcw_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_txcw_txcw_hd_extract(e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_hd_extract(e1000_txcw_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_txcw_t e1000_txcw_txcw_hd_insert(e1000_txcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_txcw_hd_insert(e1000_txcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_txcw_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_txcw_txcw_pause_extract(e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_pause_extract(e1000_txcw_t _regval)
{
    return((uint8_t )((_regval & 0x180) >> 7));
}

static inline e1000_txcw_t e1000_txcw_txcw_pause_insert(e1000_txcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_txcw_pause_insert(e1000_txcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffe7f) | (0x180 & (((e1000_txcw_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_txcw_txcw_rfi_extract(e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_rfi_extract(e1000_txcw_t _regval)
{
    return((uint8_t )((_regval & 0x3000) >> 12));
}

static inline e1000_txcw_t e1000_txcw_txcw_rfi_insert(e1000_txcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_txcw_rfi_insert(e1000_txcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((e1000_txcw_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_txcw_txcw_npr_extract(e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_npr_extract(e1000_txcw_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_txcw_t e1000_txcw_txcw_npr_insert(e1000_txcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_txcw_npr_insert(e1000_txcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_txcw_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_txcw_txconfig_extract(e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txconfig_extract(e1000_txcw_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_txcw_t e1000_txcw_txconfig_insert(e1000_txcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_txconfig_insert(e1000_txcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_txcw_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_txcw_ane_extract(e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_ane_extract(e1000_txcw_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_txcw_t e1000_txcw_ane_insert(e1000_txcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_ane_insert(e1000_txcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_txcw_t )(_fieldval)) << 31)));
}

static inline int e1000_txcw_prtval(char *_s, size_t _size, e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline int e1000_txcw_prtval(char *_s, size_t _size, e1000_txcw_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_fd =\t%" PRIx8 "\t(TXCW full-duplex)\n", e1000_txcw_txcw_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_hd =\t%" PRIx8 "\t(TXCW half-duplex)\n", e1000_txcw_txcw_hd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_pause =\t%" PRIx8 "\t(TXCW pause)\n", e1000_txcw_txcw_pause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_rfi =\t%" PRIx8 "\t(TXCW remote fault indication)\n", e1000_txcw_txcw_rfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_npr =\t%" PRIx8 "\t(TXCW next page request)\n", e1000_txcw_txcw_npr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txconfig =\t%" PRIx8 "\t(Transmit config control bit)\n", e1000_txcw_txconfig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ane =\t%" PRIx8 "\t(Auto-negotiation enable)\n", e1000_txcw_ane_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rxcw_t
 * Description: Implicit type of Receive config word register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   rxcw_fd	(size 1, offset 5, init 0):	RO	RXCW full-duplex
 *   rxcw_hd	(size 1, offset 6, init 0):	RO	RXCW half-duplex
 *   rxcw_pause	(size 2, offset 7, init 0):	RO	RXCW pause
 *   _anon9	(size 3, offset 9, init 0):	MBZ	_
 *   rxcw_rfi	(size 2, offset 12, init 0):	RO	RXCW remote fault indication
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   rxcw_npr	(size 1, offset 15, init 0):	RO	RXCW next page request
 *   _anon16	(size 10, offset 16, init 0):	MBZ	_
 *   nc	(size 1, offset 26, init 0):	RO	Carrier sense indicator
 *   inv	(size 1, offset 27, init 0):	RO	Invalid symbol during config process
 *   chg	(size 1, offset 28, init 0):	RO	Change to RXCW indication
 *   rxconfig	(size 1, offset 29, init 0):	RO	Reception indication
 *   sync	(size 1, offset 30, init 0):	RO	Lost bit sync indication
 *   anc	(size 1, offset 31, init 0):	RO	Auto-negotiation complete
 */
typedef uint32_t e1000_rxcw_t;
#define e1000_rxcw_default 0x0
static inline uint8_t e1000_rxcw_rxcw_fd_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_fd_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_rxcw_t e1000_rxcw_rxcw_fd_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rxcw_fd_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_rxcw_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_rxcw_rxcw_hd_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_hd_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_rxcw_t e1000_rxcw_rxcw_hd_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rxcw_hd_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_rxcw_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_rxcw_rxcw_pause_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_pause_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x180) >> 7));
}

static inline e1000_rxcw_t e1000_rxcw_rxcw_pause_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rxcw_pause_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffe7f) | (0x180 & (((e1000_rxcw_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_rxcw_rxcw_rfi_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_rfi_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x3000) >> 12));
}

static inline e1000_rxcw_t e1000_rxcw_rxcw_rfi_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rxcw_rfi_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((e1000_rxcw_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_rxcw_rxcw_npr_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_npr_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_rxcw_t e1000_rxcw_rxcw_npr_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rxcw_npr_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_rxcw_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_rxcw_nc_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_nc_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e1000_rxcw_t e1000_rxcw_nc_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_nc_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e1000_rxcw_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_rxcw_inv_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_inv_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_rxcw_t e1000_rxcw_inv_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_inv_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_rxcw_t )(_fieldval)) << 27)));
}

static inline uint8_t e1000_rxcw_chg_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_chg_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_rxcw_t e1000_rxcw_chg_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_chg_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_rxcw_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_rxcw_rxconfig_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxconfig_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_rxcw_t e1000_rxcw_rxconfig_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rxconfig_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_rxcw_t )(_fieldval)) << 29)));
}

static inline uint8_t e1000_rxcw_sync_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_sync_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_rxcw_t e1000_rxcw_sync_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_sync_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_rxcw_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_rxcw_anc_extract(e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_anc_extract(e1000_rxcw_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_rxcw_t e1000_rxcw_anc_insert(e1000_rxcw_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_anc_insert(e1000_rxcw_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_rxcw_t )(_fieldval)) << 31)));
}

static inline int e1000_rxcw_prtval(char *_s, size_t _size, e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline int e1000_rxcw_prtval(char *_s, size_t _size, e1000_rxcw_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_fd =\t%" PRIx8 "\t(RXCW full-duplex)\n", e1000_rxcw_rxcw_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_hd =\t%" PRIx8 "\t(RXCW half-duplex)\n", e1000_rxcw_rxcw_hd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_pause =\t%" PRIx8 "\t(RXCW pause)\n", e1000_rxcw_rxcw_pause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_rfi =\t%" PRIx8 "\t(RXCW remote fault indication)\n", e1000_rxcw_rxcw_rfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_npr =\t%" PRIx8 "\t(RXCW next page request)\n", e1000_rxcw_rxcw_npr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nc =\t%" PRIx8 "\t(Carrier sense indicator)\n", e1000_rxcw_nc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " inv =\t%" PRIx8 "\t(Invalid symbol during config process)\n", e1000_rxcw_inv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chg =\t%" PRIx8 "\t(Change to RXCW indication)\n", e1000_rxcw_chg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxconfig =\t%" PRIx8 "\t(Reception indication)\n", e1000_rxcw_rxconfig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sync =\t%" PRIx8 "\t(Lost bit sync indication)\n", e1000_rxcw_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anc =\t%" PRIx8 "\t(Auto-negotiation complete)\n", e1000_rxcw_anc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ledctl_t
 * Description: Implicit type of LED control register
 * Fields:
 *   led0_mode	(size 4, offset 0, init 0):	RW	LED0/LINK# mode
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   global_blink_mode	(size 1, offset 5, init 0):	RW	Global blink mode
 *   led0_ivrt	(size 1, offset 6, init 0):	RW	LED0 invert
 *   led0_blink	(size 1, offset 7, init 0):	RW	LED0 blink
 *   led1_mode	(size 4, offset 8, init 0):	RW	LED1/LINK# mode
 *   _anon12	(size 1, offset 12, init 0):	MBZ	_
 *   led1_blink_mode	(size 1, offset 13, init 0):	RW	Global blink mode
 *   led1_ivrt	(size 1, offset 14, init 0):	RW	LED1 invert
 *   led1_blink	(size 1, offset 15, init 0):	RW	LED1 blink
 *   led2_mode	(size 4, offset 16, init 0):	RW	LED2/LINK# mode
 *   _anon20	(size 1, offset 20, init 0):	MBZ	_
 *   led2_blink_mode	(size 1, offset 21, init 0):	RW	Global blink mode
 *   led2_ivrt	(size 1, offset 22, init 0):	RW	LED2 invert
 *   led2_blink	(size 1, offset 23, init 0):	RW	LED2 blink
 *   led3_mode	(size 4, offset 24, init 0):	RW	LED3/LINK# mode
 *   _anon28	(size 1, offset 28, init 0):	MBZ	_
 *   led3_blink_mode	(size 1, offset 29, init 0):	RW	Global blink mode
 *   led3_ivrt	(size 1, offset 30, init 0):	RW	LED3 invert
 *   led3_blink	(size 1, offset 31, init 0):	RW	LED3 blink
 */
typedef uint32_t e1000_ledctl_t;
#define e1000_ledctl_default 0x0
static inline e1000_ledmode_t e1000_ledctl_led0_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led0_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_ledmode_t )((_regval & 0xf) >> 0));
}

static inline e1000_ledctl_t e1000_ledctl_led0_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led0_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((e1000_ledctl_t )(_fieldval)) << 0)));
}

static inline e1000_blmode_t e1000_ledctl_global_blink_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_global_blink_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_blmode_t )((_regval & 0x20) >> 5));
}

static inline e1000_ledctl_t e1000_ledctl_global_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_global_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_ledctl_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_ledctl_led0_ivrt_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led0_ivrt_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_ledctl_t e1000_ledctl_led0_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led0_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_ledctl_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_ledctl_led0_blink_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led0_blink_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_ledctl_t e1000_ledctl_led0_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led0_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_ledctl_t )(_fieldval)) << 7)));
}

static inline e1000_ledmode_t e1000_ledctl_led1_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led1_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_ledmode_t )((_regval & 0xf00) >> 8));
}

static inline e1000_ledctl_t e1000_ledctl_led1_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led1_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((e1000_ledctl_t )(_fieldval)) << 8)));
}

static inline e1000_blmode_t e1000_ledctl_led1_blink_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_led1_blink_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_blmode_t )((_regval & 0x2000) >> 13));
}

static inline e1000_ledctl_t e1000_ledctl_led1_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led1_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e1000_ledctl_t )(_fieldval)) << 13)));
}

static inline uint8_t e1000_ledctl_led1_ivrt_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led1_ivrt_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e1000_ledctl_t e1000_ledctl_led1_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led1_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e1000_ledctl_t )(_fieldval)) << 14)));
}

static inline uint8_t e1000_ledctl_led1_blink_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led1_blink_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_ledctl_t e1000_ledctl_led1_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led1_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_ledctl_t )(_fieldval)) << 15)));
}

static inline e1000_ledmode_t e1000_ledctl_led2_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led2_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_ledmode_t )((_regval & 0xf0000) >> 16));
}

static inline e1000_ledctl_t e1000_ledctl_led2_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led2_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((e1000_ledctl_t )(_fieldval)) << 16)));
}

static inline e1000_blmode_t e1000_ledctl_led2_blink_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_led2_blink_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_blmode_t )((_regval & 0x200000) >> 21));
}

static inline e1000_ledctl_t e1000_ledctl_led2_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led2_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_ledctl_t )(_fieldval)) << 21)));
}

static inline uint8_t e1000_ledctl_led2_ivrt_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led2_ivrt_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e1000_ledctl_t e1000_ledctl_led2_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led2_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e1000_ledctl_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_ledctl_led2_blink_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led2_blink_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e1000_ledctl_t e1000_ledctl_led2_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led2_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e1000_ledctl_t )(_fieldval)) << 23)));
}

static inline e1000_ledmode_t e1000_ledctl_led3_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led3_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_ledmode_t )((_regval & 0xf000000) >> 24));
}

static inline e1000_ledctl_t e1000_ledctl_led3_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led3_mode_insert(e1000_ledctl_t _regval, e1000_ledmode_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((e1000_ledctl_t )(_fieldval)) << 24)));
}

static inline e1000_blmode_t e1000_ledctl_led3_blink_mode_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_led3_blink_mode_extract(e1000_ledctl_t _regval)
{
    return((e1000_blmode_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_ledctl_t e1000_ledctl_led3_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led3_blink_mode_insert(e1000_ledctl_t _regval, e1000_blmode_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_ledctl_t )(_fieldval)) << 29)));
}

static inline uint8_t e1000_ledctl_led3_ivrt_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led3_ivrt_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_ledctl_t e1000_ledctl_led3_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led3_ivrt_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_ledctl_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_ledctl_led3_blink_extract(e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led3_blink_extract(e1000_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_ledctl_t e1000_ledctl_led3_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_led3_blink_insert(e1000_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_ledctl_t )(_fieldval)) << 31)));
}

static inline int e1000_ledctl_prtval(char *_s, size_t _size, e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_ledctl_prtval(char *_s, size_t _size, e1000_ledctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led0_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED0/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " global_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_global_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_ivrt =\t%" PRIx8 "\t(LED0 invert)\n", e1000_ledctl_led0_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_blink =\t%" PRIx8 "\t(LED0 blink)\n", e1000_ledctl_led0_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led1_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED1/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_led1_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_ivrt =\t%" PRIx8 "\t(LED1 invert)\n", e1000_ledctl_led1_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_blink =\t%" PRIx8 "\t(LED1 blink)\n", e1000_ledctl_led1_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led2_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED2/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_led2_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_ivrt =\t%" PRIx8 "\t(LED2 invert)\n", e1000_ledctl_led2_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_blink =\t%" PRIx8 "\t(LED2 blink)\n", e1000_ledctl_led2_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led3_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED3/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_led3_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_ivrt =\t%" PRIx8 "\t(LED3 invert)\n", e1000_ledctl_led3_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_blink =\t%" PRIx8 "\t(LED3 blink)\n", e1000_ledctl_led3_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_extcnf_ctrl_t
 * Description: Implicit type of Extended config control register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   phy_we	(size 1, offset 1, init 0):	RW	PHY write enable
 *   dud_en	(size 1, offset 2, init 0):	RW	Extended dock/undock configuration enable
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   dock_own	(size 1, offset 4, init 0):	RW	Dock config owner
 *   mdio_swown	(size 1, offset 5, init 0):	RW	MDIO software ownership
 *   mdio_hwown	(size 1, offset 6, init 0):	RW	MDIO hoftware ownership
 *   _anon7	(size 9, offset 7, init 0):	RSVD	_
 *   ecp	(size 12, offset 16, init 0):	RW	Extended configuration pointer
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e1000_extcnf_ctrl_t;
#define e1000_extcnf_ctrl_default 0x0
static inline uint8_t e1000_extcnf_ctrl_phy_we_extract(e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_phy_we_extract(e1000_extcnf_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_phy_we_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_phy_we_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_extcnf_ctrl_dud_en_extract(e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_dud_en_extract(e1000_extcnf_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_dud_en_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_dud_en_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_extcnf_ctrl_dock_own_extract(e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_dock_own_extract(e1000_extcnf_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_dock_own_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_dock_own_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_extcnf_ctrl_mdio_swown_extract(e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_mdio_swown_extract(e1000_extcnf_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_mdio_swown_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_mdio_swown_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_extcnf_ctrl_mdio_hwown_extract(e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_mdio_hwown_extract(e1000_extcnf_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_mdio_hwown_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_mdio_hwown_insert(e1000_extcnf_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 6)));
}

static inline uint16_t e1000_extcnf_ctrl_ecp_extract(e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_extcnf_ctrl_ecp_extract(e1000_extcnf_ctrl_t _regval)
{
    return((uint16_t )((_regval & 0xfff0000) >> 16));
}

static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_ecp_insert(e1000_extcnf_ctrl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_ecp_insert(e1000_extcnf_ctrl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xf000ffff) | (0xfff0000 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 16)));
}

static inline int e1000_extcnf_ctrl_prtval(char *_s, size_t _size, e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline int e1000_extcnf_ctrl_prtval(char *_s, size_t _size, e1000_extcnf_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_we =\t%" PRIx8 "\t(PHY write enable)\n", e1000_extcnf_ctrl_phy_we_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dud_en =\t%" PRIx8 "\t(Extended dock/undock configuration enable)\n", e1000_extcnf_ctrl_dud_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dock_own =\t%" PRIx8 "\t(Dock config owner)\n", e1000_extcnf_ctrl_dock_own_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdio_swown =\t%" PRIx8 "\t(MDIO software ownership)\n", e1000_extcnf_ctrl_mdio_swown_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdio_hwown =\t%" PRIx8 "\t(MDIO hoftware ownership)\n", e1000_extcnf_ctrl_mdio_hwown_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ecp =\t%" PRIx16 "\t(Extended configuration pointer)\n", e1000_extcnf_ctrl_ecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_extcnf_size_t
 * Description: Implicit type of Extended config size register
 * Fields:
 *   phy_len	(size 8, offset 0, init 0):	RW	Extended PHY configuration area length
 *   dock_len	(size 8, offset 8, init 0):	RW	Extended dock configuration area length
 *   _anon16	(size 8, offset 16, init 0):	MBZ	_
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t e1000_extcnf_size_t;
#define e1000_extcnf_size_default 0x0
static inline uint8_t e1000_extcnf_size_phy_len_extract(e1000_extcnf_size_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_size_phy_len_extract(e1000_extcnf_size_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e1000_extcnf_size_t e1000_extcnf_size_phy_len_insert(e1000_extcnf_size_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_size_t e1000_extcnf_size_phy_len_insert(e1000_extcnf_size_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e1000_extcnf_size_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_extcnf_size_dock_len_extract(e1000_extcnf_size_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_size_dock_len_extract(e1000_extcnf_size_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_extcnf_size_t e1000_extcnf_size_dock_len_insert(e1000_extcnf_size_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_extcnf_size_t e1000_extcnf_size_dock_len_insert(e1000_extcnf_size_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_extcnf_size_t )(_fieldval)) << 8)));
}

static inline int e1000_extcnf_size_prtval(char *_s, size_t _size, e1000_extcnf_size_t _regval) __attribute__ ((always_inline));
static inline int e1000_extcnf_size_prtval(char *_s, size_t _size, e1000_extcnf_size_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_len =\t%" PRIx8 "\t(Extended PHY configuration area length)\n", e1000_extcnf_size_phy_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dock_len =\t%" PRIx8 "\t(Extended dock configuration area length)\n", e1000_extcnf_size_dock_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_pba_t
 * Description: Implicit type of Packet buffer allocation register
 * Fields:
 *   rxa	(size 16, offset 0, init 0):	RW	Rx packet buffer allocation in KB
 *   txa	(size 16, offset 16, init 0):	RW	Tx packet buffer allocation in KB
 */
typedef uint32_t e1000_pba_t;
#define e1000_pba_default 0x0
static inline uint16_t e1000_pba_rxa_extract(e1000_pba_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_pba_rxa_extract(e1000_pba_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_pba_t e1000_pba_rxa_insert(e1000_pba_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_pba_t e1000_pba_rxa_insert(e1000_pba_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_pba_t )(_fieldval)) << 0)));
}

static inline uint16_t e1000_pba_txa_extract(e1000_pba_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_pba_txa_extract(e1000_pba_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e1000_pba_t e1000_pba_txa_insert(e1000_pba_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_pba_t e1000_pba_txa_insert(e1000_pba_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e1000_pba_t )(_fieldval)) << 16)));
}

static inline int e1000_pba_prtval(char *_s, size_t _size, e1000_pba_t _regval) __attribute__ ((always_inline));
static inline int e1000_pba_prtval(char *_s, size_t _size, e1000_pba_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxa =\t%" PRIx16 "\t(Rx packet buffer allocation in KB)\n", e1000_pba_rxa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txa =\t%" PRIx16 "\t(Tx packet buffer allocation in KB)\n", e1000_pba_txa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_eemngctl_t
 * Description: Implicit type of MNG EEPROM control register
 * Fields:
 *   _anon0	(size 18, offset 0, init 0):	RSVD	_
 *   crg_done	(size 1, offset 18, init 0):	RW	MNG configuration cycle done
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
typedef uint32_t e1000_eemngctl_t;
#define e1000_eemngctl_default 0x0
static inline uint8_t e1000_eemngctl_crg_done_extract(e1000_eemngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_eemngctl_crg_done_extract(e1000_eemngctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_eemngctl_t e1000_eemngctl_crg_done_insert(e1000_eemngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eemngctl_t e1000_eemngctl_crg_done_insert(e1000_eemngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_eemngctl_t )(_fieldval)) << 18)));
}

static inline int e1000_eemngctl_prtval(char *_s, size_t _size, e1000_eemngctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_eemngctl_prtval(char *_s, size_t _size, e1000_eemngctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crg_done =\t%" PRIx8 "\t(MNG configuration cycle done)\n", e1000_eemngctl_crg_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_sw_fw_sync_t
 * Description: Implicit type of Software/firmware sync register
 * Fields:
 *   sw_eep_sm	(size 1, offset 0, init 0):	RW	EEPROM access owned by software
 *   sw_phy_sm0	(size 1, offset 1, init 0):	RW	PHY 0 access owned by software
 *   sw_phy_sm1	(size 1, offset 2, init 0):	RW	PHY 1 access owned by software
 *   sw_mac_csr_sm	(size 1, offset 3, init 0):	RW	Shared CSR access owned by software
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   fw_eep_sm	(size 1, offset 16, init 0):	RW	EEPROM access owned by firmware
 *   fw_phy_sm0	(size 1, offset 17, init 0):	RW	PHY 0 access owned by firmware
 *   fw_phy_sm1	(size 1, offset 18, init 0):	RW	PHY 1 access owned by firmware
 *   fw_mac_csr_sm	(size 1, offset 19, init 0):	RW	Shared CSR access owned by firmware
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e1000_sw_fw_sync_t;
#define e1000_sw_fw_sync_default 0x0
static inline uint8_t e1000_sw_fw_sync_sw_eep_sm_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_eep_sm_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_eep_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_eep_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_sw_fw_sync_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_sw_fw_sync_sw_phy_sm0_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_phy_sm0_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_phy_sm0_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_phy_sm0_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_sw_fw_sync_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_sw_fw_sync_sw_phy_sm1_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_phy_sm1_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_phy_sm1_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_phy_sm1_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_sw_fw_sync_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_sw_fw_sync_sw_mac_csr_sm_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_mac_csr_sm_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_mac_csr_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_sw_mac_csr_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_sw_fw_sync_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_sw_fw_sync_fw_eep_sm_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_eep_sm_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_eep_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_eep_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_sw_fw_sync_fw_phy_sm0_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_phy_sm0_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_phy_sm0_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_phy_sm0_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 17)));
}

static inline uint8_t e1000_sw_fw_sync_fw_phy_sm1_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_phy_sm1_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_phy_sm1_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_phy_sm1_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_sw_fw_sync_fw_mac_csr_sm_extract(e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_mac_csr_sm_extract(e1000_sw_fw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_mac_csr_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_fw_mac_csr_sm_insert(e1000_sw_fw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 19)));
}

static inline int e1000_sw_fw_sync_prtval(char *_s, size_t _size, e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline int e1000_sw_fw_sync_prtval(char *_s, size_t _size, e1000_sw_fw_sync_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_eep_sm =\t%" PRIx8 "\t(EEPROM access owned by software)\n", e1000_sw_fw_sync_sw_eep_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_phy_sm0 =\t%" PRIx8 "\t(PHY 0 access owned by software)\n", e1000_sw_fw_sync_sw_phy_sm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_phy_sm1 =\t%" PRIx8 "\t(PHY 1 access owned by software)\n", e1000_sw_fw_sync_sw_phy_sm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_mac_csr_sm =\t%" PRIx8 "\t(Shared CSR access owned by software)\n", e1000_sw_fw_sync_sw_mac_csr_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_eep_sm =\t%" PRIx8 "\t(EEPROM access owned by firmware)\n", e1000_sw_fw_sync_fw_eep_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_phy_sm0 =\t%" PRIx8 "\t(PHY 0 access owned by firmware)\n", e1000_sw_fw_sync_fw_phy_sm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_phy_sm1 =\t%" PRIx8 "\t(PHY 1 access owned by firmware)\n", e1000_sw_fw_sync_fw_phy_sm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_mac_csr_sm =\t%" PRIx8 "\t(Shared CSR access owned by firmware)\n", e1000_sw_fw_sync_fw_mac_csr_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_intreg_t
 * Description: Interrupt register format
 * Fields:
 *   txdw	(size 1, offset 0, init 0):	NOATTR	Transmit descriptor written back
 *   txqe	(size 1, offset 1, init 0):	NOATTR	Transmit queue empty
 *   lsc	(size 1, offset 2, init 0):	NOATTR	Link status change
 *   rxseq	(size 1, offset 3, init 0):	NOATTR	Receive sequence error
 *   rxdmt0	(size 1, offset 4, init 0):	NOATTR	Receive descriptor minimum threshold reached
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   rxo	(size 1, offset 6, init 0):	NOATTR	Receiver overrun
 *   rxt0	(size 1, offset 7, init 0):	NOATTR	Receiver timer interrupt
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   mdac	(size 1, offset 9, init 0):	NOATTR	MDI/O access complete
 *   rxcfg	(size 1, offset 10, init 0):	NOATTR	Received configuration symbols
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   gpi_sdp2	(size 1, offset 13, init 0):	NOATTR	General-purpose interrupt on SPD2
 *   gpi_sdp3	(size 1, offset 14, init 0):	NOATTR	General-purpose interrupt on SPD3
 *   txd_low	(size 1, offset 15, init 0):	NOATTR	Transmit descriptor low threshold
 *   srpd	(size 1, offset 16, init 0):	NOATTR	Small receive packet detected
 *   ack	(size 1, offset 17, init 0):	NOATTR	Receive ack frame detected
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   rx_desc_fifo_par0	(size 1, offset 20, init 0):	NOATTR	Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0	(size 1, offset 21, init 0):	NOATTR	Tx descriptor FIFO parity error 0
 *   pcie_master_par	(size 1, offset 22, init 0):	NOATTR	PCIe master data FIFO parity error
 *   pbpar	(size 1, offset 23, init 0):	NOATTR	Packet buffer parity error
 *   rx_desc_fifo_par1	(size 1, offset 24, init 0):	NOATTR	Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1	(size 1, offset 25, init 0):	NOATTR	Tx descriptor FIFO parity error 1
 *   _anon26	(size 5, offset 26, init 0):	RSVD	_
 *   int_asserted	(size 1, offset 31, init 0):	NOATTR	Interrupt asserted
 */
typedef uint32_t e1000_intreg_t;
#define e1000_intreg_default 0x0
static inline uint8_t e1000_intreg_txdw_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_txdw_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_intreg_t e1000_intreg_txdw_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_txdw_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_intreg_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_intreg_txqe_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_txqe_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_intreg_t e1000_intreg_txqe_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_txqe_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_intreg_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_intreg_lsc_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_lsc_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_intreg_t e1000_intreg_lsc_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_lsc_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_intreg_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_intreg_rxseq_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_rxseq_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_intreg_t e1000_intreg_rxseq_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_rxseq_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_intreg_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_intreg_rxdmt0_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_rxdmt0_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_intreg_t e1000_intreg_rxdmt0_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_rxdmt0_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_intreg_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_intreg_rxo_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_rxo_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_intreg_t e1000_intreg_rxo_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_rxo_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_intreg_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_intreg_rxt0_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_rxt0_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_intreg_t e1000_intreg_rxt0_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_rxt0_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_intreg_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_intreg_mdac_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_mdac_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e1000_intreg_t e1000_intreg_mdac_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_mdac_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e1000_intreg_t )(_fieldval)) << 9)));
}

static inline uint8_t e1000_intreg_rxcfg_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_rxcfg_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_intreg_t e1000_intreg_rxcfg_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_rxcfg_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_intreg_t )(_fieldval)) << 10)));
}

static inline uint8_t e1000_intreg_gpi_sdp2_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_gpi_sdp2_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e1000_intreg_t e1000_intreg_gpi_sdp2_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_gpi_sdp2_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e1000_intreg_t )(_fieldval)) << 13)));
}

static inline uint8_t e1000_intreg_gpi_sdp3_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_gpi_sdp3_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e1000_intreg_t e1000_intreg_gpi_sdp3_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_gpi_sdp3_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e1000_intreg_t )(_fieldval)) << 14)));
}

static inline uint8_t e1000_intreg_txd_low_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_txd_low_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_intreg_t e1000_intreg_txd_low_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_txd_low_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_intreg_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_intreg_srpd_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_srpd_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e1000_intreg_t e1000_intreg_srpd_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_srpd_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e1000_intreg_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_intreg_ack_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_ack_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e1000_intreg_t e1000_intreg_ack_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_ack_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e1000_intreg_t )(_fieldval)) << 17)));
}

static inline uint8_t e1000_intreg_rx_desc_fifo_par0_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_rx_desc_fifo_par0_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_intreg_t e1000_intreg_rx_desc_fifo_par0_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_rx_desc_fifo_par0_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_intreg_t )(_fieldval)) << 20)));
}

static inline uint8_t e1000_intreg_tx_desc_fifo_par0_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_tx_desc_fifo_par0_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e1000_intreg_t e1000_intreg_tx_desc_fifo_par0_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_tx_desc_fifo_par0_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_intreg_t )(_fieldval)) << 21)));
}

static inline uint8_t e1000_intreg_pcie_master_par_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_pcie_master_par_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e1000_intreg_t e1000_intreg_pcie_master_par_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_pcie_master_par_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e1000_intreg_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_intreg_pbpar_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_pbpar_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e1000_intreg_t e1000_intreg_pbpar_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_pbpar_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e1000_intreg_t )(_fieldval)) << 23)));
}

static inline uint8_t e1000_intreg_rx_desc_fifo_par1_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_rx_desc_fifo_par1_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e1000_intreg_t e1000_intreg_rx_desc_fifo_par1_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_rx_desc_fifo_par1_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e1000_intreg_t )(_fieldval)) << 24)));
}

static inline uint8_t e1000_intreg_tx_desc_fifo_par1_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_tx_desc_fifo_par1_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e1000_intreg_t e1000_intreg_tx_desc_fifo_par1_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_tx_desc_fifo_par1_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e1000_intreg_t )(_fieldval)) << 25)));
}

static inline uint8_t e1000_intreg_int_asserted_extract(e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_intreg_int_asserted_extract(e1000_intreg_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_intreg_t e1000_intreg_int_asserted_insert(e1000_intreg_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_intreg_int_asserted_insert(e1000_intreg_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_intreg_t )(_fieldval)) << 31)));
}

static inline int e1000_intreg_prtval(char *_s, size_t _size, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline int e1000_intreg_prtval(char *_s, size_t _size, e1000_intreg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdw =\t%" PRIx8 "\t(Transmit descriptor written back)\n", e1000_intreg_txdw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txqe =\t%" PRIx8 "\t(Transmit queue empty)\n", e1000_intreg_txqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link status change)\n", e1000_intreg_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxseq =\t%" PRIx8 "\t(Receive sequence error)\n", e1000_intreg_rxseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmt0 =\t%" PRIx8 "\t(Receive descriptor minimum threshold reached)\n", e1000_intreg_rxdmt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxo =\t%" PRIx8 "\t(Receiver overrun)\n", e1000_intreg_rxo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxt0 =\t%" PRIx8 "\t(Receiver timer interrupt)\n", e1000_intreg_rxt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdac =\t%" PRIx8 "\t(MDI/O access complete)\n", e1000_intreg_mdac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcfg =\t%" PRIx8 "\t(Received configuration symbols)\n", e1000_intreg_rxcfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp2 =\t%" PRIx8 "\t(General-purpose interrupt on SPD2)\n", e1000_intreg_gpi_sdp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp3 =\t%" PRIx8 "\t(General-purpose interrupt on SPD3)\n", e1000_intreg_gpi_sdp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_low =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_intreg_txd_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srpd =\t%" PRIx8 "\t(Small receive packet detected)\n", e1000_intreg_srpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(Receive ack frame detected)\n", e1000_intreg_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par0 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 0)\n", e1000_intreg_rx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par0 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 0)\n", e1000_intreg_tx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_master_par =\t%" PRIx8 "\t(PCIe master data FIFO parity error)\n", e1000_intreg_pcie_master_par_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pbpar =\t%" PRIx8 "\t(Packet buffer parity error)\n", e1000_intreg_pbpar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par1 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 1)\n", e1000_intreg_rx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par1 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 1)\n", e1000_intreg_tx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_asserted =\t%" PRIx8 "\t(Interrupt asserted)\n", e1000_intreg_int_asserted_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_itr_t
 * Description: Implicit type of Interrupt throttling rate register
 * Fields:
 *   interval	(size 16, offset 0, init 0):	RW	Minimum inter-interrupt interval (x256ns)
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t e1000_itr_t;
#define e1000_itr_default 0x0
static inline uint16_t e1000_itr_interval_extract(e1000_itr_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_itr_interval_extract(e1000_itr_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_itr_t e1000_itr_interval_insert(e1000_itr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_itr_t e1000_itr_interval_insert(e1000_itr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_itr_t )(_fieldval)) << 0)));
}

static inline int e1000_itr_prtval(char *_s, size_t _size, e1000_itr_t _regval) __attribute__ ((always_inline));
static inline int e1000_itr_prtval(char *_s, size_t _size, e1000_itr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " interval =\t%" PRIx16 "\t(Minimum inter-interrupt interval (x256ns))\n", e1000_itr_interval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_eitr_t
 * Description: Implicit type of Extended Interrupt Throttle register array
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   interval	(size 13, offset 2, init 0):	NOATTR	Interval
 *   _anon15	(size 1, offset 15, init 0):	MBZ	_
 *   counter	(size 16, offset 16, init 0):	NOATTR	Down counter
 */
typedef uint32_t e1000_eitr_t;
#define e1000_eitr_default 0x0
static inline uint16_t e1000_eitr_interval_extract(e1000_eitr_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_eitr_interval_extract(e1000_eitr_t _regval)
{
    return((uint16_t )((_regval & 0x7ffc) >> 2));
}

static inline e1000_eitr_t e1000_eitr_interval_insert(e1000_eitr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eitr_t e1000_eitr_interval_insert(e1000_eitr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff8003) | (0x7ffc & (((e1000_eitr_t )(_fieldval)) << 2)));
}

static inline uint16_t e1000_eitr_counter_extract(e1000_eitr_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_eitr_counter_extract(e1000_eitr_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e1000_eitr_t e1000_eitr_counter_insert(e1000_eitr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_eitr_t e1000_eitr_counter_insert(e1000_eitr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e1000_eitr_t )(_fieldval)) << 16)));
}

static inline int e1000_eitr_prtval(char *_s, size_t _size, e1000_eitr_t _regval) __attribute__ ((always_inline));
static inline int e1000_eitr_prtval(char *_s, size_t _size, e1000_eitr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " interval =\t%" PRIx16 "\t(Interval)\n", e1000_eitr_interval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " counter =\t%" PRIx16 "\t(Down counter)\n", e1000_eitr_counter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rctl_t
 * Description: Implicit type of Receive control register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   en	(size 1, offset 1, init 0):	RW	Receiver enable
 *   sbp	(size 1, offset 2, init 0):	RW	Store bad packets
 *   upe	(size 1, offset 3, init 0):	RW	Unicast promiscuous enabled
 *   mpe	(size 1, offset 4, init 0):	RW	Multicast promiscuous enabled
 *   lpe	(size 1, offset 5, init 0):	RW	Long packet reception enable
 *   lbm	(size 2, offset 6, init 0):	RW	Loopback mode
 *   rdmts	(size 2, offset 8, init 0):	RW	Receive descriptor minimum threshold size
 *   dtyp	(size 2, offset 10, init 0):	RW	Descriptor type
 *   mo	(size 2, offset 12, init 0):	RW	Multicast offset (12 bits starting at 36-val)
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   bam	(size 1, offset 15, init 0):	RW	Broadcast accept mode
 *   bsize	(size 2, offset 16, init 0):	RW	Receive buffer size (see BSEX)
 *   vfe	(size 1, offset 18, init 0):	RW	VLAN filter enable
 *   cfien	(size 1, offset 19, init 0):	RW	Canonical form indicator enable
 *   cfi	(size 1, offset 20, init 0):	RW	Canonical form indicator value
 *   _anon21	(size 1, offset 21, init 0):	MBZ	_
 *   dpf	(size 1, offset 22, init 0):	RW	Discard pause frames
 *   pmcf	(size 1, offset 23, init 0):	RW	Pass MAC control frames
 *   _anon24	(size 1, offset 24, init 0):	MBZ	_
 *   bsex	(size 1, offset 25, init 0):	RW	Buffer size extension
 *   secrc	(size 1, offset 26, init 0):	RW	Strip Ethernet CRC from packet
 *   flxbuf	(size 4, offset 27, init 0):	RW	Flexible buffer size (in KB)
 *   _anon31	(size 1, offset 31, init 0):	MBZ	_
 */
typedef uint32_t e1000_rctl_t;
#define e1000_rctl_default 0x0
static inline uint8_t e1000_rctl_en_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_en_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_rctl_t e1000_rctl_en_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_en_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_rctl_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_rctl_sbp_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_sbp_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_rctl_t e1000_rctl_sbp_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_sbp_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_rctl_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_rctl_upe_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_upe_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_rctl_t e1000_rctl_upe_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_upe_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_rctl_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_rctl_mpe_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_mpe_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_rctl_t e1000_rctl_mpe_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_mpe_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_rctl_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_rctl_lpe_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_lpe_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_rctl_t e1000_rctl_lpe_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_lpe_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_rctl_t )(_fieldval)) << 5)));
}

static inline e1000_lbmode_t e1000_rctl_lbm_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline e1000_lbmode_t e1000_rctl_lbm_extract(e1000_rctl_t _regval)
{
    return((e1000_lbmode_t )((_regval & 0xc0) >> 6));
}

static inline e1000_rctl_t e1000_rctl_lbm_insert(e1000_rctl_t _regval, e1000_lbmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_lbm_insert(e1000_rctl_t _regval, e1000_lbmode_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((e1000_rctl_t )(_fieldval)) << 6)));
}

static inline e1000_rxthresh_t e1000_rctl_rdmts_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline e1000_rxthresh_t e1000_rctl_rdmts_extract(e1000_rctl_t _regval)
{
    return((e1000_rxthresh_t )((_regval & 0x300) >> 8));
}

static inline e1000_rctl_t e1000_rctl_rdmts_insert(e1000_rctl_t _regval, e1000_rxthresh_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_rdmts_insert(e1000_rctl_t _regval, e1000_rxthresh_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((e1000_rctl_t )(_fieldval)) << 8)));
}

static inline e1000_dtype_t e1000_rctl_dtyp_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline e1000_dtype_t e1000_rctl_dtyp_extract(e1000_rctl_t _regval)
{
    return((e1000_dtype_t )((_regval & 0xc00) >> 10));
}

static inline e1000_rctl_t e1000_rctl_dtyp_insert(e1000_rctl_t _regval, e1000_dtype_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_dtyp_insert(e1000_rctl_t _regval, e1000_dtype_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((e1000_rctl_t )(_fieldval)) << 10)));
}

static inline uint8_t e1000_rctl_mo_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_mo_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x3000) >> 12));
}

static inline e1000_rctl_t e1000_rctl_mo_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_mo_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((e1000_rctl_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_rctl_bam_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_bam_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_rctl_t e1000_rctl_bam_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_bam_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_rctl_t )(_fieldval)) << 15)));
}

static inline e1000_rxbsize_t e1000_rctl_bsize_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline e1000_rxbsize_t e1000_rctl_bsize_extract(e1000_rctl_t _regval)
{
    return((e1000_rxbsize_t )((_regval & 0x30000) >> 16));
}

static inline e1000_rctl_t e1000_rctl_bsize_insert(e1000_rctl_t _regval, e1000_rxbsize_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_bsize_insert(e1000_rctl_t _regval, e1000_rxbsize_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((e1000_rctl_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_rctl_vfe_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_vfe_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_rctl_t e1000_rctl_vfe_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_vfe_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_rctl_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_rctl_cfien_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_cfien_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_rctl_t e1000_rctl_cfien_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_cfien_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_rctl_t )(_fieldval)) << 19)));
}

static inline uint8_t e1000_rctl_cfi_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_cfi_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_rctl_t e1000_rctl_cfi_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_cfi_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_rctl_t )(_fieldval)) << 20)));
}

static inline uint8_t e1000_rctl_dpf_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_dpf_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e1000_rctl_t e1000_rctl_dpf_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_dpf_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e1000_rctl_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_rctl_pmcf_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_pmcf_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e1000_rctl_t e1000_rctl_pmcf_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_pmcf_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e1000_rctl_t )(_fieldval)) << 23)));
}

static inline uint8_t e1000_rctl_bsex_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_bsex_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e1000_rctl_t e1000_rctl_bsex_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_bsex_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e1000_rctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e1000_rctl_secrc_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_secrc_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e1000_rctl_t e1000_rctl_secrc_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_secrc_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e1000_rctl_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_rctl_flxbuf_extract(e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_flxbuf_extract(e1000_rctl_t _regval)
{
    return((uint8_t )((_regval & 0x78000000) >> 27));
}

static inline e1000_rctl_t e1000_rctl_flxbuf_insert(e1000_rctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_flxbuf_insert(e1000_rctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x87ffffff) | (0x78000000 & (((e1000_rctl_t )(_fieldval)) << 27)));
}

static inline int e1000_rctl_prtval(char *_s, size_t _size, e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_rctl_prtval(char *_s, size_t _size, e1000_rctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Receiver enable)\n", e1000_rctl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sbp =\t%" PRIx8 "\t(Store bad packets)\n", e1000_rctl_sbp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " upe =\t%" PRIx8 "\t(Unicast promiscuous enabled)\n", e1000_rctl_upe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpe =\t%" PRIx8 "\t(Multicast promiscuous enabled)\n", e1000_rctl_mpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpe =\t%" PRIx8 "\t(Long packet reception enable)\n", e1000_rctl_lpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_lbmode_prtval(_s + _r, _avail, e1000_rctl_lbm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Loopback mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdmts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxthresh_prtval(_s + _r, _avail, e1000_rctl_rdmts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive descriptor minimum threshold size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtyp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_dtype_prtval(_s + _r, _avail, e1000_rctl_dtyp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Descriptor type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mo =\t%" PRIx8 "\t(Multicast offset (12 bits starting at 36-val))\n", e1000_rctl_mo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bam =\t%" PRIx8 "\t(Broadcast accept mode)\n", e1000_rctl_bam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxbsize_prtval(_s + _r, _avail, e1000_rctl_bsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive buffer size (see BSEX))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vfe =\t%" PRIx8 "\t(VLAN filter enable)\n", e1000_rctl_vfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfien =\t%" PRIx8 "\t(Canonical form indicator enable)\n", e1000_rctl_cfien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfi =\t%" PRIx8 "\t(Canonical form indicator value)\n", e1000_rctl_cfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpf =\t%" PRIx8 "\t(Discard pause frames)\n", e1000_rctl_dpf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmcf =\t%" PRIx8 "\t(Pass MAC control frames)\n", e1000_rctl_pmcf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsex =\t%" PRIx8 "\t(Buffer size extension)\n", e1000_rctl_bsex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " secrc =\t%" PRIx8 "\t(Strip Ethernet CRC from packet)\n", e1000_rctl_secrc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flxbuf =\t%" PRIx8 "\t(Flexible buffer size (in KB))\n", e1000_rctl_flxbuf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ert_t
 * Description: Implicit type of Early receive threshold register
 * Fields:
 *   rxthresh	(size 13, offset 0, init 0):	RW	Receive threshold value (x 8 bytes)
 *   _anon13	(size 1, offset 13, init 0):	RSVD	_
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
typedef uint32_t e1000_ert_t;
#define e1000_ert_default 0x0
static inline uint16_t e1000_ert_rxthresh_extract(e1000_ert_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_ert_rxthresh_extract(e1000_ert_t _regval)
{
    return((uint16_t )((_regval & 0x1fff) >> 0));
}

static inline e1000_ert_t e1000_ert_rxthresh_insert(e1000_ert_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ert_t e1000_ert_rxthresh_insert(e1000_ert_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffe000) | (0x1fff & (((e1000_ert_t )(_fieldval)) << 0)));
}

static inline int e1000_ert_prtval(char *_s, size_t _size, e1000_ert_t _regval) __attribute__ ((always_inline));
static inline int e1000_ert_prtval(char *_s, size_t _size, e1000_ert_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxthresh =\t%" PRIx16 "\t(Receive threshold value (x 8 bytes))\n", e1000_ert_rxthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_fcrtl_t
 * Description: Implicit type of Flow control rx threshold low register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   rtl	(size 13, offset 3, init 0):	RW	Recieve threshold low
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   xone	(size 1, offset 31, init 0):	RW	XON enable
 */
typedef uint32_t e1000_fcrtl_t;
#define e1000_fcrtl_default 0x0
static inline uint16_t e1000_fcrtl_rtl_extract(e1000_fcrtl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_fcrtl_rtl_extract(e1000_fcrtl_t _regval)
{
    return((uint16_t )((_regval & 0xfff8) >> 3));
}

static inline e1000_fcrtl_t e1000_fcrtl_rtl_insert(e1000_fcrtl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fcrtl_t e1000_fcrtl_rtl_insert(e1000_fcrtl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0007) | (0xfff8 & (((e1000_fcrtl_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_fcrtl_xone_extract(e1000_fcrtl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fcrtl_xone_extract(e1000_fcrtl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_fcrtl_t e1000_fcrtl_xone_insert(e1000_fcrtl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fcrtl_t e1000_fcrtl_xone_insert(e1000_fcrtl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_fcrtl_t )(_fieldval)) << 31)));
}

static inline int e1000_fcrtl_prtval(char *_s, size_t _size, e1000_fcrtl_t _regval) __attribute__ ((always_inline));
static inline int e1000_fcrtl_prtval(char *_s, size_t _size, e1000_fcrtl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtl =\t%" PRIx16 "\t(Recieve threshold low)\n", e1000_fcrtl_rtl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xone =\t%" PRIx8 "\t(XON enable)\n", e1000_fcrtl_xone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_fcrth_t
 * Description: Implicit type of Flow control rx threshold high register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   rth	(size 13, offset 3, init 0):	RW	Recieve threshold high
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   flowcntdis	(size 1, offset 31, init 0):	RW	Flow control disable
 */
typedef uint32_t e1000_fcrth_t;
#define e1000_fcrth_default 0x0
static inline uint16_t e1000_fcrth_rth_extract(e1000_fcrth_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_fcrth_rth_extract(e1000_fcrth_t _regval)
{
    return((uint16_t )((_regval & 0xfff8) >> 3));
}

static inline e1000_fcrth_t e1000_fcrth_rth_insert(e1000_fcrth_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fcrth_t e1000_fcrth_rth_insert(e1000_fcrth_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0007) | (0xfff8 & (((e1000_fcrth_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_fcrth_flowcntdis_extract(e1000_fcrth_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fcrth_flowcntdis_extract(e1000_fcrth_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_fcrth_t e1000_fcrth_flowcntdis_insert(e1000_fcrth_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fcrth_t e1000_fcrth_flowcntdis_insert(e1000_fcrth_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_fcrth_t )(_fieldval)) << 31)));
}

static inline int e1000_fcrth_prtval(char *_s, size_t _size, e1000_fcrth_t _regval) __attribute__ ((always_inline));
static inline int e1000_fcrth_prtval(char *_s, size_t _size, e1000_fcrth_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rth =\t%" PRIx16 "\t(Recieve threshold high)\n", e1000_fcrth_rth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flowcntdis =\t%" PRIx8 "\t(Flow control disable)\n", e1000_fcrth_flowcntdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_psrctl_t
 * Description: Implicit type of Packet split rx control register
 * Fields:
 *   bsize0	(size 7, offset 0, init 0):	RW	Receive buffer 0 size (x 128 bytes)
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   bsize1	(size 7, offset 8, init 0):	RW	Receive buffer 1 size (x 1 kbytes)
 *   _anon15	(size 1, offset 15, init 0):	MBZ	_
 *   bsize2	(size 7, offset 16, init 0):	RW	Receive buffer 2 size (x 1 kbytes)
 *   _anon23	(size 1, offset 23, init 0):	MBZ	_
 *   bsize3	(size 7, offset 24, init 0):	RW	Receive buffer 3 size (x 1 kbytes)
 *   _anon31	(size 1, offset 31, init 0):	MBZ	_
 */
typedef uint32_t e1000_psrctl_t;
#define e1000_psrctl_default 0x0
static inline uint8_t e1000_psrctl_bsize0_extract(e1000_psrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize0_extract(e1000_psrctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline e1000_psrctl_t e1000_psrctl_bsize0_insert(e1000_psrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_psrctl_t e1000_psrctl_bsize0_insert(e1000_psrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((e1000_psrctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_psrctl_bsize1_extract(e1000_psrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize1_extract(e1000_psrctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f00) >> 8));
}

static inline e1000_psrctl_t e1000_psrctl_bsize1_insert(e1000_psrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_psrctl_t e1000_psrctl_bsize1_insert(e1000_psrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff80ff) | (0x7f00 & (((e1000_psrctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_psrctl_bsize2_extract(e1000_psrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize2_extract(e1000_psrctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f0000) >> 16));
}

static inline e1000_psrctl_t e1000_psrctl_bsize2_insert(e1000_psrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_psrctl_t e1000_psrctl_bsize2_insert(e1000_psrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff80ffff) | (0x7f0000 & (((e1000_psrctl_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_psrctl_bsize3_extract(e1000_psrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize3_extract(e1000_psrctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f000000) >> 24));
}

static inline e1000_psrctl_t e1000_psrctl_bsize3_insert(e1000_psrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_psrctl_t e1000_psrctl_bsize3_insert(e1000_psrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x80ffffff) | (0x7f000000 & (((e1000_psrctl_t )(_fieldval)) << 24)));
}

static inline int e1000_psrctl_prtval(char *_s, size_t _size, e1000_psrctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_psrctl_prtval(char *_s, size_t _size, e1000_psrctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize0 =\t%" PRIx8 "\t(Receive buffer 0 size (x 128 bytes))\n", e1000_psrctl_bsize0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize1 =\t%" PRIx8 "\t(Receive buffer 1 size (x 1 kbytes))\n", e1000_psrctl_bsize1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize2 =\t%" PRIx8 "\t(Receive buffer 2 size (x 1 kbytes))\n", e1000_psrctl_bsize2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize3 =\t%" PRIx8 "\t(Receive buffer 3 size (x 1 kbytes))\n", e1000_psrctl_bsize3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_dqlen_t
 * Description: Descriptor length value
 * Fields:
 *   _anon0	(size 7, offset 0, init 0):	MBZ	_
 *   len	(size 13, offset 7, init 0):	NOATTR	Num. descriptors (x8)
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t e1000_dqlen_t;
#define e1000_dqlen_default 0x0
static inline uint16_t e1000_dqlen_len_extract(e1000_dqlen_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_dqlen_len_extract(e1000_dqlen_t _regval)
{
    return((uint16_t )((_regval & 0xfff80) >> 7));
}

static inline e1000_dqlen_t e1000_dqlen_len_insert(e1000_dqlen_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_dqlen_t e1000_dqlen_len_insert(e1000_dqlen_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfff0007f) | (0xfff80 & (((e1000_dqlen_t )(_fieldval)) << 7)));
}

static inline int e1000_dqlen_prtval(char *_s, size_t _size, e1000_dqlen_t _regval) __attribute__ ((always_inline));
static inline int e1000_dqlen_prtval(char *_s, size_t _size, e1000_dqlen_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx16 "\t(Num. descriptors (x8))\n", e1000_dqlen_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_dqval_t
 * Description: Descriptor head/tail value
 * Fields:
 *   val	(size 16, offset 0, init 0):	NOATTR	value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t e1000_dqval_t;
#define e1000_dqval_default 0x0
static inline uint16_t e1000_dqval_val_extract(e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_dqval_val_extract(e1000_dqval_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_dqval_t e1000_dqval_val_insert(e1000_dqval_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_dqval_val_insert(e1000_dqval_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_dqval_t )(_fieldval)) << 0)));
}

static inline int e1000_dqval_prtval(char *_s, size_t _size, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline int e1000_dqval_prtval(char *_s, size_t _size, e1000_dqval_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t(value)\n", e1000_dqval_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rdtr_t
 * Description: Implicit type of Rx. interrupt delay timer register
 * Fields:
 *   delay	(size 16, offset 0, init 0):	RW	delay timer (x 1.024us)
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   fpd	(size 1, offset 31, init 0):	RW	Flush partial descriptor block
 */
typedef uint32_t e1000_rdtr_t;
#define e1000_rdtr_default 0x0
static inline uint16_t e1000_rdtr_delay_extract(e1000_rdtr_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_rdtr_delay_extract(e1000_rdtr_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_rdtr_t e1000_rdtr_delay_insert(e1000_rdtr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rdtr_t e1000_rdtr_delay_insert(e1000_rdtr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_rdtr_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_rdtr_fpd_extract(e1000_rdtr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rdtr_fpd_extract(e1000_rdtr_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_rdtr_t e1000_rdtr_fpd_insert(e1000_rdtr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rdtr_t e1000_rdtr_fpd_insert(e1000_rdtr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_rdtr_t )(_fieldval)) << 31)));
}

static inline int e1000_rdtr_prtval(char *_s, size_t _size, e1000_rdtr_t _regval) __attribute__ ((always_inline));
static inline int e1000_rdtr_prtval(char *_s, size_t _size, e1000_rdtr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " delay =\t%" PRIx16 "\t(delay timer (x 1.024us))\n", e1000_rdtr_delay_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpd =\t%" PRIx8 "\t(Flush partial descriptor block)\n", e1000_rdtr_fpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rxdctl_t
 * Description: Implicit type of Rx descriptor control register array
 * Fields:
 *   pthresh	(size 6, offset 0, init 0):	NOATTR	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 6, offset 8, init 0):	NOATTR	Host threshold
 *   _anon14	(size 2, offset 14, init 0):	MBZ	_
 *   wthresh	(size 6, offset 16, init 0):	NOATTR	Write back threshold
 *   _anon22	(size 2, offset 22, init 0):	MBZ	_
 *   gran	(size 1, offset 24, init 0):	NOATTR	Granularity
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t e1000_rxdctl_t;
#define e1000_rxdctl_default 0x0
static inline uint8_t e1000_rxdctl_pthresh_extract(e1000_rxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_pthresh_extract(e1000_rxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline e1000_rxdctl_t e1000_rxdctl_pthresh_insert(e1000_rxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_t e1000_rxdctl_pthresh_insert(e1000_rxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((e1000_rxdctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_rxdctl_hthresh_extract(e1000_rxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_hthresh_extract(e1000_rxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e1000_rxdctl_t e1000_rxdctl_hthresh_insert(e1000_rxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_t e1000_rxdctl_hthresh_insert(e1000_rxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e1000_rxdctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_rxdctl_wthresh_extract(e1000_rxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_wthresh_extract(e1000_rxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x3f0000) >> 16));
}

static inline e1000_rxdctl_t e1000_rxdctl_wthresh_insert(e1000_rxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_t e1000_rxdctl_wthresh_insert(e1000_rxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((e1000_rxdctl_t )(_fieldval)) << 16)));
}

static inline e1000_threshgran_t e1000_rxdctl_gran_extract(e1000_rxdctl_t _regval) __attribute__ ((always_inline));
static inline e1000_threshgran_t e1000_rxdctl_gran_extract(e1000_rxdctl_t _regval)
{
    return((e1000_threshgran_t )((_regval & 0x1000000) >> 24));
}

static inline e1000_rxdctl_t e1000_rxdctl_gran_insert(e1000_rxdctl_t _regval, e1000_threshgran_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_t e1000_rxdctl_gran_insert(e1000_rxdctl_t _regval, e1000_threshgran_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e1000_rxdctl_t )(_fieldval)) << 24)));
}

static inline int e1000_rxdctl_prtval(char *_s, size_t _size, e1000_rxdctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_rxdctl_prtval(char *_s, size_t _size, e1000_rxdctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_rxdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_rxdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_rxdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gran =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_threshgran_prtval(_s + _r, _avail, e1000_rxdctl_gran_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Granularity)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rxdctl_82575_t
 * Description: Implicit type of Rx descriptor control register array
 * Fields:
 *   pthresh	(size 6, offset 0, init 0):	NOATTR	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 6, offset 8, init 0):	NOATTR	Host threshold
 *   _anon14	(size 2, offset 14, init 0):	MBZ	_
 *   wthresh	(size 6, offset 16, init 0):	NOATTR	Write back threshold
 *   _anon22	(size 3, offset 22, init 0):	MBZ	_
 *   enable	(size 1, offset 25, init 0):	NOATTR	Granularity
 *   swflush	(size 1, offset 26, init 0):	NOATTR	Receive Software Flush
 *   _anon27	(size 5, offset 27, init 0):	MBZ	_
 */
typedef uint32_t e1000_rxdctl_82575_t;
#define e1000_rxdctl_82575_default 0x0
static inline uint8_t e1000_rxdctl_82575_pthresh_extract(e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_pthresh_extract(e1000_rxdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_pthresh_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_pthresh_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((e1000_rxdctl_82575_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_rxdctl_82575_hthresh_extract(e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_hthresh_extract(e1000_rxdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_hthresh_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_hthresh_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e1000_rxdctl_82575_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_rxdctl_82575_wthresh_extract(e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_wthresh_extract(e1000_rxdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x3f0000) >> 16));
}

static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_wthresh_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_wthresh_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((e1000_rxdctl_82575_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_rxdctl_82575_enable_extract(e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_enable_extract(e1000_rxdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_enable_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_enable_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e1000_rxdctl_82575_t )(_fieldval)) << 25)));
}

static inline uint8_t e1000_rxdctl_82575_swflush_extract(e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_swflush_extract(e1000_rxdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_swflush_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_swflush_insert(e1000_rxdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e1000_rxdctl_82575_t )(_fieldval)) << 26)));
}

static inline int e1000_rxdctl_82575_prtval(char *_s, size_t _size, e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline int e1000_rxdctl_82575_prtval(char *_s, size_t _size, e1000_rxdctl_82575_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_rxdctl_82575_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_rxdctl_82575_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_rxdctl_82575_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Granularity)\n", e1000_rxdctl_82575_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflush =\t%" PRIx8 "\t(Receive Software Flush)\n", e1000_rxdctl_82575_swflush_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_radv_t
 * Description: Implicit type of Rx absolute intr. delay register
 * Fields:
 *   idv	(size 16, offset 0, init 0):	RW	Interrupt delay value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t e1000_radv_t;
#define e1000_radv_default 0x0
static inline uint16_t e1000_radv_idv_extract(e1000_radv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_radv_idv_extract(e1000_radv_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_radv_t e1000_radv_idv_insert(e1000_radv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_radv_t e1000_radv_idv_insert(e1000_radv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_radv_t )(_fieldval)) << 0)));
}

static inline int e1000_radv_prtval(char *_s, size_t _size, e1000_radv_t _regval) __attribute__ ((always_inline));
static inline int e1000_radv_prtval(char *_s, size_t _size, e1000_radv_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interrupt delay value)\n", e1000_radv_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rsrpd_t
 * Description: Implicit type of Rx small packet detect interrupt register
 * Fields:
 *   size	(size 12, offset 0, init 0):	RW	Max size of small packet
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
typedef uint32_t e1000_rsrpd_t;
#define e1000_rsrpd_default 0x0
static inline uint16_t e1000_rsrpd_size_extract(e1000_rsrpd_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_rsrpd_size_extract(e1000_rsrpd_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e1000_rsrpd_t e1000_rsrpd_size_insert(e1000_rsrpd_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rsrpd_t e1000_rsrpd_size_insert(e1000_rsrpd_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e1000_rsrpd_t )(_fieldval)) << 0)));
}

static inline int e1000_rsrpd_prtval(char *_s, size_t _size, e1000_rsrpd_t _regval) __attribute__ ((always_inline));
static inline int e1000_rsrpd_prtval(char *_s, size_t _size, e1000_rsrpd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Max size of small packet)\n", e1000_rsrpd_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_raid_t
 * Description: Implicit type of Rx ACK interrupt delay register
 * Fields:
 *   idv	(size 16, offset 0, init 0):	RW	Interrupt delay value (x 1.024us)
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t e1000_raid_t;
#define e1000_raid_default 0x0
static inline uint16_t e1000_raid_idv_extract(e1000_raid_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_raid_idv_extract(e1000_raid_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_raid_t e1000_raid_idv_insert(e1000_raid_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_raid_t e1000_raid_idv_insert(e1000_raid_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_raid_t )(_fieldval)) << 0)));
}

static inline int e1000_raid_prtval(char *_s, size_t _size, e1000_raid_t _regval) __attribute__ ((always_inline));
static inline int e1000_raid_prtval(char *_s, size_t _size, e1000_raid_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interrupt delay value (x 1.024us))\n", e1000_raid_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rxcsum_t
 * Description: Implicit type of Receive checksum control register
 * Fields:
 *   pcss	(size 8, offset 0, init 0):	RW	Packet checksum start
 *   ipofld	(size 1, offset 8, init 0):	RW	IP checksum offload enable
 *   tuofld	(size 1, offset 9, init 0):	RW	TCP/UDP checksum offload enable
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
typedef uint32_t e1000_rxcsum_t;
#define e1000_rxcsum_default 0x0
static inline uint8_t e1000_rxcsum_pcss_extract(e1000_rxcsum_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcsum_pcss_extract(e1000_rxcsum_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e1000_rxcsum_t e1000_rxcsum_pcss_insert(e1000_rxcsum_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcsum_t e1000_rxcsum_pcss_insert(e1000_rxcsum_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e1000_rxcsum_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_rxcsum_ipofld_extract(e1000_rxcsum_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcsum_ipofld_extract(e1000_rxcsum_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e1000_rxcsum_t e1000_rxcsum_ipofld_insert(e1000_rxcsum_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcsum_t e1000_rxcsum_ipofld_insert(e1000_rxcsum_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e1000_rxcsum_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_rxcsum_tuofld_extract(e1000_rxcsum_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcsum_tuofld_extract(e1000_rxcsum_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e1000_rxcsum_t e1000_rxcsum_tuofld_insert(e1000_rxcsum_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rxcsum_t e1000_rxcsum_tuofld_insert(e1000_rxcsum_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e1000_rxcsum_t )(_fieldval)) << 9)));
}

static inline int e1000_rxcsum_prtval(char *_s, size_t _size, e1000_rxcsum_t _regval) __attribute__ ((always_inline));
static inline int e1000_rxcsum_prtval(char *_s, size_t _size, e1000_rxcsum_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcss =\t%" PRIx8 "\t(Packet checksum start)\n", e1000_rxcsum_pcss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipofld =\t%" PRIx8 "\t(IP checksum offload enable)\n", e1000_rxcsum_ipofld_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tuofld =\t%" PRIx8 "\t(TCP/UDP checksum offload enable)\n", e1000_rxcsum_tuofld_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rfctl_t
 * Description: Implicit type of Receive filter control register
 * Fields:
 *   iscsi_dis	(size 1, offset 0, init 0):	RW	iSCSI filtering disable
 *   iscsi_dwc	(size 5, offset 1, init 0):	RW	iSCSI dword count
 *   nfsw_dis	(size 1, offset 6, init 0):	RW	NFS write filtering disable
 *   nfsr_dis	(size 1, offset 7, init 0):	RW	NFS read filtering disable
 *   nfs_ver	(size 2, offset 8, init 0):	RW	NFS version (+2)
 *   ipv6_dis	(size 1, offset 10, init 0):	RW	IPv6 filtering disable
 *   ipv6xsum_dis	(size 1, offset 11, init 0):	RW	IPv6 xsum disable
 *   ackdis	(size 1, offset 12, init 0):	RW	ACK accelerator disable
 *   ackd_dis	(size 1, offset 13, init 0):	RW	ACK data disable
 *   ipfrsp_dis	(size 1, offset 14, init 0):	RW	IP fragment split disable
 *   exsten	(size 1, offset 15, init 0):	RW	Extended status enable
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t e1000_rfctl_t;
#define e1000_rfctl_default 0x0
static inline uint8_t e1000_rfctl_iscsi_dis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_iscsi_dis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_rfctl_t e1000_rfctl_iscsi_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_iscsi_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_rfctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_rfctl_iscsi_dwc_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_iscsi_dwc_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x3e) >> 1));
}

static inline e1000_rfctl_t e1000_rfctl_iscsi_dwc_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_iscsi_dwc_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc1) | (0x3e & (((e1000_rfctl_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_rfctl_nfsw_dis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_nfsw_dis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_rfctl_t e1000_rfctl_nfsw_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_nfsw_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_rfctl_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_rfctl_nfsr_dis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_nfsr_dis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_rfctl_t e1000_rfctl_nfsr_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_nfsr_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_rfctl_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_rfctl_nfs_ver_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_nfs_ver_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x300) >> 8));
}

static inline e1000_rfctl_t e1000_rfctl_nfs_ver_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_nfs_ver_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((e1000_rfctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_rfctl_ipv6_dis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ipv6_dis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_rfctl_t e1000_rfctl_ipv6_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_ipv6_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_rfctl_t )(_fieldval)) << 10)));
}

static inline uint8_t e1000_rfctl_ipv6xsum_dis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ipv6xsum_dis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e1000_rfctl_t e1000_rfctl_ipv6xsum_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_ipv6xsum_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e1000_rfctl_t )(_fieldval)) << 11)));
}

static inline uint8_t e1000_rfctl_ackdis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ackdis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e1000_rfctl_t e1000_rfctl_ackdis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_ackdis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e1000_rfctl_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_rfctl_ackd_dis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ackd_dis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e1000_rfctl_t e1000_rfctl_ackd_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_ackd_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e1000_rfctl_t )(_fieldval)) << 13)));
}

static inline uint8_t e1000_rfctl_ipfrsp_dis_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ipfrsp_dis_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e1000_rfctl_t e1000_rfctl_ipfrsp_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_ipfrsp_dis_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e1000_rfctl_t )(_fieldval)) << 14)));
}

static inline uint8_t e1000_rfctl_exsten_extract(e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_exsten_extract(e1000_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_rfctl_t e1000_rfctl_exsten_insert(e1000_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_exsten_insert(e1000_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_rfctl_t )(_fieldval)) << 15)));
}

static inline int e1000_rfctl_prtval(char *_s, size_t _size, e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_rfctl_prtval(char *_s, size_t _size, e1000_rfctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iscsi_dis =\t%" PRIx8 "\t(iSCSI filtering disable)\n", e1000_rfctl_iscsi_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iscsi_dwc =\t%" PRIx8 "\t(iSCSI dword count)\n", e1000_rfctl_iscsi_dwc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsw_dis =\t%" PRIx8 "\t(NFS write filtering disable)\n", e1000_rfctl_nfsw_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsr_dis =\t%" PRIx8 "\t(NFS read filtering disable)\n", e1000_rfctl_nfsr_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfs_ver =\t%" PRIx8 "\t(NFS version (+2))\n", e1000_rfctl_nfs_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6_dis =\t%" PRIx8 "\t(IPv6 filtering disable)\n", e1000_rfctl_ipv6_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6xsum_dis =\t%" PRIx8 "\t(IPv6 xsum disable)\n", e1000_rfctl_ipv6xsum_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ackdis =\t%" PRIx8 "\t(ACK accelerator disable)\n", e1000_rfctl_ackdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ackd_dis =\t%" PRIx8 "\t(ACK data disable)\n", e1000_rfctl_ackd_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipfrsp_dis =\t%" PRIx8 "\t(IP fragment split disable)\n", e1000_rfctl_ipfrsp_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " exsten =\t%" PRIx8 "\t(Extended status enable)\n", e1000_rfctl_exsten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_tctl_t
 * Description: Implicit type of Transmit control register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   en	(size 1, offset 1, init 0):	RW	Transmit enable
 *   _anon2	(size 1, offset 2, init 0):	MBZ	_
 *   psp	(size 1, offset 3, init 0):	RW	Pad short packets
 *   ct	(size 8, offset 4, init 0):	RW	Collision threshold
 *   bst	(size 10, offset 12, init 0):	RW	Back-Off Slot time
 *   swxoff	(size 1, offset 22, init 0):	RW	Software XOFF transmission
 *   _anon23	(size 1, offset 23, init 0):	MBZ	_
 *   rtlc	(size 1, offset 24, init 0):	RW	Retransmit on late collision
 *   unortx	(size 1, offset 25, init 0):	RW	Underrun no re-transmit
 *   txcscmt	(size 2, offset 26, init 0):	RW	Tx descriptor minimum threshold
 *   mulr	(size 1, offset 28, init 0):	RW	Multiple request support
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
typedef uint32_t e1000_tctl_t;
#define e1000_tctl_default 0x0
static inline uint8_t e1000_tctl_en_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_en_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_tctl_t e1000_tctl_en_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_en_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_tctl_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_tctl_psp_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_psp_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_tctl_t e1000_tctl_psp_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_psp_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_tctl_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_tctl_ct_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_ct_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0xff0) >> 4));
}

static inline e1000_tctl_t e1000_tctl_ct_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_ct_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff00f) | (0xff0 & (((e1000_tctl_t )(_fieldval)) << 4)));
}

static inline uint16_t e1000_tctl_bst_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_tctl_bst_extract(e1000_tctl_t _regval)
{
    return((uint16_t )((_regval & 0x3ff000) >> 12));
}

static inline e1000_tctl_t e1000_tctl_bst_insert(e1000_tctl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_bst_insert(e1000_tctl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffc00fff) | (0x3ff000 & (((e1000_tctl_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_tctl_swxoff_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_swxoff_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e1000_tctl_t e1000_tctl_swxoff_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_swxoff_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e1000_tctl_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_tctl_rtlc_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_rtlc_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e1000_tctl_t e1000_tctl_rtlc_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_rtlc_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e1000_tctl_t )(_fieldval)) << 24)));
}

static inline uint8_t e1000_tctl_unortx_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_unortx_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e1000_tctl_t e1000_tctl_unortx_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_unortx_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e1000_tctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e1000_tctl_txcscmt_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_txcscmt_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0xc000000) >> 26));
}

static inline e1000_tctl_t e1000_tctl_txcscmt_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_txcscmt_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((e1000_tctl_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_tctl_mulr_extract(e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_mulr_extract(e1000_tctl_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_tctl_t e1000_tctl_mulr_insert(e1000_tctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_mulr_insert(e1000_tctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_tctl_t )(_fieldval)) << 28)));
}

static inline int e1000_tctl_prtval(char *_s, size_t _size, e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_tctl_prtval(char *_s, size_t _size, e1000_tctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Transmit enable)\n", e1000_tctl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " psp =\t%" PRIx8 "\t(Pad short packets)\n", e1000_tctl_psp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ct =\t%" PRIx8 "\t(Collision threshold)\n", e1000_tctl_ct_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bst =\t%" PRIx16 "\t(Back-Off Slot time)\n", e1000_tctl_bst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swxoff =\t%" PRIx8 "\t(Software XOFF transmission)\n", e1000_tctl_swxoff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtlc =\t%" PRIx8 "\t(Retransmit on late collision)\n", e1000_tctl_rtlc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unortx =\t%" PRIx8 "\t(Underrun no re-transmit)\n", e1000_tctl_unortx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcscmt =\t%" PRIx8 "\t(Tx descriptor minimum threshold)\n", e1000_tctl_txcscmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mulr =\t%" PRIx8 "\t(Multiple request support)\n", e1000_tctl_mulr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_tctl_ext_t
 * Description: Implicit type of Transmit control extended register
 * Fields:
 *   _anon0	(size 10, offset 0, init 0):	MBZ	_
 *   cold	(size 10, offset 10, init 0):	RW	Collision distance
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e1000_tctl_ext_t;
#define e1000_tctl_ext_default 0x0
static inline e1000_coldist_t e1000_tctl_ext_cold_extract(e1000_tctl_ext_t _regval) __attribute__ ((always_inline));
static inline e1000_coldist_t e1000_tctl_ext_cold_extract(e1000_tctl_ext_t _regval)
{
    return((e1000_coldist_t )((_regval & 0xffc00) >> 10));
}

static inline e1000_tctl_ext_t e1000_tctl_ext_cold_insert(e1000_tctl_ext_t _regval, e1000_coldist_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tctl_ext_t e1000_tctl_ext_cold_insert(e1000_tctl_ext_t _regval, e1000_coldist_t _fieldval)
{
    return((_regval & 0xfff003ff) | (0xffc00 & (((e1000_tctl_ext_t )(_fieldval)) << 10)));
}

static inline int e1000_tctl_ext_prtval(char *_s, size_t _size, e1000_tctl_ext_t _regval) __attribute__ ((always_inline));
static inline int e1000_tctl_ext_prtval(char *_s, size_t _size, e1000_tctl_ext_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cold =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_coldist_prtval(_s + _r, _avail, e1000_tctl_ext_cold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Collision distance)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_tipg_t
 * Description: Implicit type of Transmit IPQ register
 * Fields:
 *   ipgt	(size 10, offset 0, init 0):	RW	IPG back to back (x MAC clock, +4)
 *   ipgr1	(size 10, offset 10, init 0):	RW	IPG Part 1
 *   ipgr2	(size 10, offset 20, init 0):	RW	IPG after deferral
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
typedef uint32_t e1000_tipg_t;
#define e1000_tipg_default 0x0
static inline uint16_t e1000_tipg_ipgt_extract(e1000_tipg_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_tipg_ipgt_extract(e1000_tipg_t _regval)
{
    return((uint16_t )((_regval & 0x3ff) >> 0));
}

static inline e1000_tipg_t e1000_tipg_ipgt_insert(e1000_tipg_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tipg_t e1000_tipg_ipgt_insert(e1000_tipg_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc00) | (0x3ff & (((e1000_tipg_t )(_fieldval)) << 0)));
}

static inline uint16_t e1000_tipg_ipgr1_extract(e1000_tipg_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_tipg_ipgr1_extract(e1000_tipg_t _regval)
{
    return((uint16_t )((_regval & 0xffc00) >> 10));
}

static inline e1000_tipg_t e1000_tipg_ipgr1_insert(e1000_tipg_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tipg_t e1000_tipg_ipgr1_insert(e1000_tipg_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfff003ff) | (0xffc00 & (((e1000_tipg_t )(_fieldval)) << 10)));
}

static inline uint16_t e1000_tipg_ipgr2_extract(e1000_tipg_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_tipg_ipgr2_extract(e1000_tipg_t _regval)
{
    return((uint16_t )((_regval & 0x3ff00000) >> 20));
}

static inline e1000_tipg_t e1000_tipg_ipgr2_insert(e1000_tipg_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tipg_t e1000_tipg_ipgr2_insert(e1000_tipg_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xc00fffff) | (0x3ff00000 & (((e1000_tipg_t )(_fieldval)) << 20)));
}

static inline int e1000_tipg_prtval(char *_s, size_t _size, e1000_tipg_t _regval) __attribute__ ((always_inline));
static inline int e1000_tipg_prtval(char *_s, size_t _size, e1000_tipg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipgt =\t%" PRIx16 "\t(IPG back to back (x MAC clock, +4))\n", e1000_tipg_ipgt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipgr1 =\t%" PRIx16 "\t(IPG Part 1)\n", e1000_tipg_ipgr1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipgr2 =\t%" PRIx16 "\t(IPG after deferral)\n", e1000_tipg_ipgr2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_tidv_t
 * Description: Implicit type of Transmit interrupt delay value register
 * Fields:
 *   idv	(size 16, offset 0, init 0):	RW	Interupt delay value
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   fdp	(size 1, offset 31, init 0):	WO	Flush partial description block
 */
typedef uint32_t e1000_tidv_t;
#define e1000_tidv_default 0x0
static inline uint16_t e1000_tidv_idv_extract(e1000_tidv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_tidv_idv_extract(e1000_tidv_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_tidv_t e1000_tidv_idv_insert(e1000_tidv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tidv_t e1000_tidv_idv_insert(e1000_tidv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_tidv_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_tidv_fdp_extract(e1000_tidv_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tidv_fdp_extract(e1000_tidv_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_tidv_t e1000_tidv_fdp_insert(e1000_tidv_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tidv_t e1000_tidv_fdp_insert(e1000_tidv_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_tidv_t )(_fieldval)) << 31)));
}

static inline int e1000_tidv_prtval(char *_s, size_t _size, e1000_tidv_t _regval) __attribute__ ((always_inline));
static inline int e1000_tidv_prtval(char *_s, size_t _size, e1000_tidv_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interupt delay value)\n", e1000_tidv_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fdp =\t%" PRIx8 "\t(Flush partial description block)\n", e1000_tidv_fdp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_txdctl_t
 * Description: Implicit type of Transmit descr. control queue register array
 * Fields:
 *   pthresh	(size 6, offset 0, init 0):	NOATTR	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 8, offset 8, init 0):	NOATTR	Host threshold
 *   wthresh	(size 6, offset 16, init 0):	NOATTR	Write back threshold
 *   _anon22	(size 1, offset 22, init 1):	MB1	_
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   gran	(size 1, offset 24, init 0):	NOATTR	Granularity
 *   lwthresh	(size 7, offset 25, init 0):	NOATTR	Transmit descriptor low threshold
 */
typedef uint32_t e1000_txdctl_t;
#define e1000_txdctl_default 0x400000
static inline uint8_t e1000_txdctl_pthresh_extract(e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_pthresh_extract(e1000_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline e1000_txdctl_t e1000_txdctl_pthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_t e1000_txdctl_pthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((e1000_txdctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_txdctl_hthresh_extract(e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_hthresh_extract(e1000_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_txdctl_t e1000_txdctl_hthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_t e1000_txdctl_hthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_txdctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_txdctl_wthresh_extract(e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_wthresh_extract(e1000_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0x3f0000) >> 16));
}

static inline e1000_txdctl_t e1000_txdctl_wthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_t e1000_txdctl_wthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((e1000_txdctl_t )(_fieldval)) << 16)));
}

static inline e1000_threshgran_t e1000_txdctl_gran_extract(e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline e1000_threshgran_t e1000_txdctl_gran_extract(e1000_txdctl_t _regval)
{
    return((e1000_threshgran_t )((_regval & 0x1000000) >> 24));
}

static inline e1000_txdctl_t e1000_txdctl_gran_insert(e1000_txdctl_t _regval, e1000_threshgran_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_t e1000_txdctl_gran_insert(e1000_txdctl_t _regval, e1000_threshgran_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e1000_txdctl_t )(_fieldval)) << 24)));
}

static inline uint8_t e1000_txdctl_lwthresh_extract(e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_lwthresh_extract(e1000_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0xfe000000) >> 25));
}

static inline e1000_txdctl_t e1000_txdctl_lwthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_t e1000_txdctl_lwthresh_insert(e1000_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x1ffffff) | (0xfe000000 & (((e1000_txdctl_t )(_fieldval)) << 25)));
}

static inline int e1000_txdctl_prtval(char *_s, size_t _size, e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_txdctl_prtval(char *_s, size_t _size, e1000_txdctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_txdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_txdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_txdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gran =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_threshgran_prtval(_s + _r, _avail, e1000_txdctl_gran_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Granularity)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lwthresh =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_txdctl_lwthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_txdctl_82575_t
 * Description: Implicit type of Transmit descr. control queue for 82575 cards register array
 * Fields:
 *   pthresh	(size 6, offset 0, init 0):	NOATTR	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 6, offset 8, init 0):	NOATTR	Host threshold
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 *   wthresh	(size 6, offset 16, init 0):	NOATTR	Write back threshold
 *   _anon22	(size 3, offset 22, init 7):	MB1	_
 *   enable	(size 1, offset 25, init 0):	NOATTR	Enable the queue
 *   swflsh	(size 1, offset 26, init 0):	NOATTR	Transmit Software Flush
 *   priority	(size 1, offset 27, init 0):	NOATTR	Priority
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e1000_txdctl_82575_t;
#define e1000_txdctl_82575_default 0x1c00000
static inline uint8_t e1000_txdctl_82575_pthresh_extract(e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_pthresh_extract(e1000_txdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline e1000_txdctl_82575_t e1000_txdctl_82575_pthresh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_pthresh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((e1000_txdctl_82575_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_txdctl_82575_hthresh_extract(e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_hthresh_extract(e1000_txdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e1000_txdctl_82575_t e1000_txdctl_82575_hthresh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_hthresh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e1000_txdctl_82575_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_txdctl_82575_wthresh_extract(e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_wthresh_extract(e1000_txdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x3f0000) >> 16));
}

static inline e1000_txdctl_82575_t e1000_txdctl_82575_wthresh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_wthresh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((e1000_txdctl_82575_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_txdctl_82575_enable_extract(e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_enable_extract(e1000_txdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e1000_txdctl_82575_t e1000_txdctl_82575_enable_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_enable_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e1000_txdctl_82575_t )(_fieldval)) << 25)));
}

static inline uint8_t e1000_txdctl_82575_swflsh_extract(e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_swflsh_extract(e1000_txdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e1000_txdctl_82575_t e1000_txdctl_82575_swflsh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_swflsh_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e1000_txdctl_82575_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_txdctl_82575_priority_extract(e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_priority_extract(e1000_txdctl_82575_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_txdctl_82575_t e1000_txdctl_82575_priority_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_priority_insert(e1000_txdctl_82575_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_txdctl_82575_t )(_fieldval)) << 27)));
}

static inline int e1000_txdctl_82575_prtval(char *_s, size_t _size, e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline int e1000_txdctl_82575_prtval(char *_s, size_t _size, e1000_txdctl_82575_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_txdctl_82575_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_txdctl_82575_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_txdctl_82575_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Enable the queue)\n", e1000_txdctl_82575_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflsh =\t%" PRIx8 "\t(Transmit Software Flush)\n", e1000_txdctl_82575_swflsh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority)\n", e1000_txdctl_82575_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_tadv_t
 * Description: Implicit type of Tx absolute intr. delay register
 * Fields:
 *   idv	(size 16, offset 0, init 0):	RW	Interrupt delay value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
typedef uint32_t e1000_tadv_t;
#define e1000_tadv_default 0x0
static inline uint16_t e1000_tadv_idv_extract(e1000_tadv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_tadv_idv_extract(e1000_tadv_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_tadv_t e1000_tadv_idv_insert(e1000_tadv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tadv_t e1000_tadv_idv_insert(e1000_tadv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_tadv_t )(_fieldval)) << 0)));
}

static inline int e1000_tadv_prtval(char *_s, size_t _size, e1000_tadv_t _regval) __attribute__ ((always_inline));
static inline int e1000_tadv_prtval(char *_s, size_t _size, e1000_tadv_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interrupt delay value)\n", e1000_tadv_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_tarc_t
 * Description: Implicit type of Tx arbitration counter register array
 * Fields:
 *   count	(size 7, offset 0, init 0):	NOATTR	Transmit arbitration count
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   ratio	(size 2, offset 8, init 0):	NOATTR	Compensation ratio (1 / 2^val)
 *   enable	(size 1, offset 10, init 1):	MB1	enable
 *   _anon11	(size 10, offset 11, init 0):	MBZ	_
 *   _anon21	(size 1, offset 21, init 1):	MB1	_
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   _anon23	(size 4, offset 23, init f):	MB1	_
 *   _anon27	(size 5, offset 27, init 0):	MBZ	_
 */
typedef uint32_t e1000_tarc_t;
#define e1000_tarc_default 0x7a00400
static inline uint8_t e1000_tarc_count_extract(e1000_tarc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tarc_count_extract(e1000_tarc_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline e1000_tarc_t e1000_tarc_count_insert(e1000_tarc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tarc_t e1000_tarc_count_insert(e1000_tarc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((e1000_tarc_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_tarc_ratio_extract(e1000_tarc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tarc_ratio_extract(e1000_tarc_t _regval)
{
    return((uint8_t )((_regval & 0x300) >> 8));
}

static inline e1000_tarc_t e1000_tarc_ratio_insert(e1000_tarc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tarc_t e1000_tarc_ratio_insert(e1000_tarc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((e1000_tarc_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_tarc_enable_extract(e1000_tarc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_tarc_enable_extract(e1000_tarc_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_tarc_t e1000_tarc_enable_insert(e1000_tarc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_tarc_t e1000_tarc_enable_insert(e1000_tarc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_tarc_t )(_fieldval)) << 10)));
}

static inline int e1000_tarc_prtval(char *_s, size_t _size, e1000_tarc_t _regval) __attribute__ ((always_inline));
static inline int e1000_tarc_prtval(char *_s, size_t _size, e1000_tarc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count =\t%" PRIx8 "\t(Transmit arbitration count)\n", e1000_tarc_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ratio =\t%" PRIx8 "\t(Compensation ratio (1 / 2^val))\n", e1000_tarc_ratio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(enable)\n", e1000_tarc_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_rah_t
 * Description: Implicit type of Receive address high register array
 * Fields:
 *   rah	(size 16, offset 0, init 0):	NOATTR	Receive address high
 *   asel	(size 2, offset 16, init 0):	NOATTR	Address select
 *   _anon18	(size 13, offset 18, init 0):	MBZ	_
 *   av	(size 1, offset 31, init 0):	NOATTR	Address valid
 */
typedef uint32_t e1000_rah_t;
#define e1000_rah_default 0x0
static inline uint16_t e1000_rah_rah_extract(e1000_rah_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_rah_rah_extract(e1000_rah_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e1000_rah_t e1000_rah_rah_insert(e1000_rah_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rah_t e1000_rah_rah_insert(e1000_rah_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e1000_rah_t )(_fieldval)) << 0)));
}

static inline e1000_addrsel_t e1000_rah_asel_extract(e1000_rah_t _regval) __attribute__ ((always_inline));
static inline e1000_addrsel_t e1000_rah_asel_extract(e1000_rah_t _regval)
{
    return((e1000_addrsel_t )((_regval & 0x30000) >> 16));
}

static inline e1000_rah_t e1000_rah_asel_insert(e1000_rah_t _regval, e1000_addrsel_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rah_t e1000_rah_asel_insert(e1000_rah_t _regval, e1000_addrsel_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((e1000_rah_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_rah_av_extract(e1000_rah_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_rah_av_extract(e1000_rah_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_rah_t e1000_rah_av_insert(e1000_rah_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_rah_t e1000_rah_av_insert(e1000_rah_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_rah_t )(_fieldval)) << 31)));
}

static inline int e1000_rah_prtval(char *_s, size_t _size, e1000_rah_t _regval) __attribute__ ((always_inline));
static inline int e1000_rah_prtval(char *_s, size_t _size, e1000_rah_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rah =\t%" PRIx16 "\t(Receive address high)\n", e1000_rah_rah_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_addrsel_prtval(_s + _r, _avail, e1000_rah_asel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Address select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " av =\t%" PRIx8 "\t(Address valid)\n", e1000_rah_av_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_mrq_t
 * Description: Implicit type of Multiple queues receive command register
 * Fields:
 *   mrqe	(size 2, offset 0, init 0):	RW	Multiple rx queues enable
 *   rssie	(size 1, offset 2, init 0):	RW	RSS interrupt enable
 *   _anon3	(size 13, offset 3, init 0):	MBZ	_
 *   tcp4	(size 1, offset 16, init 0):	RW	Enable TCP IPv4 hash
 *   ipv4	(size 1, offset 17, init 0):	RW	Enable IPv4 hash
 *   tcp6ex	(size 1, offset 18, init 0):	RW	Enable TCP IPv6 Ex hash
 *   ipv6ex	(size 1, offset 19, init 0):	RW	Enable IPv6 Ex hash
 *   ipv6	(size 1, offset 20, init 0):	RW	Enable IPv6 hash
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
typedef uint32_t e1000_mrq_t;
#define e1000_mrq_default 0x0
static inline e1000_mrqen_t e1000_mrq_mrqe_extract(e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline e1000_mrqen_t e1000_mrq_mrqe_extract(e1000_mrq_t _regval)
{
    return((e1000_mrqen_t )((_regval & 0x3) >> 0));
}

static inline e1000_mrq_t e1000_mrq_mrqe_insert(e1000_mrq_t _regval, e1000_mrqen_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_mrqe_insert(e1000_mrq_t _regval, e1000_mrqen_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e1000_mrq_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_mrq_rssie_extract(e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_rssie_extract(e1000_mrq_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_mrq_t e1000_mrq_rssie_insert(e1000_mrq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_rssie_insert(e1000_mrq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_mrq_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_mrq_tcp4_extract(e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_tcp4_extract(e1000_mrq_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e1000_mrq_t e1000_mrq_tcp4_insert(e1000_mrq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_tcp4_insert(e1000_mrq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e1000_mrq_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_mrq_ipv4_extract(e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_ipv4_extract(e1000_mrq_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e1000_mrq_t e1000_mrq_ipv4_insert(e1000_mrq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_ipv4_insert(e1000_mrq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e1000_mrq_t )(_fieldval)) << 17)));
}

static inline uint8_t e1000_mrq_tcp6ex_extract(e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_tcp6ex_extract(e1000_mrq_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_mrq_t e1000_mrq_tcp6ex_insert(e1000_mrq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_tcp6ex_insert(e1000_mrq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_mrq_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_mrq_ipv6ex_extract(e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_ipv6ex_extract(e1000_mrq_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_mrq_t e1000_mrq_ipv6ex_insert(e1000_mrq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_ipv6ex_insert(e1000_mrq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_mrq_t )(_fieldval)) << 19)));
}

static inline uint8_t e1000_mrq_ipv6_extract(e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_ipv6_extract(e1000_mrq_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_mrq_t e1000_mrq_ipv6_insert(e1000_mrq_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_ipv6_insert(e1000_mrq_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_mrq_t )(_fieldval)) << 20)));
}

static inline int e1000_mrq_prtval(char *_s, size_t _size, e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline int e1000_mrq_prtval(char *_s, size_t _size, e1000_mrq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mrqe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mrqen_prtval(_s + _r, _avail, e1000_mrq_mrqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple rx queues enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rssie =\t%" PRIx8 "\t(RSS interrupt enable)\n", e1000_mrq_rssie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp4 =\t%" PRIx8 "\t(Enable TCP IPv4 hash)\n", e1000_mrq_tcp4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv4 =\t%" PRIx8 "\t(Enable IPv4 hash)\n", e1000_mrq_ipv4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp6ex =\t%" PRIx8 "\t(Enable TCP IPv6 Ex hash)\n", e1000_mrq_tcp6ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6ex =\t%" PRIx8 "\t(Enable IPv6 Ex hash)\n", e1000_mrq_ipv6ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(Enable IPv6 hash)\n", e1000_mrq_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_wuc_t
 * Description: Implicit type of Wakeup control register
 * Fields:
 *   apme	(size 1, offset 0, init 0):	RW	Advanced power mgmt enable
 *   pme_en	(size 1, offset 1, init 0):	RW	PME enable
 *   pme_stat	(size 1, offset 2, init 0):	RW	PME status
 *   apmpme	(size 1, offset 3, init 0):	RW	Assert PME on APM wakeup
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t e1000_wuc_t;
#define e1000_wuc_default 0x0
static inline uint8_t e1000_wuc_apme_extract(e1000_wuc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_apme_extract(e1000_wuc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_wuc_t e1000_wuc_apme_insert(e1000_wuc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wuc_t e1000_wuc_apme_insert(e1000_wuc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_wuc_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_wuc_pme_en_extract(e1000_wuc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_pme_en_extract(e1000_wuc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_wuc_t e1000_wuc_pme_en_insert(e1000_wuc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wuc_t e1000_wuc_pme_en_insert(e1000_wuc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_wuc_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_wuc_pme_stat_extract(e1000_wuc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_pme_stat_extract(e1000_wuc_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_wuc_t e1000_wuc_pme_stat_insert(e1000_wuc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wuc_t e1000_wuc_pme_stat_insert(e1000_wuc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_wuc_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_wuc_apmpme_extract(e1000_wuc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_apmpme_extract(e1000_wuc_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_wuc_t e1000_wuc_apmpme_insert(e1000_wuc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wuc_t e1000_wuc_apmpme_insert(e1000_wuc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_wuc_t )(_fieldval)) << 3)));
}

static inline int e1000_wuc_prtval(char *_s, size_t _size, e1000_wuc_t _regval) __attribute__ ((always_inline));
static inline int e1000_wuc_prtval(char *_s, size_t _size, e1000_wuc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apme =\t%" PRIx8 "\t(Advanced power mgmt enable)\n", e1000_wuc_apme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pme_en =\t%" PRIx8 "\t(PME enable)\n", e1000_wuc_pme_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pme_stat =\t%" PRIx8 "\t(PME status)\n", e1000_wuc_pme_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apmpme =\t%" PRIx8 "\t(Assert PME on APM wakeup)\n", e1000_wuc_apmpme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_wakeup_t
 * Description: Wakeup register
 * Fields:
 *   lnkc	(size 1, offset 0, init 0):	NOATTR	Link status change
 *   mag	(size 1, offset 1, init 0):	NOATTR	Magic packet
 *   ex	(size 1, offset 2, init 0):	NOATTR	Directed exact
 *   mc	(size 1, offset 3, init 0):	NOATTR	Directed multicast
 *   bc	(size 1, offset 4, init 0):	NOATTR	Broadcast
 *   arp	(size 1, offset 5, init 0):	NOATTR	ARP request packet
 *   ipv4	(size 1, offset 6, init 0):	NOATTR	Directed IPv4
 *   ipv6	(size 1, offset 7, init 0):	NOATTR	Directed IPv6
 *   _anon8	(size 7, offset 8, init 0):	MBZ	_
 *   notco	(size 1, offset 15, init 0):	NOATTR	Ignore TCO/management packets
 *   flx0	(size 1, offset 16, init 0):	NOATTR	Flexible filter 0 enable
 *   flx1	(size 1, offset 17, init 0):	NOATTR	Flexible filter 1 enable
 *   flx2	(size 1, offset 18, init 0):	NOATTR	Flexible filter 2 enable
 *   flx3	(size 1, offset 19, init 0):	NOATTR	Flexible filter 3 enable
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
typedef uint32_t e1000_wakeup_t;
#define e1000_wakeup_default 0x0
static inline uint8_t e1000_wakeup_lnkc_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_lnkc_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_wakeup_t e1000_wakeup_lnkc_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_lnkc_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_wakeup_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_wakeup_mag_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_mag_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_wakeup_t e1000_wakeup_mag_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_mag_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_wakeup_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_wakeup_ex_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_ex_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_wakeup_t e1000_wakeup_ex_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_ex_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_wakeup_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_wakeup_mc_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_mc_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_wakeup_t e1000_wakeup_mc_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_mc_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_wakeup_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_wakeup_bc_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_bc_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_wakeup_t e1000_wakeup_bc_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_bc_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_wakeup_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_wakeup_arp_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_arp_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_wakeup_t e1000_wakeup_arp_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_arp_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_wakeup_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_wakeup_ipv4_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_ipv4_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_wakeup_t e1000_wakeup_ipv4_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_ipv4_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_wakeup_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_wakeup_ipv6_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_ipv6_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_wakeup_t e1000_wakeup_ipv6_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_ipv6_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_wakeup_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_wakeup_notco_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_notco_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_wakeup_t e1000_wakeup_notco_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_notco_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_wakeup_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_wakeup_flx0_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_flx0_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e1000_wakeup_t e1000_wakeup_flx0_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_flx0_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e1000_wakeup_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_wakeup_flx1_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_flx1_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e1000_wakeup_t e1000_wakeup_flx1_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_flx1_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e1000_wakeup_t )(_fieldval)) << 17)));
}

static inline uint8_t e1000_wakeup_flx2_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_flx2_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_wakeup_t e1000_wakeup_flx2_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_flx2_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_wakeup_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_wakeup_flx3_extract(e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_wakeup_flx3_extract(e1000_wakeup_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_wakeup_t e1000_wakeup_flx3_insert(e1000_wakeup_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wakeup_flx3_insert(e1000_wakeup_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_wakeup_t )(_fieldval)) << 19)));
}

static inline int e1000_wakeup_prtval(char *_s, size_t _size, e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline int e1000_wakeup_prtval(char *_s, size_t _size, e1000_wakeup_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnkc =\t%" PRIx8 "\t(Link status change)\n", e1000_wakeup_lnkc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mag =\t%" PRIx8 "\t(Magic packet)\n", e1000_wakeup_mag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ex =\t%" PRIx8 "\t(Directed exact)\n", e1000_wakeup_ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mc =\t%" PRIx8 "\t(Directed multicast)\n", e1000_wakeup_mc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bc =\t%" PRIx8 "\t(Broadcast)\n", e1000_wakeup_bc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arp =\t%" PRIx8 "\t(ARP request packet)\n", e1000_wakeup_arp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv4 =\t%" PRIx8 "\t(Directed IPv4)\n", e1000_wakeup_ipv4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(Directed IPv6)\n", e1000_wakeup_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " notco =\t%" PRIx8 "\t(Ignore TCO/management packets)\n", e1000_wakeup_notco_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx0 =\t%" PRIx8 "\t(Flexible filter 0 enable)\n", e1000_wakeup_flx0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx1 =\t%" PRIx8 "\t(Flexible filter 1 enable)\n", e1000_wakeup_flx1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx2 =\t%" PRIx8 "\t(Flexible filter 2 enable)\n", e1000_wakeup_flx2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx3 =\t%" PRIx8 "\t(Flexible filter 3 enable)\n", e1000_wakeup_flx3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ipav_t
 * Description: Implicit type of IP address valid register
 * Fields:
 *   v40	(size 1, offset 0, init 0):	RW	IPv4 address 0 valid
 *   v41	(size 1, offset 1, init 0):	RW	IPv4 address 1 valid
 *   v42	(size 1, offset 2, init 0):	RW	IPv4 address 2 valid
 *   v43	(size 1, offset 3, init 0):	RW	IPv4 address 3 valid
 *   _anon4	(size 12, offset 4, init 0):	MBZ	_
 *   v60	(size 1, offset 16, init 0):	RW	IPv6 address 0 valid
 *   _anon17	(size 15, offset 17, init 0):	MBZ	_
 */
typedef uint32_t e1000_ipav_t;
#define e1000_ipav_default 0x0
static inline uint8_t e1000_ipav_v40_extract(e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v40_extract(e1000_ipav_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_ipav_t e1000_ipav_v40_insert(e1000_ipav_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ipav_t e1000_ipav_v40_insert(e1000_ipav_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_ipav_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_ipav_v41_extract(e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v41_extract(e1000_ipav_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_ipav_t e1000_ipav_v41_insert(e1000_ipav_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ipav_t e1000_ipav_v41_insert(e1000_ipav_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_ipav_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_ipav_v42_extract(e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v42_extract(e1000_ipav_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_ipav_t e1000_ipav_v42_insert(e1000_ipav_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ipav_t e1000_ipav_v42_insert(e1000_ipav_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_ipav_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_ipav_v43_extract(e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v43_extract(e1000_ipav_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_ipav_t e1000_ipav_v43_insert(e1000_ipav_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ipav_t e1000_ipav_v43_insert(e1000_ipav_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_ipav_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_ipav_v60_extract(e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v60_extract(e1000_ipav_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e1000_ipav_t e1000_ipav_v60_insert(e1000_ipav_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ipav_t e1000_ipav_v60_insert(e1000_ipav_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e1000_ipav_t )(_fieldval)) << 16)));
}

static inline int e1000_ipav_prtval(char *_s, size_t _size, e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline int e1000_ipav_prtval(char *_s, size_t _size, e1000_ipav_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v40 =\t%" PRIx8 "\t(IPv4 address 0 valid)\n", e1000_ipav_v40_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v41 =\t%" PRIx8 "\t(IPv4 address 1 valid)\n", e1000_ipav_v41_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v42 =\t%" PRIx8 "\t(IPv4 address 2 valid)\n", e1000_ipav_v42_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v43 =\t%" PRIx8 "\t(IPv4 address 3 valid)\n", e1000_ipav_v43_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v60 =\t%" PRIx8 "\t(IPv6 address 0 valid)\n", e1000_ipav_v60_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_wupl_t
 * Description: Implicit type of Wakeup packet length register
 * Fields:
 *   len	(size 12, offset 0, init 0):	RW	Length
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
typedef uint32_t e1000_wupl_t;
#define e1000_wupl_default 0x0
static inline uint16_t e1000_wupl_len_extract(e1000_wupl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_wupl_len_extract(e1000_wupl_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e1000_wupl_t e1000_wupl_len_insert(e1000_wupl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_wupl_t e1000_wupl_len_insert(e1000_wupl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e1000_wupl_t )(_fieldval)) << 0)));
}

static inline int e1000_wupl_prtval(char *_s, size_t _size, e1000_wupl_t _regval) __attribute__ ((always_inline));
static inline int e1000_wupl_prtval(char *_s, size_t _size, e1000_wupl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx16 "\t(Length)\n", e1000_wupl_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_fflt_t
 * Description: Implicit type of Flexible filter length table register array
 * Fields:
 *   len	(size 11, offset 0, init 0):	NOATTR	Length
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t e1000_fflt_t;
#define e1000_fflt_default 0x0
static inline uint16_t e1000_fflt_len_extract(e1000_fflt_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_fflt_len_extract(e1000_fflt_t _regval)
{
    return((uint16_t )((_regval & 0x7ff) >> 0));
}

static inline e1000_fflt_t e1000_fflt_len_insert(e1000_fflt_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fflt_t e1000_fflt_len_insert(e1000_fflt_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff800) | (0x7ff & (((e1000_fflt_t )(_fieldval)) << 0)));
}

static inline int e1000_fflt_prtval(char *_s, size_t _size, e1000_fflt_t _regval) __attribute__ ((always_inline));
static inline int e1000_fflt_prtval(char *_s, size_t _size, e1000_fflt_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx16 "\t(Length)\n", e1000_fflt_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ffltco_t
 * Description: Implicit type of Flexible filter length table register array
 * Fields:
 *   tcolen	(size 11, offset 0, init 0):	NOATTR	Length
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
typedef uint32_t e1000_ffltco_t;
#define e1000_ffltco_default 0x0
static inline uint16_t e1000_ffltco_tcolen_extract(e1000_ffltco_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_ffltco_tcolen_extract(e1000_ffltco_t _regval)
{
    return((uint16_t )((_regval & 0x7ff) >> 0));
}

static inline e1000_ffltco_t e1000_ffltco_tcolen_insert(e1000_ffltco_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ffltco_t e1000_ffltco_tcolen_insert(e1000_ffltco_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff800) | (0x7ff & (((e1000_ffltco_t )(_fieldval)) << 0)));
}

static inline int e1000_ffltco_prtval(char *_s, size_t _size, e1000_ffltco_t _regval) __attribute__ ((always_inline));
static inline int e1000_ffltco_prtval(char *_s, size_t _size, e1000_ffltco_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcolen =\t%" PRIx16 "\t(Length)\n", e1000_ffltco_tcolen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ffmt_t
 * Description: Implicit type of Flexible filter mask table register array
 * Fields:
 *   mask	(size 4, offset 0, init 0):	NOATTR	mask
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
typedef uint32_t e1000_ffmt_t;
#define e1000_ffmt_default 0x0
static inline uint8_t e1000_ffmt_mask_extract(e1000_ffmt_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ffmt_mask_extract(e1000_ffmt_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline e1000_ffmt_t e1000_ffmt_mask_insert(e1000_ffmt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ffmt_t e1000_ffmt_mask_insert(e1000_ffmt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((e1000_ffmt_t )(_fieldval)) << 0)));
}

static inline int e1000_ffmt_prtval(char *_s, size_t _size, e1000_ffmt_t _regval) __attribute__ ((always_inline));
static inline int e1000_ffmt_prtval(char *_s, size_t _size, e1000_ffmt_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t%" PRIx8 "\t(mask)\n", e1000_ffmt_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_ffvt_t
 * Description: Implicit type of Flexible filter value table register array
 * Fields:
 *   val0	(size 8, offset 0, init 0):	NOATTR	Value 0
 *   val1	(size 8, offset 8, init 0):	NOATTR	Value 1
 *   val2	(size 8, offset 16, init 0):	NOATTR	Value 2
 *   val3	(size 8, offset 24, init 0):	NOATTR	Value 3
 */
typedef uint32_t e1000_ffvt_t;
#define e1000_ffvt_default 0x0
static inline uint8_t e1000_ffvt_val0_extract(e1000_ffvt_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val0_extract(e1000_ffvt_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e1000_ffvt_t e1000_ffvt_val0_insert(e1000_ffvt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ffvt_t e1000_ffvt_val0_insert(e1000_ffvt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e1000_ffvt_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_ffvt_val1_extract(e1000_ffvt_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val1_extract(e1000_ffvt_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_ffvt_t e1000_ffvt_val1_insert(e1000_ffvt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ffvt_t e1000_ffvt_val1_insert(e1000_ffvt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_ffvt_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_ffvt_val2_extract(e1000_ffvt_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val2_extract(e1000_ffvt_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline e1000_ffvt_t e1000_ffvt_val2_insert(e1000_ffvt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ffvt_t e1000_ffvt_val2_insert(e1000_ffvt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((e1000_ffvt_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_ffvt_val3_extract(e1000_ffvt_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val3_extract(e1000_ffvt_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline e1000_ffvt_t e1000_ffvt_val3_insert(e1000_ffvt_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_ffvt_t e1000_ffvt_val3_insert(e1000_ffvt_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((e1000_ffvt_t )(_fieldval)) << 24)));
}

static inline int e1000_ffvt_prtval(char *_s, size_t _size, e1000_ffvt_t _regval) __attribute__ ((always_inline));
static inline int e1000_ffvt_prtval(char *_s, size_t _size, e1000_ffvt_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val0 =\t%" PRIx8 "\t(Value 0)\n", e1000_ffvt_val0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val1 =\t%" PRIx8 "\t(Value 1)\n", e1000_ffvt_val1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val2 =\t%" PRIx8 "\t(Value 2)\n", e1000_ffvt_val2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val3 =\t%" PRIx8 "\t(Value 3)\n", e1000_ffvt_val3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_manc_t
 * Description: Implicit type of Management control register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   en_flexport0	(size 1, offset 3, init 0):	RW	Enable flex UDP/TCP port 0 filtering
 *   en_flexport1	(size 1, offset 4, init 0):	RW	Enable flex UDP/TCP port 1 filtering
 *   en_flexport2	(size 1, offset 5, init 0):	RW	Enable flex UDP/TCP port 2 filtering
 *   flex_tco1_filter	(size 1, offset 6, init 0):	RW	Enable TCO filter 1
 *   flex_tco0_filter	(size 1, offset 7, init 0):	RW	Enable TCO filter 0
 *   rmcp_en	(size 1, offset 8, init 0):	RW	Enable RMCP 0x026f filtering
 *   o298_en	(size 1, offset 9, init 0):	RW	Enable RMCP 0x0298 filtering
 *   _anon10	(size 3, offset 10, init 0):	MBZ	_
 *   arp_req_en	(size 1, offset 13, init 0):	RW	Enable ARP request filtering
 *   neighbor_en	(size 1, offset 14, init 0):	RW	Enable neighbor discovery filtering
 *   arp_res_en	(size 1, offset 15, init 0):	RW	Enable ARP response filtering
 *   tco_reset	(size 1, offset 16, init 0):	RW	TCO reset occurred
 *   rcv_tco_en	(size 1, offset 17, init 0):	RW	Receive TCO packets enable
 *   blk_phyrst_on_ide	(size 1, offset 18, init 0):	RW	Block PHY reset and power on state changes
 *   rcv_all	(size 1, offset 19, init 0):	RW	Receive all enable
 *   en_mac16_filter	(size 1, offset 20, init 0):	RW	Enable MAC address 16 filtering
 *   en_mng2host	(size 1, offset 21, init 0):	RW	Enable firmware packets to host memory
 *   en_ip_addrfilter	(size 1, offset 22, init 0):	RW	Enable IP address filtering
 *   en_xsum_filter	(size 1, offset 23, init 0):	RW	Enable Xsum filtering to firmware
 *   br_en	(size 1, offset 24, init 0):	RW	Enable broadcast filtering
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
typedef uint32_t e1000_manc_t;
#define e1000_manc_default 0x0
static inline uint8_t e1000_manc_en_flexport0_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_flexport0_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_manc_t e1000_manc_en_flexport0_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_en_flexport0_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_manc_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_manc_en_flexport1_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_flexport1_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_manc_t e1000_manc_en_flexport1_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_en_flexport1_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_manc_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_manc_en_flexport2_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_flexport2_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_manc_t e1000_manc_en_flexport2_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_en_flexport2_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_manc_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_manc_flex_tco1_filter_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_flex_tco1_filter_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_manc_t e1000_manc_flex_tco1_filter_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_flex_tco1_filter_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_manc_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_manc_flex_tco0_filter_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_flex_tco0_filter_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_manc_t e1000_manc_flex_tco0_filter_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_flex_tco0_filter_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_manc_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_manc_rmcp_en_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_rmcp_en_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e1000_manc_t e1000_manc_rmcp_en_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_rmcp_en_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e1000_manc_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_manc_o298_en_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_o298_en_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e1000_manc_t e1000_manc_o298_en_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_o298_en_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e1000_manc_t )(_fieldval)) << 9)));
}

static inline uint8_t e1000_manc_arp_req_en_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_arp_req_en_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e1000_manc_t e1000_manc_arp_req_en_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_arp_req_en_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e1000_manc_t )(_fieldval)) << 13)));
}

static inline uint8_t e1000_manc_neighbor_en_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_neighbor_en_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e1000_manc_t e1000_manc_neighbor_en_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_neighbor_en_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e1000_manc_t )(_fieldval)) << 14)));
}

static inline uint8_t e1000_manc_arp_res_en_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_arp_res_en_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_manc_t e1000_manc_arp_res_en_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_arp_res_en_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_manc_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_manc_tco_reset_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_tco_reset_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e1000_manc_t e1000_manc_tco_reset_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_tco_reset_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e1000_manc_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_manc_rcv_tco_en_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_rcv_tco_en_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e1000_manc_t e1000_manc_rcv_tco_en_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_rcv_tco_en_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e1000_manc_t )(_fieldval)) << 17)));
}

static inline uint8_t e1000_manc_blk_phyrst_on_ide_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_blk_phyrst_on_ide_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e1000_manc_t e1000_manc_blk_phyrst_on_ide_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_blk_phyrst_on_ide_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e1000_manc_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_manc_rcv_all_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_rcv_all_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e1000_manc_t e1000_manc_rcv_all_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_rcv_all_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e1000_manc_t )(_fieldval)) << 19)));
}

static inline uint8_t e1000_manc_en_mac16_filter_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_mac16_filter_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_manc_t e1000_manc_en_mac16_filter_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_en_mac16_filter_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_manc_t )(_fieldval)) << 20)));
}

static inline uint8_t e1000_manc_en_mng2host_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_mng2host_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e1000_manc_t e1000_manc_en_mng2host_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_en_mng2host_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_manc_t )(_fieldval)) << 21)));
}

static inline uint8_t e1000_manc_en_ip_addrfilter_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_ip_addrfilter_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e1000_manc_t e1000_manc_en_ip_addrfilter_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_en_ip_addrfilter_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e1000_manc_t )(_fieldval)) << 22)));
}

static inline uint8_t e1000_manc_en_xsum_filter_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_xsum_filter_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e1000_manc_t e1000_manc_en_xsum_filter_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_en_xsum_filter_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e1000_manc_t )(_fieldval)) << 23)));
}

static inline uint8_t e1000_manc_br_en_extract(e1000_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_br_en_extract(e1000_manc_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e1000_manc_t e1000_manc_br_en_insert(e1000_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_br_en_insert(e1000_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e1000_manc_t )(_fieldval)) << 24)));
}

static inline int e1000_manc_prtval(char *_s, size_t _size, e1000_manc_t _regval) __attribute__ ((always_inline));
static inline int e1000_manc_prtval(char *_s, size_t _size, e1000_manc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_flexport0 =\t%" PRIx8 "\t(Enable flex UDP/TCP port 0 filtering)\n", e1000_manc_en_flexport0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_flexport1 =\t%" PRIx8 "\t(Enable flex UDP/TCP port 1 filtering)\n", e1000_manc_en_flexport1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_flexport2 =\t%" PRIx8 "\t(Enable flex UDP/TCP port 2 filtering)\n", e1000_manc_en_flexport2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex_tco1_filter =\t%" PRIx8 "\t(Enable TCO filter 1)\n", e1000_manc_flex_tco1_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex_tco0_filter =\t%" PRIx8 "\t(Enable TCO filter 0)\n", e1000_manc_flex_tco0_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rmcp_en =\t%" PRIx8 "\t(Enable RMCP 0x026f filtering)\n", e1000_manc_rmcp_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " o298_en =\t%" PRIx8 "\t(Enable RMCP 0x0298 filtering)\n", e1000_manc_o298_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arp_req_en =\t%" PRIx8 "\t(Enable ARP request filtering)\n", e1000_manc_arp_req_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " neighbor_en =\t%" PRIx8 "\t(Enable neighbor discovery filtering)\n", e1000_manc_neighbor_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arp_res_en =\t%" PRIx8 "\t(Enable ARP response filtering)\n", e1000_manc_arp_res_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tco_reset =\t%" PRIx8 "\t(TCO reset occurred)\n", e1000_manc_tco_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_tco_en =\t%" PRIx8 "\t(Receive TCO packets enable)\n", e1000_manc_rcv_tco_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " blk_phyrst_on_ide =\t%" PRIx8 "\t(Block PHY reset and power on state changes)\n", e1000_manc_blk_phyrst_on_ide_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_all =\t%" PRIx8 "\t(Receive all enable)\n", e1000_manc_rcv_all_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_mac16_filter =\t%" PRIx8 "\t(Enable MAC address 16 filtering)\n", e1000_manc_en_mac16_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_mng2host =\t%" PRIx8 "\t(Enable firmware packets to host memory)\n", e1000_manc_en_mng2host_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ip_addrfilter =\t%" PRIx8 "\t(Enable IP address filtering)\n", e1000_manc_en_ip_addrfilter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_xsum_filter =\t%" PRIx8 "\t(Enable Xsum filtering to firmware)\n", e1000_manc_en_xsum_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " br_en =\t%" PRIx8 "\t(Enable broadcast filtering)\n", e1000_manc_br_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_gcr_t
 * Description: Implicit type of PCIe control register
 * Fields:
 *   rxd_nosnoop	(size 1, offset 0, init 0):	RW	Receive data write
 *   rxdscw_nosnoop	(size 1, offset 1, init 0):	RW	Receive descriptor write
 *   rxdscr_nosnoop	(size 1, offset 2, init 0):	RW	Receive descriptor read
 *   txd_nosnoop	(size 1, offset 3, init 0):	RW	Transmit data write
 *   txdscw_nosnoop	(size 1, offset 4, init 0):	RW	Transmit descriptor write
 *   txdscr_nosnoop	(size 1, offset 5, init 0):	RW	Transmit descriptor read
 *   elec_idle_in0	(size 1, offset 6, init 0):	RO	SerDes0 internal electrical idle indicator
 *   elec_idle_in1	(size 1, offset 7, init 0):	RO	SerDes1 internal electrical idle indicator
 *   self_test_enable	(size 1, offset 8, init 0):	RW	Perform self test
 *   _anon9	(size 12, offset 9, init 0):	MBZ	_
 *   logheader	(size 1, offset 21, init 0):	RW	Log header into PCI config space
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   l1el_msb	(size 1, offset 23, init 0):	RO	L1 Entry latency msb
 *   l0s_el	(size 1, offset 24, init 0):	RW	L0s entry latency
 *   l1el_lsb	(size 2, offset 25, init 0):	RO	L1 Entry latency lsbs
 *   l1_aw_l0s	(size 1, offset 27, init 0):	RW	L1 act without L0s_rx correlation
 *   gio_dis_rderr	(size 1, offset 28, init 0):	RW	Disable running disparity err
 *   gio_good_10s	(size 1, offset 29, init 0):	RW	Force good PCIe l0s training
 *   self_test_result	(size 1, offset 30, init 0):	RW	Result of self test
 *   dis_tmout	(size 1, offset 31, init 0):	RW	Disable PCIe timeout mechanism
 */
typedef uint32_t e1000_gcr_t;
#define e1000_gcr_default 0x0
static inline uint8_t e1000_gcr_rxd_nosnoop_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_rxd_nosnoop_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_gcr_t e1000_gcr_rxd_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_rxd_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_gcr_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_gcr_rxdscw_nosnoop_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_rxdscw_nosnoop_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_gcr_t e1000_gcr_rxdscw_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_rxdscw_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_gcr_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_gcr_rxdscr_nosnoop_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_rxdscr_nosnoop_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_gcr_t e1000_gcr_rxdscr_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_rxdscr_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_gcr_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_gcr_txd_nosnoop_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_txd_nosnoop_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_gcr_t e1000_gcr_txd_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_txd_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_gcr_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_gcr_txdscw_nosnoop_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_txdscw_nosnoop_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_gcr_t e1000_gcr_txdscw_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_txdscw_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_gcr_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_gcr_txdscr_nosnoop_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_txdscr_nosnoop_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_gcr_t e1000_gcr_txdscr_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_txdscr_nosnoop_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_gcr_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_gcr_elec_idle_in0_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_elec_idle_in0_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_gcr_t e1000_gcr_elec_idle_in0_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_elec_idle_in0_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_gcr_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_gcr_elec_idle_in1_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_elec_idle_in1_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e1000_gcr_t e1000_gcr_elec_idle_in1_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_elec_idle_in1_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e1000_gcr_t )(_fieldval)) << 7)));
}

static inline uint8_t e1000_gcr_self_test_enable_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_self_test_enable_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e1000_gcr_t e1000_gcr_self_test_enable_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_self_test_enable_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e1000_gcr_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_gcr_logheader_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_logheader_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e1000_gcr_t e1000_gcr_logheader_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_logheader_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_gcr_t )(_fieldval)) << 21)));
}

static inline uint8_t e1000_gcr_l1el_msb_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l1el_msb_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e1000_gcr_t e1000_gcr_l1el_msb_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_l1el_msb_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e1000_gcr_t )(_fieldval)) << 23)));
}

static inline uint8_t e1000_gcr_l0s_el_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l0s_el_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e1000_gcr_t e1000_gcr_l0s_el_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_l0s_el_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e1000_gcr_t )(_fieldval)) << 24)));
}

static inline uint8_t e1000_gcr_l1el_lsb_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l1el_lsb_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x6000000) >> 25));
}

static inline e1000_gcr_t e1000_gcr_l1el_lsb_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_l1el_lsb_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf9ffffff) | (0x6000000 & (((e1000_gcr_t )(_fieldval)) << 25)));
}

static inline uint8_t e1000_gcr_l1_aw_l0s_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l1_aw_l0s_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_gcr_t e1000_gcr_l1_aw_l0s_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_l1_aw_l0s_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_gcr_t )(_fieldval)) << 27)));
}

static inline uint8_t e1000_gcr_gio_dis_rderr_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_gio_dis_rderr_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_gcr_t e1000_gcr_gio_dis_rderr_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_gio_dis_rderr_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_gcr_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_gcr_gio_good_10s_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_gio_good_10s_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_gcr_t e1000_gcr_gio_good_10s_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_gio_good_10s_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_gcr_t )(_fieldval)) << 29)));
}

static inline uint8_t e1000_gcr_self_test_result_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_self_test_result_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_gcr_t e1000_gcr_self_test_result_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_self_test_result_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_gcr_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_gcr_dis_tmout_extract(e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_dis_tmout_extract(e1000_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_gcr_t e1000_gcr_dis_tmout_insert(e1000_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_dis_tmout_insert(e1000_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_gcr_t )(_fieldval)) << 31)));
}

static inline int e1000_gcr_prtval(char *_s, size_t _size, e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline int e1000_gcr_prtval(char *_s, size_t _size, e1000_gcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxd_nosnoop =\t%" PRIx8 "\t(Receive data write)\n", e1000_gcr_rxd_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdscw_nosnoop =\t%" PRIx8 "\t(Receive descriptor write)\n", e1000_gcr_rxdscw_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdscr_nosnoop =\t%" PRIx8 "\t(Receive descriptor read)\n", e1000_gcr_rxdscr_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_nosnoop =\t%" PRIx8 "\t(Transmit data write)\n", e1000_gcr_txd_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdscw_nosnoop =\t%" PRIx8 "\t(Transmit descriptor write)\n", e1000_gcr_txdscw_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdscr_nosnoop =\t%" PRIx8 "\t(Transmit descriptor read)\n", e1000_gcr_txdscr_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " elec_idle_in0 =\t%" PRIx8 "\t(SerDes0 internal electrical idle indicator)\n", e1000_gcr_elec_idle_in0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " elec_idle_in1 =\t%" PRIx8 "\t(SerDes1 internal electrical idle indicator)\n", e1000_gcr_elec_idle_in1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " self_test_enable =\t%" PRIx8 "\t(Perform self test)\n", e1000_gcr_self_test_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " logheader =\t%" PRIx8 "\t(Log header into PCI config space)\n", e1000_gcr_logheader_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1el_msb =\t%" PRIx8 "\t(L1 Entry latency msb)\n", e1000_gcr_l1el_msb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l0s_el =\t%" PRIx8 "\t(L0s entry latency)\n", e1000_gcr_l0s_el_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1el_lsb =\t%" PRIx8 "\t(L1 Entry latency lsbs)\n", e1000_gcr_l1el_lsb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1_aw_l0s =\t%" PRIx8 "\t(L1 act without L0s_rx correlation)\n", e1000_gcr_l1_aw_l0s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_dis_rderr =\t%" PRIx8 "\t(Disable running disparity err)\n", e1000_gcr_gio_dis_rderr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_good_10s =\t%" PRIx8 "\t(Force good PCIe l0s training)\n", e1000_gcr_gio_good_10s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " self_test_result =\t%" PRIx8 "\t(Result of self test)\n", e1000_gcr_self_test_result_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_tmout =\t%" PRIx8 "\t(Disable PCIe timeout mechanism)\n", e1000_gcr_dis_tmout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_gscl1_t
 * Description: Implicit type of PCIe statistics control 1 register
 * Fields:
 *   count_en0	(size 1, offset 0, init 0):	RW	Enable PCIe stats counter 0
 *   count_en1	(size 1, offset 1, init 0):	RW	Enable PCIe stats counter 1
 *   count_en2	(size 1, offset 2, init 0):	RW	Enable PCIe stats counter 2
 *   count_en3	(size 1, offset 3, init 0):	RW	Enable PCIe stats counter 3
 *   _anon4	(size 23, offset 4, init 0):	RSVD	_
 *   count_test	(size 1, offset 27, init 0):	RW	Test bit
 *   en_64bit	(size 1, offset 28, init 0):	RW	Enable two 64-bit counters instead of 4 32-bit
 *   count_reset	(size 1, offset 29, init 0):	RW	Reset indication of PCIe stats
 *   count_stop	(size 1, offset 30, init 0):	RW	Stop indication
 *   count_start	(size 1, offset 31, init 0):	RW	Start indication
 */
typedef uint32_t e1000_gscl1_t;
#define e1000_gscl1_default 0x0
static inline uint8_t e1000_gscl1_count_en0_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en0_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_gscl1_t e1000_gscl1_count_en0_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_en0_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_gscl1_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_gscl1_count_en1_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en1_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_gscl1_t e1000_gscl1_count_en1_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_en1_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_gscl1_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_gscl1_count_en2_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en2_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_gscl1_t e1000_gscl1_count_en2_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_en2_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_gscl1_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_gscl1_count_en3_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en3_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_gscl1_t e1000_gscl1_count_en3_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_en3_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_gscl1_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_gscl1_count_test_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_test_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_gscl1_t e1000_gscl1_count_test_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_test_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_gscl1_t )(_fieldval)) << 27)));
}

static inline uint8_t e1000_gscl1_en_64bit_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_en_64bit_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e1000_gscl1_t e1000_gscl1_en_64bit_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_en_64bit_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e1000_gscl1_t )(_fieldval)) << 28)));
}

static inline uint8_t e1000_gscl1_count_reset_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_reset_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_gscl1_t e1000_gscl1_count_reset_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_reset_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_gscl1_t )(_fieldval)) << 29)));
}

static inline uint8_t e1000_gscl1_count_stop_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_stop_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_gscl1_t e1000_gscl1_count_stop_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_stop_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_gscl1_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_gscl1_count_start_extract(e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_start_extract(e1000_gscl1_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_gscl1_t e1000_gscl1_count_start_insert(e1000_gscl1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_count_start_insert(e1000_gscl1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_gscl1_t )(_fieldval)) << 31)));
}

static inline int e1000_gscl1_prtval(char *_s, size_t _size, e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline int e1000_gscl1_prtval(char *_s, size_t _size, e1000_gscl1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en0 =\t%" PRIx8 "\t(Enable PCIe stats counter 0)\n", e1000_gscl1_count_en0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en1 =\t%" PRIx8 "\t(Enable PCIe stats counter 1)\n", e1000_gscl1_count_en1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en2 =\t%" PRIx8 "\t(Enable PCIe stats counter 2)\n", e1000_gscl1_count_en2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en3 =\t%" PRIx8 "\t(Enable PCIe stats counter 3)\n", e1000_gscl1_count_en3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_test =\t%" PRIx8 "\t(Test bit)\n", e1000_gscl1_count_test_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_64bit =\t%" PRIx8 "\t(Enable two 64-bit counters instead of 4 32-bit)\n", e1000_gscl1_en_64bit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_reset =\t%" PRIx8 "\t(Reset indication of PCIe stats)\n", e1000_gscl1_count_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_stop =\t%" PRIx8 "\t(Stop indication)\n", e1000_gscl1_count_stop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_start =\t%" PRIx8 "\t(Start indication)\n", e1000_gscl1_count_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_gscl2_t
 * Description: Implicit type of PCIe statistics control 2 register
 * Fields:
 *   event0	(size 8, offset 0, init 0):	RW	Event number that counter 0 counts
 *   event1	(size 8, offset 8, init 0):	RW	Event number that counter 1 counts
 *   event2	(size 8, offset 16, init 0):	RW	Event number that counter 2 counts
 *   event3	(size 8, offset 24, init 0):	RW	Event number that counter 3 counts
 */
typedef uint32_t e1000_gscl2_t;
#define e1000_gscl2_default 0x0
static inline uint8_t e1000_gscl2_event0_extract(e1000_gscl2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event0_extract(e1000_gscl2_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e1000_gscl2_t e1000_gscl2_event0_insert(e1000_gscl2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl2_t e1000_gscl2_event0_insert(e1000_gscl2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e1000_gscl2_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_gscl2_event1_extract(e1000_gscl2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event1_extract(e1000_gscl2_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_gscl2_t e1000_gscl2_event1_insert(e1000_gscl2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl2_t e1000_gscl2_event1_insert(e1000_gscl2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_gscl2_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_gscl2_event2_extract(e1000_gscl2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event2_extract(e1000_gscl2_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline e1000_gscl2_t e1000_gscl2_event2_insert(e1000_gscl2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl2_t e1000_gscl2_event2_insert(e1000_gscl2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((e1000_gscl2_t )(_fieldval)) << 16)));
}

static inline uint8_t e1000_gscl2_event3_extract(e1000_gscl2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event3_extract(e1000_gscl2_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline e1000_gscl2_t e1000_gscl2_event3_insert(e1000_gscl2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl2_t e1000_gscl2_event3_insert(e1000_gscl2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((e1000_gscl2_t )(_fieldval)) << 24)));
}

static inline int e1000_gscl2_prtval(char *_s, size_t _size, e1000_gscl2_t _regval) __attribute__ ((always_inline));
static inline int e1000_gscl2_prtval(char *_s, size_t _size, e1000_gscl2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event0 =\t%" PRIx8 "\t(Event number that counter 0 counts)\n", e1000_gscl2_event0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event1 =\t%" PRIx8 "\t(Event number that counter 1 counts)\n", e1000_gscl2_event1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event2 =\t%" PRIx8 "\t(Event number that counter 2 counts)\n", e1000_gscl2_event2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event3 =\t%" PRIx8 "\t(Event number that counter 3 counts)\n", e1000_gscl2_event3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_gscl3_t
 * Description: Implicit type of PCIe statistics control 3 register
 * Fields:
 *   fc_th0	(size 12, offset 0, init 0):	RW	Threshold of flow control credits 0
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   fc_th1	(size 12, offset 16, init 0):	RW	Threshold of flow control credits 1
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e1000_gscl3_t;
#define e1000_gscl3_default 0x0
static inline uint16_t e1000_gscl3_fc_th0_extract(e1000_gscl3_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_gscl3_fc_th0_extract(e1000_gscl3_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e1000_gscl3_t e1000_gscl3_fc_th0_insert(e1000_gscl3_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl3_t e1000_gscl3_fc_th0_insert(e1000_gscl3_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e1000_gscl3_t )(_fieldval)) << 0)));
}

static inline uint16_t e1000_gscl3_fc_th1_extract(e1000_gscl3_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_gscl3_fc_th1_extract(e1000_gscl3_t _regval)
{
    return((uint16_t )((_regval & 0xfff0000) >> 16));
}

static inline e1000_gscl3_t e1000_gscl3_fc_th1_insert(e1000_gscl3_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl3_t e1000_gscl3_fc_th1_insert(e1000_gscl3_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xf000ffff) | (0xfff0000 & (((e1000_gscl3_t )(_fieldval)) << 16)));
}

static inline int e1000_gscl3_prtval(char *_s, size_t _size, e1000_gscl3_t _regval) __attribute__ ((always_inline));
static inline int e1000_gscl3_prtval(char *_s, size_t _size, e1000_gscl3_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fc_th0 =\t%" PRIx16 "\t(Threshold of flow control credits 0)\n", e1000_gscl3_fc_th0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fc_th1 =\t%" PRIx16 "\t(Threshold of flow control credits 1)\n", e1000_gscl3_fc_th1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_gscl4_t
 * Description: Implicit type of PCIe statistics control 4 register
 * Fields:
 *   coml_th	(size 10, offset 0, init 0):	RW	Completions latency threshold
 *   rb_th	(size 6, offset 10, init 0):	RW	Retry buffer threshold
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e1000_gscl4_t;
#define e1000_gscl4_default 0x0
static inline uint16_t e1000_gscl4_coml_th_extract(e1000_gscl4_t _regval) __attribute__ ((always_inline));
static inline uint16_t e1000_gscl4_coml_th_extract(e1000_gscl4_t _regval)
{
    return((uint16_t )((_regval & 0x3ff) >> 0));
}

static inline e1000_gscl4_t e1000_gscl4_coml_th_insert(e1000_gscl4_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl4_t e1000_gscl4_coml_th_insert(e1000_gscl4_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc00) | (0x3ff & (((e1000_gscl4_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_gscl4_rb_th_extract(e1000_gscl4_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl4_rb_th_extract(e1000_gscl4_t _regval)
{
    return((uint8_t )((_regval & 0xfc00) >> 10));
}

static inline e1000_gscl4_t e1000_gscl4_rb_th_insert(e1000_gscl4_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_gscl4_t e1000_gscl4_rb_th_insert(e1000_gscl4_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff03ff) | (0xfc00 & (((e1000_gscl4_t )(_fieldval)) << 10)));
}

static inline int e1000_gscl4_prtval(char *_s, size_t _size, e1000_gscl4_t _regval) __attribute__ ((always_inline));
static inline int e1000_gscl4_prtval(char *_s, size_t _size, e1000_gscl4_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " coml_th =\t%" PRIx16 "\t(Completions latency threshold)\n", e1000_gscl4_coml_th_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rb_th =\t%" PRIx8 "\t(Retry buffer threshold)\n", e1000_gscl4_rb_th_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_factps_t
 * Description: Implicit type of Fn. active & power state to MNG register
 * Fields:
 *   f0ps	(size 2, offset 0, init 0):	RO	Power state of fn. 0
 *   lan0v	(size 1, offset 2, init 0):	RO	LAN 0 valid enable
 *   f0aux	(size 1, offset 3, init 0):	RO	Fn. 0 aux power enable shadow
 *   lan0en	(size 1, offset 4, init 0):	RO	LAN 0 enabled
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   f1ps	(size 2, offset 6, init 0):	RO	Power state of fn. 1
 *   lan1v	(size 1, offset 8, init 0):	RO	LAN 1 valid enable
 *   f1aux	(size 1, offset 9, init 0):	RO	Fn. 1 aux power enable shadow
 *   lan1en	(size 1, offset 10, init 0):	RO	LAN 1 enabled
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   f2ps	(size 2, offset 12, init 0):	RO	Power state of fn. 2
 *   ide_en	(size 1, offset 14, init 0):	RO	IDE (function 2) enable
 *   f2aux	(size 1, offset 15, init 0):	RO	Fn. 2 aux power enable shadow
 *   _anon16	(size 2, offset 16, init 0):	RSVD	_
 *   f3ps	(size 2, offset 18, init 0):	RO	Power state of fn. 3
 *   sp_en	(size 1, offset 20, init 0):	RO	SP (function 3) enable
 *   f3aux	(size 1, offset 21, init 0):	RO	Fn. 3 aux power enable shadow
 *   _anon22	(size 2, offset 22, init 0):	RSVD	_
 *   f4ps	(size 2, offset 24, init 0):	RO	Power state of fn. 4
 *   ipmi_en	(size 1, offset 26, init 0):	RO	IPMI (function 4) enable
 *   f4aux	(size 1, offset 27, init 0):	RO	Fn. 4 aux power enable shadow
 *   _anon28	(size 1, offset 28, init 0):	RSVD	_
 *   mngcg	(size 1, offset 29, init 0):	RO	MNG clock gated
 *   lanfs	(size 1, offset 30, init 0):	RO	LAN function select
 *   pmchg	(size 1, offset 31, init 0):	RO	PM state changed
 */
typedef uint32_t e1000_factps_t;
#define e1000_factps_default 0x0
static inline e1000_fps_t e1000_factps_f0ps_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f0ps_extract(e1000_factps_t _regval)
{
    return((e1000_fps_t )((_regval & 0x3) >> 0));
}

static inline e1000_factps_t e1000_factps_f0ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f0ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e1000_factps_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_factps_lan0v_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan0v_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_factps_t e1000_factps_lan0v_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_lan0v_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_factps_t )(_fieldval)) << 2)));
}

static inline uint8_t e1000_factps_f0aux_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f0aux_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e1000_factps_t e1000_factps_f0aux_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f0aux_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e1000_factps_t )(_fieldval)) << 3)));
}

static inline uint8_t e1000_factps_lan0en_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan0en_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_factps_t e1000_factps_lan0en_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_lan0en_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_factps_t )(_fieldval)) << 4)));
}

static inline e1000_fps_t e1000_factps_f1ps_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f1ps_extract(e1000_factps_t _regval)
{
    return((e1000_fps_t )((_regval & 0xc0) >> 6));
}

static inline e1000_factps_t e1000_factps_f1ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f1ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((e1000_factps_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_factps_lan1v_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan1v_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e1000_factps_t e1000_factps_lan1v_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_lan1v_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e1000_factps_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_factps_f1aux_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f1aux_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e1000_factps_t e1000_factps_f1aux_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f1aux_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e1000_factps_t )(_fieldval)) << 9)));
}

static inline uint8_t e1000_factps_lan1en_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan1en_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e1000_factps_t e1000_factps_lan1en_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_lan1en_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e1000_factps_t )(_fieldval)) << 10)));
}

static inline e1000_fps_t e1000_factps_f2ps_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f2ps_extract(e1000_factps_t _regval)
{
    return((e1000_fps_t )((_regval & 0x3000) >> 12));
}

static inline e1000_factps_t e1000_factps_f2ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f2ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((e1000_factps_t )(_fieldval)) << 12)));
}

static inline uint8_t e1000_factps_ide_en_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_ide_en_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e1000_factps_t e1000_factps_ide_en_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_ide_en_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e1000_factps_t )(_fieldval)) << 14)));
}

static inline uint8_t e1000_factps_f2aux_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f2aux_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_factps_t e1000_factps_f2aux_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f2aux_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_factps_t )(_fieldval)) << 15)));
}

static inline e1000_fps_t e1000_factps_f3ps_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f3ps_extract(e1000_factps_t _regval)
{
    return((e1000_fps_t )((_regval & 0xc0000) >> 18));
}

static inline e1000_factps_t e1000_factps_f3ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f3ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((e1000_factps_t )(_fieldval)) << 18)));
}

static inline uint8_t e1000_factps_sp_en_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_sp_en_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e1000_factps_t e1000_factps_sp_en_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_sp_en_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e1000_factps_t )(_fieldval)) << 20)));
}

static inline uint8_t e1000_factps_f3aux_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f3aux_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e1000_factps_t e1000_factps_f3aux_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f3aux_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e1000_factps_t )(_fieldval)) << 21)));
}

static inline e1000_fps_t e1000_factps_f4ps_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f4ps_extract(e1000_factps_t _regval)
{
    return((e1000_fps_t )((_regval & 0x3000000) >> 24));
}

static inline e1000_factps_t e1000_factps_f4ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f4ps_insert(e1000_factps_t _regval, e1000_fps_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((e1000_factps_t )(_fieldval)) << 24)));
}

static inline uint8_t e1000_factps_ipmi_en_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_ipmi_en_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e1000_factps_t e1000_factps_ipmi_en_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_ipmi_en_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e1000_factps_t )(_fieldval)) << 26)));
}

static inline uint8_t e1000_factps_f4aux_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f4aux_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e1000_factps_t e1000_factps_f4aux_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_f4aux_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e1000_factps_t )(_fieldval)) << 27)));
}

static inline uint8_t e1000_factps_mngcg_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_mngcg_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e1000_factps_t e1000_factps_mngcg_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_mngcg_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e1000_factps_t )(_fieldval)) << 29)));
}

static inline uint8_t e1000_factps_lanfs_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lanfs_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_factps_t e1000_factps_lanfs_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_lanfs_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_factps_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_factps_pmchg_extract(e1000_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_pmchg_extract(e1000_factps_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_factps_t e1000_factps_pmchg_insert(e1000_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_pmchg_insert(e1000_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_factps_t )(_fieldval)) << 31)));
}

static inline int e1000_factps_prtval(char *_s, size_t _size, e1000_factps_t _regval) __attribute__ ((always_inline));
static inline int e1000_factps_prtval(char *_s, size_t _size, e1000_factps_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f0ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan0v =\t%" PRIx8 "\t(LAN 0 valid enable)\n", e1000_factps_lan0v_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0aux =\t%" PRIx8 "\t(Fn. 0 aux power enable shadow)\n", e1000_factps_f0aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan0en =\t%" PRIx8 "\t(LAN 0 enabled)\n", e1000_factps_lan0en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f1ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan1v =\t%" PRIx8 "\t(LAN 1 valid enable)\n", e1000_factps_lan1v_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1aux =\t%" PRIx8 "\t(Fn. 1 aux power enable shadow)\n", e1000_factps_f1aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan1en =\t%" PRIx8 "\t(LAN 1 enabled)\n", e1000_factps_lan1en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f2ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f2ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ide_en =\t%" PRIx8 "\t(IDE (function 2) enable)\n", e1000_factps_ide_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f2aux =\t%" PRIx8 "\t(Fn. 2 aux power enable shadow)\n", e1000_factps_f2aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f3ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f3ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sp_en =\t%" PRIx8 "\t(SP (function 3) enable)\n", e1000_factps_sp_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f3aux =\t%" PRIx8 "\t(Fn. 3 aux power enable shadow)\n", e1000_factps_f3aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f4ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f4ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipmi_en =\t%" PRIx8 "\t(IPMI (function 4) enable)\n", e1000_factps_ipmi_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f4aux =\t%" PRIx8 "\t(Fn. 4 aux power enable shadow)\n", e1000_factps_f4aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mngcg =\t%" PRIx8 "\t(MNG clock gated)\n", e1000_factps_mngcg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lanfs =\t%" PRIx8 "\t(LAN function select)\n", e1000_factps_lanfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmchg =\t%" PRIx8 "\t(PM state changed)\n", e1000_factps_pmchg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_anal_ctl_t
 * Description: Analog circuit configuration
 * Fields:
 *   data	(size 8, offset 0, init 0):	NOATTR	Data to SerDes
 *   address	(size 8, offset 8, init 0):	NOATTR	Address to SerDes
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	NOATTR	Done indicator
 */
typedef uint32_t e1000_anal_ctl_t;
#define e1000_anal_ctl_default 0x0
static inline uint8_t e1000_anal_ctl_data_extract(e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_anal_ctl_data_extract(e1000_anal_ctl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e1000_anal_ctl_t e1000_anal_ctl_data_insert(e1000_anal_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_anal_ctl_data_insert(e1000_anal_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e1000_anal_ctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_anal_ctl_address_extract(e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_anal_ctl_address_extract(e1000_anal_ctl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_anal_ctl_t e1000_anal_ctl_address_insert(e1000_anal_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_anal_ctl_address_insert(e1000_anal_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_anal_ctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_anal_ctl_done_extract(e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_anal_ctl_done_extract(e1000_anal_ctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_anal_ctl_t e1000_anal_ctl_done_insert(e1000_anal_ctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_anal_ctl_done_insert(e1000_anal_ctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_anal_ctl_t )(_fieldval)) << 31)));
}

static inline int e1000_anal_ctl_prtval(char *_s, size_t _size, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline int e1000_anal_ctl_prtval(char *_s, size_t _size, e1000_anal_ctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to SerDes)\n", e1000_anal_ctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to SerDes)\n", e1000_anal_ctl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done indicator)\n", e1000_anal_ctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_anactl_t
 * Description: Implicit type of Analog control register
 * Fields:
 *   data	(size 8, offset 0, init 0):	RW	Data to/from analog register
 *   address	(size 8, offset 8, init 0):	RW	Address of analog register
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   write	(size 1, offset 30, init 0):	RW	Read/write command
 *   done	(size 1, offset 31, init 0):	RW	Done indication
 */
typedef uint32_t e1000_anactl_t;
#define e1000_anactl_default 0x0
static inline uint8_t e1000_anactl_data_extract(e1000_anactl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_data_extract(e1000_anactl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e1000_anactl_t e1000_anactl_data_insert(e1000_anactl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_anactl_t e1000_anactl_data_insert(e1000_anactl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e1000_anactl_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_anactl_address_extract(e1000_anactl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_address_extract(e1000_anactl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e1000_anactl_t e1000_anactl_address_insert(e1000_anactl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_anactl_t e1000_anactl_address_insert(e1000_anactl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e1000_anactl_t )(_fieldval)) << 8)));
}

static inline uint8_t e1000_anactl_write_extract(e1000_anactl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_write_extract(e1000_anactl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e1000_anactl_t e1000_anactl_write_insert(e1000_anactl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_anactl_t e1000_anactl_write_insert(e1000_anactl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e1000_anactl_t )(_fieldval)) << 30)));
}

static inline uint8_t e1000_anactl_done_extract(e1000_anactl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_done_extract(e1000_anactl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e1000_anactl_t e1000_anactl_done_insert(e1000_anactl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_anactl_t e1000_anactl_done_insert(e1000_anactl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e1000_anactl_t )(_fieldval)) << 31)));
}

static inline int e1000_anactl_prtval(char *_s, size_t _size, e1000_anactl_t _regval) __attribute__ ((always_inline));
static inline int e1000_anactl_prtval(char *_s, size_t _size, e1000_anactl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to/from analog register)\n", e1000_anactl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address of analog register)\n", e1000_anactl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " write =\t%" PRIx8 "\t(Read/write command)\n", e1000_anactl_write_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done indication)\n", e1000_anactl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_swsm_t
 * Description: Implicit type of Software semaphore register
 * Fields:
 *   smbi	(size 1, offset 0, init 0):	RW	Semaphore bit
 *   swesmbi	(size 1, offset 1, init 0):	RW	Software EEPROM semaphore bit
 *   wmng	(size 1, offset 2, init 0):	RW	Wake MNG clock
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e1000_swsm_t;
#define e1000_swsm_default 0x0
static inline uint8_t e1000_swsm_smbi_extract(e1000_swsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_swsm_smbi_extract(e1000_swsm_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_swsm_t e1000_swsm_smbi_insert(e1000_swsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_swsm_t e1000_swsm_smbi_insert(e1000_swsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_swsm_t )(_fieldval)) << 0)));
}

static inline uint8_t e1000_swsm_swesmbi_extract(e1000_swsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_swsm_swesmbi_extract(e1000_swsm_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e1000_swsm_t e1000_swsm_swesmbi_insert(e1000_swsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_swsm_t e1000_swsm_swesmbi_insert(e1000_swsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e1000_swsm_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_swsm_wmng_extract(e1000_swsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_swsm_wmng_extract(e1000_swsm_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e1000_swsm_t e1000_swsm_wmng_insert(e1000_swsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_swsm_t e1000_swsm_wmng_insert(e1000_swsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e1000_swsm_t )(_fieldval)) << 2)));
}

static inline int e1000_swsm_prtval(char *_s, size_t _size, e1000_swsm_t _regval) __attribute__ ((always_inline));
static inline int e1000_swsm_prtval(char *_s, size_t _size, e1000_swsm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smbi =\t%" PRIx8 "\t(Semaphore bit)\n", e1000_swsm_smbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swesmbi =\t%" PRIx8 "\t(Software EEPROM semaphore bit)\n", e1000_swsm_swesmbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wmng =\t%" PRIx8 "\t(Wake MNG clock)\n", e1000_swsm_wmng_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e1000_fwsm_t
 * Description: Implicit type of Firmware semaphore register
 * Fields:
 *   eep_fw	(size 1, offset 0, init 0):	RW	EEPROM firmware semaphore
 *   fw_mode	(size 3, offset 1, init 0):	RW	Firmware mode
 *   ide_on	(size 1, offset 4, init 0):	RW	IDE redirection on
 *   sol_on	(size 1, offset 5, init 0):	RW	SOL on
 *   eep_rl	(size 1, offset 6, init 0):	RW	EEPROM reloaded indication
 *   _anon7	(size 8, offset 7, init 0):	RSVD	_
 *   fwval	(size 1, offset 15, init 0):	RW	Firmware valid bit
 *   rstcnt	(size 3, offset 16, init 0):	RW	Reset counter
 *   error	(size 6, offset 19, init 0):	RW	External error indication
 *   _anon25	(size 7, offset 25, init 0):	RSVD	_
 */
typedef uint32_t e1000_fwsm_t;
#define e1000_fwsm_default 0x0
static inline uint8_t e1000_fwsm_eep_fw_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_eep_fw_extract(e1000_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e1000_fwsm_t e1000_fwsm_eep_fw_insert(e1000_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_eep_fw_insert(e1000_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e1000_fwsm_t )(_fieldval)) << 0)));
}

static inline e1000_fwmode_t e1000_fwsm_fw_mode_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline e1000_fwmode_t e1000_fwsm_fw_mode_extract(e1000_fwsm_t _regval)
{
    return((e1000_fwmode_t )((_regval & 0xe) >> 1));
}

static inline e1000_fwsm_t e1000_fwsm_fw_mode_insert(e1000_fwsm_t _regval, e1000_fwmode_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_fw_mode_insert(e1000_fwsm_t _regval, e1000_fwmode_t _fieldval)
{
    return((_regval & 0xfffffff1) | (0xe & (((e1000_fwsm_t )(_fieldval)) << 1)));
}

static inline uint8_t e1000_fwsm_ide_on_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_ide_on_extract(e1000_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e1000_fwsm_t e1000_fwsm_ide_on_insert(e1000_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_ide_on_insert(e1000_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e1000_fwsm_t )(_fieldval)) << 4)));
}

static inline uint8_t e1000_fwsm_sol_on_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_sol_on_extract(e1000_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e1000_fwsm_t e1000_fwsm_sol_on_insert(e1000_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_sol_on_insert(e1000_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e1000_fwsm_t )(_fieldval)) << 5)));
}

static inline uint8_t e1000_fwsm_eep_rl_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_eep_rl_extract(e1000_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e1000_fwsm_t e1000_fwsm_eep_rl_insert(e1000_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_eep_rl_insert(e1000_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e1000_fwsm_t )(_fieldval)) << 6)));
}

static inline uint8_t e1000_fwsm_fwval_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_fwval_extract(e1000_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e1000_fwsm_t e1000_fwsm_fwval_insert(e1000_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_fwval_insert(e1000_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e1000_fwsm_t )(_fieldval)) << 15)));
}

static inline uint8_t e1000_fwsm_rstcnt_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_rstcnt_extract(e1000_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x70000) >> 16));
}

static inline e1000_fwsm_t e1000_fwsm_rstcnt_insert(e1000_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_rstcnt_insert(e1000_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((e1000_fwsm_t )(_fieldval)) << 16)));
}

static inline e1000_pcierr_t e1000_fwsm_error_extract(e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline e1000_pcierr_t e1000_fwsm_error_extract(e1000_fwsm_t _regval)
{
    return((e1000_pcierr_t )((_regval & 0x1f80000) >> 19));
}

static inline e1000_fwsm_t e1000_fwsm_error_insert(e1000_fwsm_t _regval, e1000_pcierr_t _fieldval) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_error_insert(e1000_fwsm_t _regval, e1000_pcierr_t _fieldval)
{
    return((_regval & 0xfe07ffff) | (0x1f80000 & (((e1000_fwsm_t )(_fieldval)) << 19)));
}

static inline int e1000_fwsm_prtval(char *_s, size_t _size, e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline int e1000_fwsm_prtval(char *_s, size_t _size, e1000_fwsm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eep_fw =\t%" PRIx8 "\t(EEPROM firmware semaphore)\n", e1000_fwsm_eep_fw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fwmode_prtval(_s + _r, _avail, e1000_fwsm_fw_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Firmware mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ide_on =\t%" PRIx8 "\t(IDE redirection on)\n", e1000_fwsm_ide_on_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sol_on =\t%" PRIx8 "\t(SOL on)\n", e1000_fwsm_sol_on_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eep_rl =\t%" PRIx8 "\t(EEPROM reloaded indication)\n", e1000_fwsm_eep_rl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwval =\t%" PRIx8 "\t(Firmware valid bit)\n", e1000_fwsm_fwval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rstcnt =\t%" PRIx8 "\t(Reset counter)\n", e1000_fwsm_rstcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " error =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_pcierr_prtval(_s + _r, _avail, e1000_fwsm_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(External error indication)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: e1000_legacy_rdesc_t
 * Description: Legacy rx descriptor
 * Fields:
 *   addr	(size 64, offset 0, init 0):	RW	Buffer address
 *   length	(size 16, offset 64, init 0):	RW	Packet length
 *   checksum	(size 16, offset 80, init 0):	RW	Packet checksum
 *   dd	(size 1, offset 96, init 0):	RW	Descriptor done
 *   eop	(size 1, offset 97, init 0):	RW	End of packet
 *   ixsm	(size 1, offset 98, init 0):	RW	Ignore checksum indication
 *   vp	(size 1, offset 99, init 0):	RW	Packet is 802.1q (matched VET)
 *   udpcs	(size 1, offset 100, init 0):	RW	UDP checksum calculated on packet
 *   tcpcs	(size 1, offset 101, init 0):	RW	TCP checksum calculated on packet
 *   ipcs	(size 1, offset 102, init 0):	RW	IPv4 checksum calculated on packet
 *   pif	(size 1, offset 103, init 0):	RW	Passed in-exact filter
 *   ce	(size 1, offset 104, init 0):	RW	CRC or alignment error
 *   se	(size 1, offset 105, init 0):	RW	Symbol error
 *   seq	(size 1, offset 106, init 0):	RW	Sequence error
 *   _anon107	(size 2, offset 107, init 0):	RSVD	_
 *   tcpe	(size 1, offset 109, init 0):	RW	TCP/UDP checksum error
 *   ipe	(size 1, offset 110, init 0):	RW	IPv4 checksum error
 *   rxe	(size 1, offset 111, init 0):	RW	RX data error
 *   vlan	(size 12, offset 112, init 0):	RW	VLAN id
 *   cr	(size 1, offset 124, init 0):	RW	Canonical form indicator
 *   pri	(size 3, offset 125, init 0):	RW	802.1p priority
 */
typedef uint8_t *e1000_legacy_rdesc_t;
typedef uint8_t e1000_legacy_rdesc_array_t[16];
static const size_t e1000_legacy_rdesc_size = sizeof(e1000_legacy_rdesc_array_t );
static inline uint64_t e1000_legacy_rdesc_addr_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t e1000_legacy_rdesc_addr_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint64_t *)(0 + _dtptr))) & 0xffffffffffffffff) >> 0);
}

static inline void e1000_legacy_rdesc_addr_insert(e1000_legacy_rdesc_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_addr_insert(e1000_legacy_rdesc_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(0 + _dtptr)) = (((*((uint64_t *)(0 + _dtptr))) & 0x0) | (0xffffffffffffffff & (_fieldval << 0)));
}

static inline uint16_t e1000_legacy_rdesc_length_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t e1000_legacy_rdesc_length_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint16_t *)(8 + _dtptr))) & 0xffff) >> 0);
}

static inline void e1000_legacy_rdesc_length_insert(e1000_legacy_rdesc_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_length_insert(e1000_legacy_rdesc_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(8 + _dtptr)) = (((*((uint16_t *)(8 + _dtptr))) & 0x0) | (0xffff & (_fieldval << 0)));
}

static inline uint16_t e1000_legacy_rdesc_checksum_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t e1000_legacy_rdesc_checksum_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint16_t *)(10 + _dtptr))) & 0xffff) >> 0);
}

static inline void e1000_legacy_rdesc_checksum_insert(e1000_legacy_rdesc_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_checksum_insert(e1000_legacy_rdesc_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(10 + _dtptr)) = (((*((uint16_t *)(10 + _dtptr))) & 0x0) | (0xffff & (_fieldval << 0)));
}

static inline uint8_t e1000_legacy_rdesc_dd_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_dd_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x1) >> 0);
}

static inline void e1000_legacy_rdesc_dd_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_dd_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t e1000_legacy_rdesc_eop_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_eop_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x2) >> 1);
}

static inline void e1000_legacy_rdesc_eop_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_eop_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t e1000_legacy_rdesc_ixsm_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_ixsm_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x4) >> 2);
}

static inline void e1000_legacy_rdesc_ixsm_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_ixsm_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t e1000_legacy_rdesc_vp_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_vp_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x8) >> 3);
}

static inline void e1000_legacy_rdesc_vp_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_vp_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t e1000_legacy_rdesc_udpcs_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_udpcs_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x10) >> 4);
}

static inline void e1000_legacy_rdesc_udpcs_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_udpcs_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t e1000_legacy_rdesc_tcpcs_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_tcpcs_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x20) >> 5);
}

static inline void e1000_legacy_rdesc_tcpcs_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_tcpcs_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t e1000_legacy_rdesc_ipcs_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_ipcs_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x40) >> 6);
}

static inline void e1000_legacy_rdesc_ipcs_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_ipcs_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t e1000_legacy_rdesc_pif_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_pif_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(12 + _dtptr))) & 0x80) >> 7);
}

static inline void e1000_legacy_rdesc_pif_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_pif_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(12 + _dtptr)) = (((*((uint8_t *)(12 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t e1000_legacy_rdesc_ce_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_ce_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(13 + _dtptr))) & 0x1) >> 0);
}

static inline void e1000_legacy_rdesc_ce_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_ce_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(13 + _dtptr)) = (((*((uint8_t *)(13 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t e1000_legacy_rdesc_se_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_se_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(13 + _dtptr))) & 0x2) >> 1);
}

static inline void e1000_legacy_rdesc_se_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_se_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(13 + _dtptr)) = (((*((uint8_t *)(13 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t e1000_legacy_rdesc_seq_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_seq_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(13 + _dtptr))) & 0x4) >> 2);
}

static inline void e1000_legacy_rdesc_seq_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_seq_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(13 + _dtptr)) = (((*((uint8_t *)(13 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t e1000_legacy_rdesc_tcpe_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_tcpe_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(13 + _dtptr))) & 0x20) >> 5);
}

static inline void e1000_legacy_rdesc_tcpe_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_tcpe_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(13 + _dtptr)) = (((*((uint8_t *)(13 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t e1000_legacy_rdesc_ipe_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_ipe_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(13 + _dtptr))) & 0x40) >> 6);
}

static inline void e1000_legacy_rdesc_ipe_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_ipe_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(13 + _dtptr)) = (((*((uint8_t *)(13 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t e1000_legacy_rdesc_rxe_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_rxe_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(13 + _dtptr))) & 0x80) >> 7);
}

static inline void e1000_legacy_rdesc_rxe_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_rxe_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(13 + _dtptr)) = (((*((uint8_t *)(13 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t e1000_legacy_rdesc_vlan_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t e1000_legacy_rdesc_vlan_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint16_t *)(14 + _dtptr))) & 0xfff) >> 0);
}

static inline void e1000_legacy_rdesc_vlan_insert(e1000_legacy_rdesc_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_vlan_insert(e1000_legacy_rdesc_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(14 + _dtptr)) = (((*((uint16_t *)(14 + _dtptr))) & 0xf000) | (0xfff & (_fieldval << 0)));
}

static inline uint8_t e1000_legacy_rdesc_cr_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_cr_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x10) >> 4);
}

static inline void e1000_legacy_rdesc_cr_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_cr_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t e1000_legacy_rdesc_pri_extract(e1000_legacy_rdesc_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_legacy_rdesc_pri_extract(e1000_legacy_rdesc_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xe0) >> 5);
}

static inline void e1000_legacy_rdesc_pri_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_legacy_rdesc_pri_insert(e1000_legacy_rdesc_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0x1f) | (0xe0 & (_fieldval << 5)));
}

static inline int e1000_legacy_rdesc_prtval(char *_s, size_t _size, e1000_legacy_rdesc_t _regval) __attribute__ ((always_inline));
static inline int e1000_legacy_rdesc_prtval(char *_s, size_t _size, e1000_legacy_rdesc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx64 "\t(Buffer address)\n", e1000_legacy_rdesc_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " length =\t%" PRIx16 "\t(Packet length)\n", e1000_legacy_rdesc_length_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " checksum =\t%" PRIx16 "\t(Packet checksum)\n", e1000_legacy_rdesc_checksum_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dd =\t%" PRIx8 "\t(Descriptor done)\n", e1000_legacy_rdesc_dd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eop =\t%" PRIx8 "\t(End of packet)\n", e1000_legacy_rdesc_eop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ixsm =\t%" PRIx8 "\t(Ignore checksum indication)\n", e1000_legacy_rdesc_ixsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vp =\t%" PRIx8 "\t(Packet is 802.1q (matched VET))\n", e1000_legacy_rdesc_vp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " udpcs =\t%" PRIx8 "\t(UDP checksum calculated on packet)\n", e1000_legacy_rdesc_udpcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpcs =\t%" PRIx8 "\t(TCP checksum calculated on packet)\n", e1000_legacy_rdesc_tcpcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipcs =\t%" PRIx8 "\t(IPv4 checksum calculated on packet)\n", e1000_legacy_rdesc_ipcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pif =\t%" PRIx8 "\t(Passed in-exact filter)\n", e1000_legacy_rdesc_pif_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce =\t%" PRIx8 "\t(CRC or alignment error)\n", e1000_legacy_rdesc_ce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " se =\t%" PRIx8 "\t(Symbol error)\n", e1000_legacy_rdesc_se_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " seq =\t%" PRIx8 "\t(Sequence error)\n", e1000_legacy_rdesc_seq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpe =\t%" PRIx8 "\t(TCP/UDP checksum error)\n", e1000_legacy_rdesc_tcpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipe =\t%" PRIx8 "\t(IPv4 checksum error)\n", e1000_legacy_rdesc_ipe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxe =\t%" PRIx8 "\t(RX data error)\n", e1000_legacy_rdesc_rxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan =\t%" PRIx16 "\t(VLAN id)\n", e1000_legacy_rdesc_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cr =\t%" PRIx8 "\t(Canonical form indicator)\n", e1000_legacy_rdesc_cr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pri =\t%" PRIx8 "\t(802.1p priority)\n", e1000_legacy_rdesc_pri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: e1000_rdesc_read_t
 * Description: Extended rx descriptor (read format)
 * Fields:
 *   addr	(size 64, offset 0, init 0):	RW	Buffer address
 *   dd	(size 1, offset 64, init 0):	RW	Descriptor done
 *   _anon65	(size 63, offset 65, init 0):	RSVD	_
 */
typedef uint8_t *e1000_rdesc_read_t;
typedef uint8_t e1000_rdesc_read_array_t[16];
static const size_t e1000_rdesc_read_size = sizeof(e1000_rdesc_read_array_t );
static inline uint64_t e1000_rdesc_read_addr_extract(e1000_rdesc_read_t _dtptr) __attribute__ ((always_inline));
static inline uint64_t e1000_rdesc_read_addr_extract(e1000_rdesc_read_t _dtptr)
{
    return(((*((uint64_t *)(0 + _dtptr))) & 0xffffffffffffffff) >> 0);
}

static inline void e1000_rdesc_read_addr_insert(e1000_rdesc_read_t _dtptr, uint64_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_read_addr_insert(e1000_rdesc_read_t _dtptr, uint64_t _fieldval)
{
    *((uint64_t *)(0 + _dtptr)) = (((*((uint64_t *)(0 + _dtptr))) & 0x0) | (0xffffffffffffffff & (_fieldval << 0)));
}

static inline uint8_t e1000_rdesc_read_dd_extract(e1000_rdesc_read_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_read_dd_extract(e1000_rdesc_read_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x1) >> 0);
}

static inline void e1000_rdesc_read_dd_insert(e1000_rdesc_read_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_read_dd_insert(e1000_rdesc_read_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline int e1000_rdesc_read_prtval(char *_s, size_t _size, e1000_rdesc_read_t _regval) __attribute__ ((always_inline));
static inline int e1000_rdesc_read_prtval(char *_s, size_t _size, e1000_rdesc_read_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx64 "\t(Buffer address)\n", e1000_rdesc_read_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dd =\t%" PRIx8 "\t(Descriptor done)\n", e1000_rdesc_read_dd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Data type: e1000_rdesc_write_t
 * Description: Extended rx descriptor (write format)
 * Fields:
 *   rss	(size 4, offset 0, init 0):	RW	RSS type
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   queue	(size 5, offset 8, init 0):	RW	Receive queue
 *   _anon13	(size 19, offset 13, init 0):	RSVD	_
 *   ipid	(size 16, offset 32, init 0):	RW	IP header identification field
 *   checksum	(size 16, offset 48, init 0):	RW	Packet checksum
 *   dd	(size 1, offset 64, init 0):	RW	Descriptor done
 *   eop	(size 1, offset 65, init 0):	RW	End of packet
 *   ixsm	(size 1, offset 66, init 0):	RW	Ignore checksum indication
 *   vp	(size 1, offset 67, init 0):	RW	Packet is 802.1q (matched VET)
 *   udpcs	(size 1, offset 68, init 0):	RW	UDP checksum calculated on packet
 *   tcpcs	(size 1, offset 69, init 0):	RW	TCP checksum calculated on packet
 *   ipcs	(size 1, offset 70, init 0):	RW	IPv4 checksum calculated on packet
 *   pif	(size 1, offset 71, init 0):	RW	Passed in-exact filter
 *   _anon72	(size 1, offset 72, init 0):	RSVD	_
 *   ipidv	(size 1, offset 73, init 0):	RW	IP identification valid
 *   udpv	(size 1, offset 74, init 0):	RW	Valid UDP checksum
 *   _anon75	(size 4, offset 75, init 0):	RSVD	_
 *   ack	(size 1, offset 79, init 0):	RW	ACK packet identification
 *   _anon80	(size 4, offset 80, init 0):	RSVD	_
 *   _anon84	(size 4, offset 84, init 0):	RSVD	_
 *   ce	(size 1, offset 88, init 0):	RW	CRC or alignment error
 *   se	(size 1, offset 89, init 0):	RW	Symbol error
 *   seq	(size 1, offset 90, init 0):	RW	Sequence error
 *   _anon91	(size 2, offset 91, init 0):	RSVD	_
 *   tcpe	(size 1, offset 93, init 0):	RW	TCP/UDP checksum error
 *   ipe	(size 1, offset 94, init 0):	RW	IPv4 checksum error
 *   rxe	(size 1, offset 95, init 0):	RW	RX data error
 *   length	(size 16, offset 96, init 0):	RW	Packet length
 *   vlan	(size 12, offset 112, init 0):	RW	VLAN id
 *   cr	(size 1, offset 124, init 0):	RW	Canonical form indicator
 *   pri	(size 3, offset 125, init 0):	RW	802.1p priority
 */
typedef uint8_t *e1000_rdesc_write_t;
typedef uint8_t e1000_rdesc_write_array_t[16];
static const size_t e1000_rdesc_write_size = sizeof(e1000_rdesc_write_array_t );
static inline e1000_rsstype_t e1000_rdesc_write_rss_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline e1000_rsstype_t e1000_rdesc_write_rss_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(0 + _dtptr))) & 0xf) >> 0);
}

static inline void e1000_rdesc_write_rss_insert(e1000_rdesc_write_t _dtptr, e1000_rsstype_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_rss_insert(e1000_rdesc_write_t _dtptr, e1000_rsstype_t _fieldval)
{
    *((uint8_t *)(0 + _dtptr)) = (((*((uint8_t *)(0 + _dtptr))) & 0xf0) | (0xf & (_fieldval << 0)));
}

static inline uint8_t e1000_rdesc_write_queue_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_queue_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(1 + _dtptr))) & 0x1f) >> 0);
}

static inline void e1000_rdesc_write_queue_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_queue_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(1 + _dtptr)) = (((*((uint8_t *)(1 + _dtptr))) & 0xe0) | (0x1f & (_fieldval << 0)));
}

static inline uint16_t e1000_rdesc_write_ipid_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t e1000_rdesc_write_ipid_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint16_t *)(4 + _dtptr))) & 0xffff) >> 0);
}

static inline void e1000_rdesc_write_ipid_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_ipid_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(4 + _dtptr)) = (((*((uint16_t *)(4 + _dtptr))) & 0x0) | (0xffff & (_fieldval << 0)));
}

static inline uint16_t e1000_rdesc_write_checksum_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t e1000_rdesc_write_checksum_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint16_t *)(6 + _dtptr))) & 0xffff) >> 0);
}

static inline void e1000_rdesc_write_checksum_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_checksum_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(6 + _dtptr)) = (((*((uint16_t *)(6 + _dtptr))) & 0x0) | (0xffff & (_fieldval << 0)));
}

static inline uint8_t e1000_rdesc_write_dd_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_dd_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x1) >> 0);
}

static inline void e1000_rdesc_write_dd_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_dd_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t e1000_rdesc_write_eop_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_eop_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x2) >> 1);
}

static inline void e1000_rdesc_write_eop_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_eop_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t e1000_rdesc_write_ixsm_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_ixsm_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x4) >> 2);
}

static inline void e1000_rdesc_write_ixsm_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_ixsm_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t e1000_rdesc_write_vp_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_vp_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x8) >> 3);
}

static inline void e1000_rdesc_write_vp_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_vp_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xf7) | (0x8 & (_fieldval << 3)));
}

static inline uint8_t e1000_rdesc_write_udpcs_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_udpcs_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x10) >> 4);
}

static inline void e1000_rdesc_write_udpcs_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_udpcs_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t e1000_rdesc_write_tcpcs_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_tcpcs_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x20) >> 5);
}

static inline void e1000_rdesc_write_tcpcs_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_tcpcs_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t e1000_rdesc_write_ipcs_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_ipcs_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x40) >> 6);
}

static inline void e1000_rdesc_write_ipcs_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_ipcs_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t e1000_rdesc_write_pif_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_pif_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(8 + _dtptr))) & 0x80) >> 7);
}

static inline void e1000_rdesc_write_pif_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_pif_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(8 + _dtptr)) = (((*((uint8_t *)(8 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t e1000_rdesc_write_ipidv_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_ipidv_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(9 + _dtptr))) & 0x2) >> 1);
}

static inline void e1000_rdesc_write_ipidv_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_ipidv_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(9 + _dtptr)) = (((*((uint8_t *)(9 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t e1000_rdesc_write_udpv_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_udpv_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(9 + _dtptr))) & 0x4) >> 2);
}

static inline void e1000_rdesc_write_udpv_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_udpv_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(9 + _dtptr)) = (((*((uint8_t *)(9 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t e1000_rdesc_write_ack_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_ack_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(9 + _dtptr))) & 0x80) >> 7);
}

static inline void e1000_rdesc_write_ack_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_ack_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(9 + _dtptr)) = (((*((uint8_t *)(9 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint8_t e1000_rdesc_write_ce_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_ce_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(11 + _dtptr))) & 0x1) >> 0);
}

static inline void e1000_rdesc_write_ce_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_ce_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(11 + _dtptr)) = (((*((uint8_t *)(11 + _dtptr))) & 0xfe) | (0x1 & (_fieldval << 0)));
}

static inline uint8_t e1000_rdesc_write_se_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_se_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(11 + _dtptr))) & 0x2) >> 1);
}

static inline void e1000_rdesc_write_se_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_se_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(11 + _dtptr)) = (((*((uint8_t *)(11 + _dtptr))) & 0xfd) | (0x2 & (_fieldval << 1)));
}

static inline uint8_t e1000_rdesc_write_seq_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_seq_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(11 + _dtptr))) & 0x4) >> 2);
}

static inline void e1000_rdesc_write_seq_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_seq_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(11 + _dtptr)) = (((*((uint8_t *)(11 + _dtptr))) & 0xfb) | (0x4 & (_fieldval << 2)));
}

static inline uint8_t e1000_rdesc_write_tcpe_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_tcpe_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(11 + _dtptr))) & 0x20) >> 5);
}

static inline void e1000_rdesc_write_tcpe_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_tcpe_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(11 + _dtptr)) = (((*((uint8_t *)(11 + _dtptr))) & 0xdf) | (0x20 & (_fieldval << 5)));
}

static inline uint8_t e1000_rdesc_write_ipe_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_ipe_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(11 + _dtptr))) & 0x40) >> 6);
}

static inline void e1000_rdesc_write_ipe_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_ipe_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(11 + _dtptr)) = (((*((uint8_t *)(11 + _dtptr))) & 0xbf) | (0x40 & (_fieldval << 6)));
}

static inline uint8_t e1000_rdesc_write_rxe_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_rxe_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(11 + _dtptr))) & 0x80) >> 7);
}

static inline void e1000_rdesc_write_rxe_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_rxe_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(11 + _dtptr)) = (((*((uint8_t *)(11 + _dtptr))) & 0x7f) | (0x80 & (_fieldval << 7)));
}

static inline uint16_t e1000_rdesc_write_length_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t e1000_rdesc_write_length_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint16_t *)(12 + _dtptr))) & 0xffff) >> 0);
}

static inline void e1000_rdesc_write_length_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_length_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(12 + _dtptr)) = (((*((uint16_t *)(12 + _dtptr))) & 0x0) | (0xffff & (_fieldval << 0)));
}

static inline uint16_t e1000_rdesc_write_vlan_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint16_t e1000_rdesc_write_vlan_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint16_t *)(14 + _dtptr))) & 0xfff) >> 0);
}

static inline void e1000_rdesc_write_vlan_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_vlan_insert(e1000_rdesc_write_t _dtptr, uint16_t _fieldval)
{
    *((uint16_t *)(14 + _dtptr)) = (((*((uint16_t *)(14 + _dtptr))) & 0xf000) | (0xfff & (_fieldval << 0)));
}

static inline uint8_t e1000_rdesc_write_cr_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_cr_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0x10) >> 4);
}

static inline void e1000_rdesc_write_cr_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_cr_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0xef) | (0x10 & (_fieldval << 4)));
}

static inline uint8_t e1000_rdesc_write_pri_extract(e1000_rdesc_write_t _dtptr) __attribute__ ((always_inline));
static inline uint8_t e1000_rdesc_write_pri_extract(e1000_rdesc_write_t _dtptr)
{
    return(((*((uint8_t *)(15 + _dtptr))) & 0xe0) >> 5);
}

static inline void e1000_rdesc_write_pri_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdesc_write_pri_insert(e1000_rdesc_write_t _dtptr, uint8_t _fieldval)
{
    *((uint8_t *)(15 + _dtptr)) = (((*((uint8_t *)(15 + _dtptr))) & 0x1f) | (0xe0 & (_fieldval << 5)));
}

static inline int e1000_rdesc_write_prtval(char *_s, size_t _size, e1000_rdesc_write_t _regval) __attribute__ ((always_inline));
static inline int e1000_rdesc_write_prtval(char *_s, size_t _size, e1000_rdesc_write_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rss =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rsstype_prtval(_s + _r, _avail, e1000_rdesc_write_rss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(RSS type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue =\t%" PRIx8 "\t(Receive queue)\n", e1000_rdesc_write_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipid =\t%" PRIx16 "\t(IP header identification field)\n", e1000_rdesc_write_ipid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " checksum =\t%" PRIx16 "\t(Packet checksum)\n", e1000_rdesc_write_checksum_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dd =\t%" PRIx8 "\t(Descriptor done)\n", e1000_rdesc_write_dd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eop =\t%" PRIx8 "\t(End of packet)\n", e1000_rdesc_write_eop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ixsm =\t%" PRIx8 "\t(Ignore checksum indication)\n", e1000_rdesc_write_ixsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vp =\t%" PRIx8 "\t(Packet is 802.1q (matched VET))\n", e1000_rdesc_write_vp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " udpcs =\t%" PRIx8 "\t(UDP checksum calculated on packet)\n", e1000_rdesc_write_udpcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpcs =\t%" PRIx8 "\t(TCP checksum calculated on packet)\n", e1000_rdesc_write_tcpcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipcs =\t%" PRIx8 "\t(IPv4 checksum calculated on packet)\n", e1000_rdesc_write_ipcs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pif =\t%" PRIx8 "\t(Passed in-exact filter)\n", e1000_rdesc_write_pif_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipidv =\t%" PRIx8 "\t(IP identification valid)\n", e1000_rdesc_write_ipidv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " udpv =\t%" PRIx8 "\t(Valid UDP checksum)\n", e1000_rdesc_write_udpv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(ACK packet identification)\n", e1000_rdesc_write_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ce =\t%" PRIx8 "\t(CRC or alignment error)\n", e1000_rdesc_write_ce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " se =\t%" PRIx8 "\t(Symbol error)\n", e1000_rdesc_write_se_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " seq =\t%" PRIx8 "\t(Sequence error)\n", e1000_rdesc_write_seq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpe =\t%" PRIx8 "\t(TCP/UDP checksum error)\n", e1000_rdesc_write_tcpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipe =\t%" PRIx8 "\t(IPv4 checksum error)\n", e1000_rdesc_write_ipe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxe =\t%" PRIx8 "\t(RX data error)\n", e1000_rdesc_write_rxe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " length =\t%" PRIx16 "\t(Packet length)\n", e1000_rdesc_write_length_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan =\t%" PRIx16 "\t(VLAN id)\n", e1000_rdesc_write_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cr =\t%" PRIx8 "\t(Canonical form indicator)\n", e1000_rdesc_write_cr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pri =\t%" PRIx8 "\t(802.1p priority)\n", e1000_rdesc_write_pri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    e1000_intreg_t ics_shadow;
    e1000_intreg_t imc_shadow;
    e1000_tidv_t tidv_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum e1000_initials {
    e1000_ctrl_initial = 0x0,
    e1000_ctrldup_initial = 0x0,
    e1000_status_initial = 0x0,
    e1000_eecd_initial = 0x0,
    e1000_eerd_nm_initial = 0x0,
    e1000_eerd_ms_initial = 0x0,
    e1000_ctrlext_initial = 0x0,
    e1000_fla_initial = 0x0,
    e1000_mdic_initial = 0x0,
    e1000_serdesctl_initial = 0x0,
    e1000_fcal_initial = 0x0,
    e1000_fcah_initial = 0x0,
    e1000_fct_initial = 0x0,
    e1000_kumctrlsta_initial = 0x0,
    e1000_vet_initial = 0x0,
    e1000_mdphya_initial = 0x0,
    e1000_ufuse3_initial = 0x0,
    e1000_fcttv_initial = 0x0,
    e1000_txcw_initial = 0x0,
    e1000_rxcw_initial = 0x0,
    e1000_ledctl_initial = 0x0,
    e1000_extcnf_ctrl_initial = 0x0,
    e1000_extcnf_size_initial = 0x0,
    e1000_pba_initial = 0x0,
    e1000_eemngctl_initial = 0x0,
    e1000_sw_fw_sync_initial = 0x0,
    e1000_icr_initial = 0x0,
    e1000_itr_initial = 0x0,
    e1000_ics_initial = 0x0,
    e1000_ims_initial = 0x0,
    e1000_imc_initial = 0x0,
    e1000_iam_initial = 0x0,
    e1000_eitr_initial = 0x0,
    e1000_rctl_initial = 0x0,
    e1000_ert_initial = 0x0,
    e1000_fcrtl_initial = 0x0,
    e1000_fcrth_initial = 0x0,
    e1000_psrctl_initial = 0x0,
    e1000_rdbal_initial = 0x0,
    e1000_rdbah_initial = 0x0,
    e1000_rdlen_initial = 0x0,
    e1000_rdh_initial = 0x0,
    e1000_rdt_initial = 0x0,
    e1000_rdtr_initial = 0x0,
    e1000_rxdctl_initial = 0x0,
    e1000_rxdctl_82575_initial = 0x0,
    e1000_radv_initial = 0x0,
    e1000_rsrpd_initial = 0x0,
    e1000_raid_initial = 0x0,
    e1000_cpuvec_initial = 0x0,
    e1000_rxcsum_initial = 0x0,
    e1000_rfctl_initial = 0x0,
    e1000_tctl_initial = 0x0,
    e1000_tctl_ext_initial = 0x0,
    e1000_tipg_initial = 0x0,
    e1000_tdbal_initial = 0x0,
    e1000_tdbah_initial = 0x0,
    e1000_tdlen_initial = 0x0,
    e1000_tdh_initial = 0x0,
    e1000_tdt_initial = 0x0,
    e1000_tidv_initial = 0x0,
    e1000_txdctl_initial = 0x0,
    e1000_txdctl_82575_initial = 0x0,
    e1000_tadv_initial = 0x0,
    e1000_tarc_initial = 0x0,
    e1000_mta_initial = 0x0,
    e1000_ral_initial = 0x0,
    e1000_rah_initial = 0x0,
    e1000_vfta_initial = 0x0,
    e1000_mrq_initial = 0x0,
    e1000_rssim_initial = 0x0,
    e1000_rssir_initial = 0x0,
    e1000_reta_initial = 0x0,
    e1000_rssrk_initial = 0x0,
    e1000_wuc_initial = 0x0,
    e1000_wufc_initial = 0x0,
    e1000_wus_initial = 0x0,
    e1000_ipav_initial = 0x0,
    e1000_ip4at_initial = 0x0,
    e1000_ip6at_initial = 0x0,
    e1000_wupl_initial = 0x0,
    e1000_wupm_initial = 0x0,
    e1000_fflt_initial = 0x0,
    e1000_ffltco_initial = 0x0,
    e1000_ffmt_initial = 0x0,
    e1000_ffvt_initial = 0x0,
    e1000_manc_initial = 0x0,
    e1000_gcr_initial = 0x0,
    e1000_gscl1_initial = 0x0,
    e1000_gscl2_initial = 0x0,
    e1000_gscl3_initial = 0x0,
    e1000_gscl4_initial = 0x0,
    e1000_gscn_initial = 0x0,
    e1000_factps_initial = 0x0,
    e1000_gioanactl_initial = 0x0,
    e1000_gioanactlall_initial = 0x0,
    e1000_ccmctl_initial = 0x0,
    e1000_anactl_initial = 0x0,
    e1000_scctl_initial = 0x0,
    e1000_swsm_initial = 0x0,
    e1000_fwsm_initial = 0x0,
    e1000_crcerrs_initial = 0x0,
    e1000_algnerrc_initial = 0x0,
    e1000_symerrs_initial = 0x0,
    e1000_rxerrc_initial = 0x0,
    e1000_mpc_initial = 0x0,
    e1000_scc_initial = 0x0,
    e1000_ecol_initial = 0x0,
    e1000_mcc_initial = 0x0,
    e1000_latecol_initial = 0x0,
    e1000_colc_initial = 0x0,
    e1000_dc_initial = 0x0,
    e1000_tncrs_initial = 0x0,
    e1000_sec_initial = 0x0,
    e1000_cexterr_initial = 0x0,
    e1000_rlec_initial = 0x0,
    e1000_xonrxc_initial = 0x0,
    e1000_xontxc_initial = 0x0,
    e1000_xoffrxc_initial = 0x0,
    e1000_xofftxc_initial = 0x0,
    e1000_fcurc_initial = 0x0,
    e1000_prc64_initial = 0x0,
    e1000_prc127_initial = 0x0,
    e1000_prc255_initial = 0x0,
    e1000_prc511_initial = 0x0,
    e1000_prc1023_initial = 0x0,
    e1000_prc1522_initial = 0x0,
    e1000_gprc_initial = 0x0,
    e1000_bprc_initial = 0x0,
    e1000_mcprc_initial = 0x0,
    e1000_gptc_initial = 0x0,
    e1000_gorcl_initial = 0x0,
    e1000_gorch_initial = 0x0,
    e1000_gotcl_initial = 0x0,
    e1000_gotch_initial = 0x0,
    e1000_rnbc_initial = 0x0,
    e1000_ruc_initial = 0x0,
    e1000_rfc_initial = 0x0,
    e1000_roc_initial = 0x0,
    e1000_rjc_initial = 0x0,
    e1000_mprc_initial = 0x0,
    e1000_mpdc_initial = 0x0,
    e1000_mptc_initial = 0x0,
    e1000_torl_initial = 0x0,
    e1000_torh_initial = 0x0,
    e1000_totl_initial = 0x0,
    e1000_toth_initial = 0x0,
    e1000_tpr_initial = 0x0,
    e1000_tpt_initial = 0x0,
    e1000_ptc64_initial = 0x0,
    e1000_ptc127_initial = 0x0,
    e1000_ptc255_initial = 0x0,
    e1000_ptc511_initial = 0x0,
    e1000_ptc1023_initial = 0x0,
    e1000_ptc1522_initial = 0x0,
    e1000_mcptc_initial = 0x0,
    e1000_bptc_initial = 0x0,
    e1000_tsctc_initial = 0x0,
    e1000_tsctfc_initial = 0x0,
    e1000_iac_initial = 0x0,
    e1000_icrxptc_initial = 0x0,
    e1000_icrxatc_initial = 0x0,
    e1000_ictxptc_initial = 0x0,
    e1000_ictxatc_initial = 0x0,
    e1000_ictxqec_initial = 0x0,
    e1000_ictxdltc_initial = 0x0,
    e1000_icrxdmtc_initial = 0x0,
    e1000_icrxoc_initial = 0x0,
    e1000_statsregs_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void e1000_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void e1000_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register ctrl: Device control
 * Type: e1000.ctrl (Implicit type of Device control register)
 *   fd	(size 1, offset 0, init 0):	RW	full-duplex
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   gio_md	(size 1, offset 2, init 0):	RW	GIO master disable
 *   lrst	(size 1, offset 3, init 0):	RW	Link reset
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   asde	(size 1, offset 5, init 0):	RW	Auto-Speed Detection Enable
 *   slu	(size 1, offset 6, init 0):	RW	Set link up
 *   ilos	(size 1, offset 7, init 0):	RW	Invert Loss-of-Signal (LOS)
 *   speed	(size 2, offset 8, init 0):	RW	Speed selection
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   frcspd	(size 1, offset 11, init 0):	RW	Force speed
 *   frcdplx	(size 1, offset 12, init 0):	RW	Force duplex
 *   _anon13	(size 5, offset 13, init 0):	MBZ	_
 *   sdp0_data	(size 1, offset 18, init 0):	RW	SDP0 data value, or dock/undock status
 *   sdp1_data	(size 1, offset 19, init 0):	RW	SDP1 data value
 *   advd3wuc	(size 1, offset 20, init 0):	RW	D3cold wakeup capability
 *   en_phy_pwr_mgmt	(size 1, offset 21, init 0):	RW	PHY Power-Management Enable
 *   sdp0_iodir	(size 1, offset 22, init 0):	RW	SDP0 pin I/O directionality
 *   sdp1_iodir	(size 1, offset 23, init 0):	RW	SDP1 pin I/O directionality
 *   _anon24	(size 2, offset 24, init 0):	MBZ	_
 *   rst	(size 1, offset 26, init 0):	RW	Device reset
 *   rfce	(size 1, offset 27, init 0):	RW	Receive flow control enable
 *   tfce	(size 1, offset 28, init 0):	RW	Transmit flow control enable
 *   _anon29	(size 1, offset 29, init 0):	MBZ	_
 *   vme	(size 1, offset 30, init 0):	RW	VLAN mode enable
 *   phy_rst	(size 1, offset 31, init 0):	RW	PHY reset
 */
static inline e1000_ctrl_t e1000_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline e1000_ctrl_t e1000_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ctrl_t e1000_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void e1000_ctrl_rawwr(__DN(t) *_dev, e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e1000_ctrl_rawwr(__DN(t) *_dev, e1000_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void e1000_ctrl_wr(__DN(t) *_dev, e1000_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e1000_ctrl_wr(__DN(t) *_dev, e1000_ctrl_t _regval)
{
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int e1000_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl (Device control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fd =\t%" PRIx8 "\t(full-duplex)\n", e1000_ctrl_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_md =\t%" PRIx8 "\t(GIO master disable)\n", e1000_ctrl_gio_md_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrst =\t%" PRIx8 "\t(Link reset)\n", e1000_ctrl_lrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asde =\t%" PRIx8 "\t(Auto-Speed Detection Enable)\n", e1000_ctrl_asde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slu =\t%" PRIx8 "\t(Set link up)\n", e1000_ctrl_slu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ilos =\t%" PRIx8 "\t(Invert Loss-of-Signal (LOS))\n", e1000_ctrl_ilos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_ctrl_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Speed selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcspd =\t%" PRIx8 "\t(Force speed)\n", e1000_ctrl_frcspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcdplx =\t%" PRIx8 "\t(Force duplex)\n", e1000_ctrl_frcdplx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_data =\t%" PRIx8 "\t(SDP0 data value, or dock/undock status)\n", e1000_ctrl_sdp0_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_data =\t%" PRIx8 "\t(SDP1 data value)\n", e1000_ctrl_sdp1_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " advd3wuc =\t%" PRIx8 "\t(D3cold wakeup capability)\n", e1000_ctrl_advd3wuc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_phy_pwr_mgmt =\t%" PRIx8 "\t(PHY Power-Management Enable)\n", e1000_ctrl_en_phy_pwr_mgmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_iodir =\t%" PRIx8 "\t(SDP0 pin I/O directionality)\n", e1000_ctrl_sdp0_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_iodir =\t%" PRIx8 "\t(SDP1 pin I/O directionality)\n", e1000_ctrl_sdp1_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e1000_ctrl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfce =\t%" PRIx8 "\t(Receive flow control enable)\n", e1000_ctrl_rfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfce =\t%" PRIx8 "\t(Transmit flow control enable)\n", e1000_ctrl_tfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN mode enable)\n", e1000_ctrl_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_rst =\t%" PRIx8 "\t(PHY reset)\n", e1000_ctrl_phy_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_ctrl_fd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_fd_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_fd_extract(_regval));
}

static inline uint8_t e1000_ctrl_gio_md_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_gio_md_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_gio_md_extract(_regval));
}

static inline uint8_t e1000_ctrl_lrst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_lrst_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_lrst_extract(_regval));
}

static inline uint8_t e1000_ctrl_asde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_asde_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_asde_extract(_regval));
}

static inline uint8_t e1000_ctrl_slu_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_slu_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_slu_extract(_regval));
}

static inline uint8_t e1000_ctrl_ilos_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_ilos_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_ilos_extract(_regval));
}

static inline e1000_linkspeed_t e1000_ctrl_speed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_ctrl_speed_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_speed_extract(_regval));
}

static inline uint8_t e1000_ctrl_frcspd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_frcspd_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_frcspd_extract(_regval));
}

static inline uint8_t e1000_ctrl_frcdplx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_frcdplx_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_frcdplx_extract(_regval));
}

static inline uint8_t e1000_ctrl_sdp0_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp0_data_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_sdp0_data_extract(_regval));
}

static inline uint8_t e1000_ctrl_sdp1_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp1_data_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_sdp1_data_extract(_regval));
}

static inline uint8_t e1000_ctrl_advd3wuc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_advd3wuc_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_advd3wuc_extract(_regval));
}

static inline uint8_t e1000_ctrl_en_phy_pwr_mgmt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_en_phy_pwr_mgmt_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_en_phy_pwr_mgmt_extract(_regval));
}

static inline uint8_t e1000_ctrl_sdp0_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp0_iodir_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_sdp0_iodir_extract(_regval));
}

static inline uint8_t e1000_ctrl_sdp1_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_sdp1_iodir_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_sdp1_iodir_extract(_regval));
}

static inline uint8_t e1000_ctrl_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_rst_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_rst_extract(_regval));
}

static inline uint8_t e1000_ctrl_rfce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_rfce_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_rfce_extract(_regval));
}

static inline uint8_t e1000_ctrl_tfce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_tfce_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_tfce_extract(_regval));
}

static inline uint8_t e1000_ctrl_vme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_vme_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_vme_extract(_regval));
}

static inline uint8_t e1000_ctrl_phy_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrl_phy_rst_rdf(__DN(t) *_dev)
{
    e1000_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e1000_ctrl_phy_rst_extract(_regval));
}

static inline void e1000_ctrl_fd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_fd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x1 & (((e1000_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xdcfc1bec & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_gio_md_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_gio_md_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x4 & (((e1000_ctrl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xdcfc1be9 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_lrst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_lrst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x8 & (((e1000_ctrl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xdcfc1be5 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_asde_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_asde_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x20 & (((e1000_ctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdcfc1bcd & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_slu_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_slu_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x40 & (((e1000_ctrl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xdcfc1bad & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_ilos_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_ilos_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x80 & (((e1000_ctrl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xdcfc1b6d & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_speed_wrf(__DN(t) *_dev, e1000_linkspeed_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_speed_wrf(__DN(t) *_dev, e1000_linkspeed_t _fieldval)
{
    e1000_ctrl_t _regval = 0x300 & (((e1000_ctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xdcfc18ed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_frcspd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_frcspd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x800 & (((e1000_ctrl_t )(_fieldval)) << 11);
    _regval = (_regval | (0xdcfc13ed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_frcdplx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_frcdplx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x1000 & (((e1000_ctrl_t )(_fieldval)) << 12);
    _regval = (_regval | (0xdcfc0bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_sdp0_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_sdp0_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x40000 & (((e1000_ctrl_t )(_fieldval)) << 18);
    _regval = (_regval | (0xdcf81bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_sdp1_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_sdp1_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x80000 & (((e1000_ctrl_t )(_fieldval)) << 19);
    _regval = (_regval | (0xdcf41bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_advd3wuc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_advd3wuc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x100000 & (((e1000_ctrl_t )(_fieldval)) << 20);
    _regval = (_regval | (0xdcec1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_en_phy_pwr_mgmt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_en_phy_pwr_mgmt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x200000 & (((e1000_ctrl_t )(_fieldval)) << 21);
    _regval = (_regval | (0xdcdc1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_sdp0_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_sdp0_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x400000 & (((e1000_ctrl_t )(_fieldval)) << 22);
    _regval = (_regval | (0xdcbc1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_sdp1_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_sdp1_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x800000 & (((e1000_ctrl_t )(_fieldval)) << 23);
    _regval = (_regval | (0xdc7c1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x4000000 & (((e1000_ctrl_t )(_fieldval)) << 26);
    _regval = (_regval | (0xd8fc1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_rfce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_rfce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x8000000 & (((e1000_ctrl_t )(_fieldval)) << 27);
    _regval = (_regval | (0xd4fc1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_tfce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_tfce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x10000000 & (((e1000_ctrl_t )(_fieldval)) << 28);
    _regval = (_regval | (0xccfc1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_vme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_vme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x40000000 & (((e1000_ctrl_t )(_fieldval)) << 30);
    _regval = (_regval | (0x9cfc1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrl_phy_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrl_phy_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrl_t _regval = 0x80000000 & (((e1000_ctrl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x5cfc1bed & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register ctrldup: Device Control Duplicate (Shadow)
 * Type: e1000.ctrldup (Implicit type of Device Control Duplicate (Shadow) register)
 *   fd	(size 1, offset 0, init 0):	RW	full-duplex
 *   _anon1	(size 1, offset 1, init 0):	MBZ	_
 *   gio_md	(size 1, offset 2, init 0):	RW	GIO master disable
 *   lrst	(size 1, offset 3, init 0):	RW	Link reset
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   asde	(size 1, offset 5, init 0):	RW	Auto-Speed Detection Enable
 *   slu	(size 1, offset 6, init 0):	RW	Set link up
 *   ilos	(size 1, offset 7, init 0):	RW	Invert Loss-of-Signal (LOS)
 *   speed	(size 2, offset 8, init 0):	RW	Speed selection
 *   _anon10	(size 1, offset 10, init 0):	MBZ	_
 *   frcspd	(size 1, offset 11, init 0):	RW	Force speed
 *   frcdplx	(size 1, offset 12, init 0):	RW	Force duplex
 *   _anon13	(size 5, offset 13, init 0):	MBZ	_
 *   sdp0_data	(size 1, offset 18, init 0):	RW	SDP0 data value, or dock/undock status
 *   sdp1_data	(size 1, offset 19, init 0):	RW	SDP1 data value
 *   advd3wuc	(size 1, offset 20, init 0):	RW	D3cold wakeup capability
 *   en_phy_pwr_mgmt	(size 1, offset 21, init 0):	RW	PHY Power-Management Enable
 *   sdp0_iodir	(size 1, offset 22, init 0):	RW	SDP0 pin I/O directionality
 *   sdp1_iodir	(size 1, offset 23, init 0):	RW	SDP1 pin I/O directionality
 *   _anon24	(size 2, offset 24, init 0):	MBZ	_
 *   rst	(size 1, offset 26, init 0):	RW	Device reset
 *   rfce	(size 1, offset 27, init 0):	RW	Receive flow control enable
 *   tfce	(size 1, offset 28, init 0):	RW	Transmit flow control enable
 *   _anon29	(size 1, offset 29, init 0):	MBZ	_
 *   vme	(size 1, offset 30, init 0):	RW	VLAN mode enable
 *   phy_rst	(size 1, offset 31, init 0):	RW	PHY reset
 */
static inline e1000_ctrldup_t e1000_ctrldup_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline e1000_ctrldup_t e1000_ctrldup_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ctrldup_t e1000_ctrldup_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4));
}

static inline void e1000_ctrldup_rawwr(__DN(t) *_dev, e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_rawwr(__DN(t) *_dev, e1000_ctrldup_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline void e1000_ctrldup_wr(__DN(t) *_dev, e1000_ctrldup_t _regval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_wr(__DN(t) *_dev, e1000_ctrldup_t _regval)
{
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
}

static inline int e1000_ctrldup_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ctrldup_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrldup (Device Control Duplicate (Shadow)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fd =\t%" PRIx8 "\t(full-duplex)\n", e1000_ctrldup_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_md =\t%" PRIx8 "\t(GIO master disable)\n", e1000_ctrldup_gio_md_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrst =\t%" PRIx8 "\t(Link reset)\n", e1000_ctrldup_lrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asde =\t%" PRIx8 "\t(Auto-Speed Detection Enable)\n", e1000_ctrldup_asde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slu =\t%" PRIx8 "\t(Set link up)\n", e1000_ctrldup_slu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ilos =\t%" PRIx8 "\t(Invert Loss-of-Signal (LOS))\n", e1000_ctrldup_ilos_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_ctrldup_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Speed selection)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcspd =\t%" PRIx8 "\t(Force speed)\n", e1000_ctrldup_frcspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " frcdplx =\t%" PRIx8 "\t(Force duplex)\n", e1000_ctrldup_frcdplx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_data =\t%" PRIx8 "\t(SDP0 data value, or dock/undock status)\n", e1000_ctrldup_sdp0_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_data =\t%" PRIx8 "\t(SDP1 data value)\n", e1000_ctrldup_sdp1_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " advd3wuc =\t%" PRIx8 "\t(D3cold wakeup capability)\n", e1000_ctrldup_advd3wuc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_phy_pwr_mgmt =\t%" PRIx8 "\t(PHY Power-Management Enable)\n", e1000_ctrldup_en_phy_pwr_mgmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_iodir =\t%" PRIx8 "\t(SDP0 pin I/O directionality)\n", e1000_ctrldup_sdp0_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_iodir =\t%" PRIx8 "\t(SDP1 pin I/O directionality)\n", e1000_ctrldup_sdp1_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e1000_ctrldup_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfce =\t%" PRIx8 "\t(Receive flow control enable)\n", e1000_ctrldup_rfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfce =\t%" PRIx8 "\t(Transmit flow control enable)\n", e1000_ctrldup_tfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN mode enable)\n", e1000_ctrldup_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_rst =\t%" PRIx8 "\t(PHY reset)\n", e1000_ctrldup_phy_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_ctrldup_fd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_fd_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_fd_extract(_regval));
}

static inline uint8_t e1000_ctrldup_gio_md_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_gio_md_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_gio_md_extract(_regval));
}

static inline uint8_t e1000_ctrldup_lrst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_lrst_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_lrst_extract(_regval));
}

static inline uint8_t e1000_ctrldup_asde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_asde_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_asde_extract(_regval));
}

static inline uint8_t e1000_ctrldup_slu_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_slu_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_slu_extract(_regval));
}

static inline uint8_t e1000_ctrldup_ilos_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_ilos_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_ilos_extract(_regval));
}

static inline e1000_linkspeed_t e1000_ctrldup_speed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_ctrldup_speed_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_speed_extract(_regval));
}

static inline uint8_t e1000_ctrldup_frcspd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_frcspd_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_frcspd_extract(_regval));
}

static inline uint8_t e1000_ctrldup_frcdplx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_frcdplx_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_frcdplx_extract(_regval));
}

static inline uint8_t e1000_ctrldup_sdp0_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp0_data_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_sdp0_data_extract(_regval));
}

static inline uint8_t e1000_ctrldup_sdp1_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp1_data_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_sdp1_data_extract(_regval));
}

static inline uint8_t e1000_ctrldup_advd3wuc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_advd3wuc_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_advd3wuc_extract(_regval));
}

static inline uint8_t e1000_ctrldup_en_phy_pwr_mgmt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_en_phy_pwr_mgmt_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_en_phy_pwr_mgmt_extract(_regval));
}

static inline uint8_t e1000_ctrldup_sdp0_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp0_iodir_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_sdp0_iodir_extract(_regval));
}

static inline uint8_t e1000_ctrldup_sdp1_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_sdp1_iodir_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_sdp1_iodir_extract(_regval));
}

static inline uint8_t e1000_ctrldup_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_rst_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_rst_extract(_regval));
}

static inline uint8_t e1000_ctrldup_rfce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_rfce_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_rfce_extract(_regval));
}

static inline uint8_t e1000_ctrldup_tfce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_tfce_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_tfce_extract(_regval));
}

static inline uint8_t e1000_ctrldup_vme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_vme_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_vme_extract(_regval));
}

static inline uint8_t e1000_ctrldup_phy_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrldup_phy_rst_rdf(__DN(t) *_dev)
{
    e1000_ctrldup_t _regval = mackerel_read_addr_32(_dev->base, 0x4);
    return(e1000_ctrldup_phy_rst_extract(_regval));
}

static inline void e1000_ctrldup_fd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_fd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x1 & (((e1000_ctrldup_t )(_fieldval)) << 0);
    _regval = (_regval | (0xdcfc1bec & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_gio_md_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_gio_md_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x4 & (((e1000_ctrldup_t )(_fieldval)) << 2);
    _regval = (_regval | (0xdcfc1be9 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_lrst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_lrst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x8 & (((e1000_ctrldup_t )(_fieldval)) << 3);
    _regval = (_regval | (0xdcfc1be5 & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_asde_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_asde_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x20 & (((e1000_ctrldup_t )(_fieldval)) << 5);
    _regval = (_regval | (0xdcfc1bcd & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_slu_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_slu_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x40 & (((e1000_ctrldup_t )(_fieldval)) << 6);
    _regval = (_regval | (0xdcfc1bad & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_ilos_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_ilos_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x80 & (((e1000_ctrldup_t )(_fieldval)) << 7);
    _regval = (_regval | (0xdcfc1b6d & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_speed_wrf(__DN(t) *_dev, e1000_linkspeed_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_speed_wrf(__DN(t) *_dev, e1000_linkspeed_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x300 & (((e1000_ctrldup_t )(_fieldval)) << 8);
    _regval = (_regval | (0xdcfc18ed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_frcspd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_frcspd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x800 & (((e1000_ctrldup_t )(_fieldval)) << 11);
    _regval = (_regval | (0xdcfc13ed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_frcdplx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_frcdplx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x1000 & (((e1000_ctrldup_t )(_fieldval)) << 12);
    _regval = (_regval | (0xdcfc0bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_sdp0_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_sdp0_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x40000 & (((e1000_ctrldup_t )(_fieldval)) << 18);
    _regval = (_regval | (0xdcf81bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_sdp1_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_sdp1_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x80000 & (((e1000_ctrldup_t )(_fieldval)) << 19);
    _regval = (_regval | (0xdcf41bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_advd3wuc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_advd3wuc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x100000 & (((e1000_ctrldup_t )(_fieldval)) << 20);
    _regval = (_regval | (0xdcec1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_en_phy_pwr_mgmt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_en_phy_pwr_mgmt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x200000 & (((e1000_ctrldup_t )(_fieldval)) << 21);
    _regval = (_regval | (0xdcdc1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_sdp0_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_sdp0_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x400000 & (((e1000_ctrldup_t )(_fieldval)) << 22);
    _regval = (_regval | (0xdcbc1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_sdp1_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_sdp1_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x800000 & (((e1000_ctrldup_t )(_fieldval)) << 23);
    _regval = (_regval | (0xdc7c1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x4000000 & (((e1000_ctrldup_t )(_fieldval)) << 26);
    _regval = (_regval | (0xd8fc1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_rfce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_rfce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x8000000 & (((e1000_ctrldup_t )(_fieldval)) << 27);
    _regval = (_regval | (0xd4fc1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_tfce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_tfce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x10000000 & (((e1000_ctrldup_t )(_fieldval)) << 28);
    _regval = (_regval | (0xccfc1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_vme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_vme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x40000000 & (((e1000_ctrldup_t )(_fieldval)) << 30);
    _regval = (_regval | (0x9cfc1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrldup_phy_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrldup_phy_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrldup_t _regval = 0x80000000 & (((e1000_ctrldup_t )(_fieldval)) << 31);
    _regval = (_regval | (0x5cfc1bed & mackerel_read_addr_32(_dev->base, 0x4)));
    // No read of register shadow required
    _regval = (_regval & 0xdcfc1bed);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4, _regval);
    // No shadow register to write to
}

/*
 * Register status: Device status
 * Type: e1000.status (Implicit type of Device status register)
 *   fd	(size 1, offset 0, init 0):	RO	Link full duplex configuration
 *   lu	(size 1, offset 1, init 0):	RO	Link up
 *   func_id	(size 2, offset 2, init 0):	RO	Function ID
 *   txoff	(size 1, offset 4, init 0):	RO	Transmission paused
 *   tbimode	(size 1, offset 5, init 0):	RO	TBI mode
 *   speed	(size 2, offset 6, init 0):	RO	Link speed setting
 *   asdv	(size 2, offset 8, init 0):	RO	Auto speed detection value
 *   phyra	(size 1, offset 10, init 0):	RO	PHY reset asserted
 *   pci66	(size 1, offset 11, init 0):	RO	PCI Bus speed indication
 *   bus64	(size 1, offset 12, init 0):	RO	PCI Bus Width indication
 *   pcix_mode	(size 1, offset 13, init 0):	RO	PCI-X Mode indication
 *   pcixspd	(size 2, offset 14, init 0):	RO	PCI-X Bus Speed Indication
 *   _anon16	(size 3, offset 16, init 0):	MBZ	_
 *   gio_mes	(size 1, offset 19, init 0):	RO	GIO master enable status
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline e1000_status_t e1000_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline e1000_status_t e1000_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_status_t e1000_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void e1000_status_rawwr(__DN(t) *_dev, e1000_status_t _regval) __attribute__ ((always_inline));
static inline void e1000_status_rawwr(__DN(t) *_dev, e1000_status_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

// Register status is not writeable
static inline int e1000_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register status (Device status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fd =\t%" PRIx8 "\t(Link full duplex configuration)\n", e1000_status_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lu =\t%" PRIx8 "\t(Link up)\n", e1000_status_lu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " func_id =\t%" PRIx8 "\t(Function ID)\n", e1000_status_func_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txoff =\t%" PRIx8 "\t(Transmission paused)\n", e1000_status_txoff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tbimode =\t%" PRIx8 "\t(TBI mode)\n", e1000_status_tbimode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_status_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link speed setting)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asdv =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkspeed_prtval(_s + _r, _avail, e1000_status_asdv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto speed detection value)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phyra =\t%" PRIx8 "\t(PHY reset asserted)\n", e1000_status_phyra_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci66 =\t%" PRIx8 "\t(PCI Bus speed indication)\n", e1000_status_pci66_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bus64 =\t%" PRIx8 "\t(PCI Bus Width indication)\n", e1000_status_bus64_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcix_mode =\t%" PRIx8 "\t(PCI-X Mode indication)\n", e1000_status_pcix_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcixspd =\t%" PRIx8 "\t(PCI-X Bus Speed Indication)\n", e1000_status_pcixspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_mes =\t%" PRIx8 "\t(GIO master enable status)\n", e1000_status_gio_mes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t e1000_status_fd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_fd_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_fd_extract(_regval));
}

static inline uint8_t e1000_status_lu_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_lu_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_lu_extract(_regval));
}

static inline uint8_t e1000_status_func_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_func_id_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_func_id_extract(_regval));
}

static inline uint8_t e1000_status_txoff_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_txoff_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_txoff_extract(_regval));
}

static inline uint8_t e1000_status_tbimode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_tbimode_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_tbimode_extract(_regval));
}

static inline e1000_linkspeed_t e1000_status_speed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_status_speed_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_speed_extract(_regval));
}

static inline e1000_linkspeed_t e1000_status_asdv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_linkspeed_t e1000_status_asdv_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_asdv_extract(_regval));
}

static inline uint8_t e1000_status_phyra_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_phyra_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_phyra_extract(_regval));
}

static inline uint8_t e1000_status_pci66_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_pci66_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_pci66_extract(_regval));
}

static inline uint8_t e1000_status_bus64_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_bus64_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_bus64_extract(_regval));
}

static inline uint8_t e1000_status_pcix_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_pcix_mode_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_pcix_mode_extract(_regval));
}

static inline uint8_t e1000_status_pcixspd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_pcixspd_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_pcixspd_extract(_regval));
}

static inline uint8_t e1000_status_gio_mes_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_status_gio_mes_rdf(__DN(t) *_dev)
{
    e1000_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e1000_status_gio_mes_extract(_regval));
}

/*
 * Register eecd: EEPROM/Flash control
 * Type: e1000.eecd (Implicit type of EEPROM/Flash control register)
 *   ee_sk	(size 1, offset 0, init 0):	RW	Clock input to EEPROM
 *   ee_cs	(size 1, offset 1, init 0):	RW	Chip select to EEPROM
 *   ee_di	(size 1, offset 2, init 0):	RW	Data input to EEPROM
 *   ee_do	(size 1, offset 3, init 0):	RW	Data output bit from EEPROM
 *   fwe	(size 2, offset 4, init 0):	RW	Flash write enable control
 *   ee_req	(size 1, offset 6, init 0):	RW	Request EEPROM access
 *   ee_gnt	(size 1, offset 7, init 0):	RW	Grant EEPROM access
 *   ee_pres	(size 1, offset 8, init 0):	RW	EEPROM present
 *   ee_size_n	(size 1, offset 9, init 0):	RW	EEPROM size for NM93C46 compatible EEPROM
 *   ee_size_m	(size 1, offset 10, init 0):	RW	EEPROM size for Microwire EEPROMs
 *   _anon11	(size 2, offset 11, init 0):	MBZ	_
 *   ee_type	(size 1, offset 13, init 0):	RW	EEPROM Type. (82541xx and 82547GI/EI)
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
static inline e1000_eecd_t e1000_eecd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline e1000_eecd_t e1000_eecd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eecd_t e1000_eecd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10));
}

static inline void e1000_eecd_rawwr(__DN(t) *_dev, e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline void e1000_eecd_rawwr(__DN(t) *_dev, e1000_eecd_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline void e1000_eecd_wr(__DN(t) *_dev, e1000_eecd_t _regval) __attribute__ ((always_inline));
static inline void e1000_eecd_wr(__DN(t) *_dev, e1000_eecd_t _regval)
{
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
}

static inline int e1000_eecd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_eecd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eecd (EEPROM/Flash control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_sk =\t%" PRIx8 "\t(Clock input to EEPROM)\n", e1000_eecd_ee_sk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_cs =\t%" PRIx8 "\t(Chip select to EEPROM)\n", e1000_eecd_ee_cs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_di =\t%" PRIx8 "\t(Data input to EEPROM)\n", e1000_eecd_ee_di_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_do =\t%" PRIx8 "\t(Data output bit from EEPROM)\n", e1000_eecd_ee_do_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_flashenable_prtval(_s + _r, _avail, e1000_eecd_fwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Flash write enable control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_req =\t%" PRIx8 "\t(Request EEPROM access)\n", e1000_eecd_ee_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_gnt =\t%" PRIx8 "\t(Grant EEPROM access)\n", e1000_eecd_ee_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_pres =\t%" PRIx8 "\t(EEPROM present)\n", e1000_eecd_ee_pres_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_size_n =\t%" PRIx8 "\t(EEPROM size for NM93C46 compatible EEPROM)\n", e1000_eecd_ee_size_n_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_size_m =\t%" PRIx8 "\t(EEPROM size for Microwire EEPROMs)\n", e1000_eecd_ee_size_m_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_type =\t%" PRIx8 "\t(EEPROM Type. (82541xx and 82547GI/EI))\n", e1000_eecd_ee_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint8_t e1000_eecd_ee_sk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_sk_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_sk_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_cs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_cs_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_cs_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_di_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_di_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_di_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_do_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_do_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_do_extract(_regval));
}

static inline e1000_flashenable_t e1000_eecd_fwe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_flashenable_t e1000_eecd_fwe_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_fwe_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_req_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_req_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_req_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_gnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_gnt_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_gnt_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_pres_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_pres_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_pres_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_size_n_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_size_n_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_size_n_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_size_m_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_size_m_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_size_m_extract(_regval));
}

static inline uint8_t e1000_eecd_ee_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eecd_ee_type_rdf(__DN(t) *_dev)
{
    e1000_eecd_t _regval = mackerel_read_addr_32(_dev->base, 0x10);
    return(e1000_eecd_ee_type_extract(_regval));
}

static inline void e1000_eecd_ee_sk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_sk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x1 & (((e1000_eecd_t )(_fieldval)) << 0);
    _regval = (_regval | (0x27fe & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_cs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_cs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x2 & (((e1000_eecd_t )(_fieldval)) << 1);
    _regval = (_regval | (0x27fd & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_di_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_di_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x4 & (((e1000_eecd_t )(_fieldval)) << 2);
    _regval = (_regval | (0x27fb & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_do_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_do_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x8 & (((e1000_eecd_t )(_fieldval)) << 3);
    _regval = (_regval | (0x27f7 & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_fwe_wrf(__DN(t) *_dev, e1000_flashenable_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_fwe_wrf(__DN(t) *_dev, e1000_flashenable_t _fieldval)
{
    e1000_eecd_t _regval = 0x30 & (((e1000_eecd_t )(_fieldval)) << 4);
    _regval = (_regval | (0x27cf & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_req_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_req_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x40 & (((e1000_eecd_t )(_fieldval)) << 6);
    _regval = (_regval | (0x27bf & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_gnt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_gnt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x80 & (((e1000_eecd_t )(_fieldval)) << 7);
    _regval = (_regval | (0x277f & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_pres_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_pres_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x100 & (((e1000_eecd_t )(_fieldval)) << 8);
    _regval = (_regval | (0x26ff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_size_n_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_size_n_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x200 & (((e1000_eecd_t )(_fieldval)) << 9);
    _regval = (_regval | (0x25ff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_size_m_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_size_m_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x400 & (((e1000_eecd_t )(_fieldval)) << 10);
    _regval = (_regval | (0x23ff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

static inline void e1000_eecd_ee_type_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eecd_ee_type_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eecd_t _regval = 0x2000 & (((e1000_eecd_t )(_fieldval)) << 13);
    _regval = (_regval | (0x7ff & mackerel_read_addr_32(_dev->base, 0x10)));
    // No read of register shadow required
    _regval = (_regval & 0x27ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10, _regval);
    // No shadow register to write to
}

/*
 * Register eerd_nm: EEPROM read
 * Type: e1000.eerd_nm (Implicit type of EEPROM read register)
 *   start	(size 1, offset 0, init 0):	RW	Start read
 *   _anon1	(size 3, offset 1, init 0):	MBZ	_
 *   done	(size 1, offset 4, init 0):	RO	Read done
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   addr	(size 8, offset 8, init 0):	RW	Read address
 *   data	(size 16, offset 16, init 0):	RW	Read data
 */
static inline e1000_eerd_nm_t e1000_eerd_nm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eerd_nm_t e1000_eerd_nm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline e1000_eerd_nm_t e1000_eerd_nm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eerd_nm_t e1000_eerd_nm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void e1000_eerd_nm_rawwr(__DN(t) *_dev, e1000_eerd_nm_t _regval) __attribute__ ((always_inline));
static inline void e1000_eerd_nm_rawwr(__DN(t) *_dev, e1000_eerd_nm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void e1000_eerd_nm_wr(__DN(t) *_dev, e1000_eerd_nm_t _regval) __attribute__ ((always_inline));
static inline void e1000_eerd_nm_wr(__DN(t) *_dev, e1000_eerd_nm_t _regval)
{
    _regval = (_regval & 0xffffff11);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int e1000_eerd_nm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_eerd_nm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_eerd_nm_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eerd_nm (EEPROM read): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start read)\n", e1000_eerd_nm_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read done)\n", e1000_eerd_nm_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx8 "\t(Read address)\n", e1000_eerd_nm_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Read data)\n", e1000_eerd_nm_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_eerd_nm_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_nm_start_rdf(__DN(t) *_dev)
{
    e1000_eerd_nm_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_nm_start_extract(_regval));
}

static inline uint8_t e1000_eerd_nm_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_nm_done_rdf(__DN(t) *_dev)
{
    e1000_eerd_nm_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_nm_done_extract(_regval));
}

static inline uint8_t e1000_eerd_nm_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_nm_addr_rdf(__DN(t) *_dev)
{
    e1000_eerd_nm_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_nm_addr_extract(_regval));
}

static inline uint16_t e1000_eerd_nm_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_eerd_nm_data_rdf(__DN(t) *_dev)
{
    e1000_eerd_nm_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_nm_data_extract(_regval));
}

static inline void e1000_eerd_nm_start_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eerd_nm_start_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eerd_nm_t _regval = 0x1 & (((e1000_eerd_nm_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff11);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void e1000_eerd_nm_addr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eerd_nm_addr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eerd_nm_t _regval = 0xff00 & (((e1000_eerd_nm_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff0001 & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff11);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void e1000_eerd_nm_data_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eerd_nm_data_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_eerd_nm_t _regval = 0xffff0000 & (((e1000_eerd_nm_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff01 & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    _regval = (_regval & 0xffffff11);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register eerd_ms: EEPROM read 82541xx and 82547GI/EI
 * Type: e1000.eerd_ms (Implicit type of EEPROM read 82541xx and 82547GI/EI register)
 *   start	(size 1, offset 0, init 0):	RW	Start read
 *   done	(size 1, offset 1, init 0):	RO	Read done
 *   addr	(size 14, offset 2, init 0):	RW	Read address
 *   data	(size 16, offset 16, init 0):	RW	Read data
 */
static inline e1000_eerd_ms_t e1000_eerd_ms_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eerd_ms_t e1000_eerd_ms_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline e1000_eerd_ms_t e1000_eerd_ms_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eerd_ms_t e1000_eerd_ms_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14));
}

static inline void e1000_eerd_ms_rawwr(__DN(t) *_dev, e1000_eerd_ms_t _regval) __attribute__ ((always_inline));
static inline void e1000_eerd_ms_rawwr(__DN(t) *_dev, e1000_eerd_ms_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline void e1000_eerd_ms_wr(__DN(t) *_dev, e1000_eerd_ms_t _regval) __attribute__ ((always_inline));
static inline void e1000_eerd_ms_wr(__DN(t) *_dev, e1000_eerd_ms_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
}

static inline int e1000_eerd_ms_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_eerd_ms_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_eerd_ms_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eerd_ms (EEPROM read 82541xx and 82547GI/EI): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start read)\n", e1000_eerd_ms_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read done)\n", e1000_eerd_ms_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Read address)\n", e1000_eerd_ms_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Read data)\n", e1000_eerd_ms_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_eerd_ms_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_ms_start_rdf(__DN(t) *_dev)
{
    e1000_eerd_ms_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_ms_start_extract(_regval));
}

static inline uint8_t e1000_eerd_ms_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eerd_ms_done_rdf(__DN(t) *_dev)
{
    e1000_eerd_ms_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_ms_done_extract(_regval));
}

static inline uint16_t e1000_eerd_ms_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_eerd_ms_addr_rdf(__DN(t) *_dev)
{
    e1000_eerd_ms_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_ms_addr_extract(_regval));
}

static inline uint16_t e1000_eerd_ms_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_eerd_ms_data_rdf(__DN(t) *_dev)
{
    e1000_eerd_ms_t _regval = mackerel_read_addr_32(_dev->base, 0x14);
    return(e1000_eerd_ms_data_extract(_regval));
}

static inline void e1000_eerd_ms_start_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eerd_ms_start_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eerd_ms_t _regval = 0x1 & (((e1000_eerd_ms_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void e1000_eerd_ms_addr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eerd_ms_addr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_eerd_ms_t _regval = 0xfffc & (((e1000_eerd_ms_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffff0001 & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

static inline void e1000_eerd_ms_data_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eerd_ms_data_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_eerd_ms_t _regval = 0xffff0000 & (((e1000_eerd_ms_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffd & mackerel_read_addr_32(_dev->base, 0x14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14, _regval);
    // No shadow register to write to
}

/*
 * Register ctrlext: Extended device control
 * Type: e1000.ctrlext (Implicit type of Extended device control register)
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   sdp2_gpien	(size 1, offset 2, init 0):	RW	General-purpose interrupt detection for SDP2
 *   sdp3_gpien	(size 1, offset 3, init 0):	RW	General-purpose interrupt detection for SDP3
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   sdp2_data	(size 1, offset 6, init 0):	RW	SDP2 data value
 *   sdp3_data	(size 1, offset 7, init 0):	RW	SDP3 data value
 *   _anon8	(size 2, offset 8, init 0):	MBZ	_
 *   sdp2_iodir	(size 1, offset 10, init 0):	RW	SDP2 pin directionality
 *   sdp3_iodir	(size 1, offset 11, init 0):	RW	SDP3 pin directionality
 *   asdchk	(size 1, offset 12, init 0):	RW	Auto-speed-detection check
 *   ee_rst	(size 1, offset 13, init 0):	RW	EEPROM reset
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   spd_byps	(size 1, offset 15, init 0):	RW	Speed select bypass
 *   _anon16	(size 1, offset 16, init 0):	RSVD	_
 *   rodis	(size 1, offset 17, init 0):	RW	Relaxed ordering disabled
 *   serdeslpe	(size 1, offset 18, init 0):	RW	SERDES low power enable
 *   dmadge	(size 1, offset 19, init 0):	RW	DMA dynamic gating enable
 *   phypde	(size 1, offset 20, init 0):	RW	PHY power down enable
 *   _anon21	(size 1, offset 21, init 0):	RSVD	_
 *   link_mode	(size 2, offset 22, init 0):	RW	Link mode
 *   pb_paren	(size 1, offset 24, init 0):	RW	Packet buffer parity error detection enable
 *   df_paren	(size 1, offset 25, init 0):	RW	Descriptor FIFO parity error detection enable
 *   _anon26	(size 1, offset 26, init 0):	MBZ	_
 *   iame	(size 1, offset 27, init 0):	RW	Interrupt acknowledge auto-mask enable
 *   drv_load	(size 1, offset 28, init 0):	RW	Driver loaded
 *   int_tca	(size 1, offset 29, init 0):	RW	Timers clear enable
 *   host_paren	(size 1, offset 30, init 0):	RW	Host data FIFO parity enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e1000_ctrlext_t e1000_ctrlext_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline e1000_ctrlext_t e1000_ctrlext_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ctrlext_t e1000_ctrlext_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void e1000_ctrlext_rawwr(__DN(t) *_dev, e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_rawwr(__DN(t) *_dev, e1000_ctrlext_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void e1000_ctrlext_wr(__DN(t) *_dev, e1000_ctrlext_t _regval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_wr(__DN(t) *_dev, e1000_ctrlext_t _regval)
{
    _regval = (_regval & 0x7bdebccc);
    // No MB1 fields present
    _regval = (_regval | (0x80210030 & mackerel_read_addr_32(_dev->base, 0x18)));
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int e1000_ctrlext_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ctrlext_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrlext (Extended device control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_gpien =\t%" PRIx8 "\t(General-purpose interrupt detection for SDP2)\n", e1000_ctrlext_sdp2_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_gpien =\t%" PRIx8 "\t(General-purpose interrupt detection for SDP3)\n", e1000_ctrlext_sdp3_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_data =\t%" PRIx8 "\t(SDP2 data value)\n", e1000_ctrlext_sdp2_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_data =\t%" PRIx8 "\t(SDP3 data value)\n", e1000_ctrlext_sdp3_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_iodir =\t%" PRIx8 "\t(SDP2 pin directionality)\n", e1000_ctrlext_sdp2_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_iodir =\t%" PRIx8 "\t(SDP3 pin directionality)\n", e1000_ctrlext_sdp3_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asdchk =\t%" PRIx8 "\t(Auto-speed-detection check)\n", e1000_ctrlext_asdchk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_rst =\t%" PRIx8 "\t(EEPROM reset)\n", e1000_ctrlext_ee_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd_byps =\t%" PRIx8 "\t(Speed select bypass)\n", e1000_ctrlext_spd_byps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rodis =\t%" PRIx8 "\t(Relaxed ordering disabled)\n", e1000_ctrlext_rodis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " serdeslpe =\t%" PRIx8 "\t(SERDES low power enable)\n", e1000_ctrlext_serdeslpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dmadge =\t%" PRIx8 "\t(DMA dynamic gating enable)\n", e1000_ctrlext_dmadge_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phypde =\t%" PRIx8 "\t(PHY power down enable)\n", e1000_ctrlext_phypde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " link_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_linkmode_prtval(_s + _r, _avail, e1000_ctrlext_link_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pb_paren =\t%" PRIx8 "\t(Packet buffer parity error detection enable)\n", e1000_ctrlext_pb_paren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " df_paren =\t%" PRIx8 "\t(Descriptor FIFO parity error detection enable)\n", e1000_ctrlext_df_paren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iame =\t%" PRIx8 "\t(Interrupt acknowledge auto-mask enable)\n", e1000_ctrlext_iame_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drv_load =\t%" PRIx8 "\t(Driver loaded)\n", e1000_ctrlext_drv_load_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_tca =\t%" PRIx8 "\t(Timers clear enable)\n", e1000_ctrlext_int_tca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " host_paren =\t%" PRIx8 "\t(Host data FIFO parity enable)\n", e1000_ctrlext_host_paren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t e1000_ctrlext_sdp2_gpien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp2_gpien_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_sdp2_gpien_extract(_regval));
}

static inline uint8_t e1000_ctrlext_sdp3_gpien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp3_gpien_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_sdp3_gpien_extract(_regval));
}

static inline uint8_t e1000_ctrlext_sdp2_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp2_data_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_sdp2_data_extract(_regval));
}

static inline uint8_t e1000_ctrlext_sdp3_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp3_data_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_sdp3_data_extract(_regval));
}

static inline uint8_t e1000_ctrlext_sdp2_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp2_iodir_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_sdp2_iodir_extract(_regval));
}

static inline uint8_t e1000_ctrlext_sdp3_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_sdp3_iodir_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_sdp3_iodir_extract(_regval));
}

static inline uint8_t e1000_ctrlext_asdchk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_asdchk_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_asdchk_extract(_regval));
}

static inline uint8_t e1000_ctrlext_ee_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_ee_rst_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_ee_rst_extract(_regval));
}

static inline uint8_t e1000_ctrlext_spd_byps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_spd_byps_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_spd_byps_extract(_regval));
}

static inline uint8_t e1000_ctrlext_rodis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_rodis_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_rodis_extract(_regval));
}

static inline uint8_t e1000_ctrlext_serdeslpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_serdeslpe_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_serdeslpe_extract(_regval));
}

static inline uint8_t e1000_ctrlext_dmadge_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_dmadge_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_dmadge_extract(_regval));
}

static inline uint8_t e1000_ctrlext_phypde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_phypde_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_phypde_extract(_regval));
}

static inline e1000_linkmode_t e1000_ctrlext_link_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_linkmode_t e1000_ctrlext_link_mode_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_link_mode_extract(_regval));
}

static inline uint8_t e1000_ctrlext_pb_paren_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_pb_paren_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_pb_paren_extract(_regval));
}

static inline uint8_t e1000_ctrlext_df_paren_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_df_paren_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_df_paren_extract(_regval));
}

static inline uint8_t e1000_ctrlext_iame_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_iame_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_iame_extract(_regval));
}

static inline uint8_t e1000_ctrlext_drv_load_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_drv_load_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_drv_load_extract(_regval));
}

static inline uint8_t e1000_ctrlext_int_tca_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_int_tca_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_int_tca_extract(_regval));
}

static inline uint8_t e1000_ctrlext_host_paren_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ctrlext_host_paren_rdf(__DN(t) *_dev)
{
    e1000_ctrlext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e1000_ctrlext_host_paren_extract(_regval));
}

static inline void e1000_ctrlext_sdp2_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_sdp2_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x4 & (((e1000_ctrlext_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfbffbcf8 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_sdp3_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_sdp3_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x8 & (((e1000_ctrlext_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfbffbcf4 & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_sdp2_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_sdp2_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x40 & (((e1000_ctrlext_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfbffbcbc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_sdp3_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_sdp3_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x80 & (((e1000_ctrlext_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfbffbc7c & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_sdp2_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_sdp2_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x400 & (((e1000_ctrlext_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfbffb8fc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_sdp3_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_sdp3_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x800 & (((e1000_ctrlext_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfbffb4fc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_asdchk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_asdchk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x1000 & (((e1000_ctrlext_t )(_fieldval)) << 12);
    _regval = (_regval | (0xfbffacfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_ee_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_ee_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x2000 & (((e1000_ctrlext_t )(_fieldval)) << 13);
    _regval = (_regval | (0xfbff9cfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_spd_byps_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_spd_byps_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x8000 & (((e1000_ctrlext_t )(_fieldval)) << 15);
    _regval = (_regval | (0xfbff3cfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_rodis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_rodis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x20000 & (((e1000_ctrlext_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfbfdbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_serdeslpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_serdeslpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x40000 & (((e1000_ctrlext_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfbfbbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_dmadge_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_dmadge_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x80000 & (((e1000_ctrlext_t )(_fieldval)) << 19);
    _regval = (_regval | (0xfbf7bcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_phypde_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_phypde_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x100000 & (((e1000_ctrlext_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfbefbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_link_mode_wrf(__DN(t) *_dev, e1000_linkmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_link_mode_wrf(__DN(t) *_dev, e1000_linkmode_t _fieldval)
{
    e1000_ctrlext_t _regval = 0xc00000 & (((e1000_ctrlext_t )(_fieldval)) << 22);
    _regval = (_regval | (0xfb3fbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_pb_paren_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_pb_paren_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x1000000 & (((e1000_ctrlext_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfaffbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_df_paren_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_df_paren_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x2000000 & (((e1000_ctrlext_t )(_fieldval)) << 25);
    _regval = (_regval | (0xf9ffbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_iame_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_iame_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x8000000 & (((e1000_ctrlext_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf3ffbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_drv_load_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_drv_load_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x10000000 & (((e1000_ctrlext_t )(_fieldval)) << 28);
    _regval = (_regval | (0xebffbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_int_tca_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_int_tca_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x20000000 & (((e1000_ctrlext_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdbffbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e1000_ctrlext_host_paren_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ctrlext_host_paren_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ctrlext_t _regval = 0x40000000 & (((e1000_ctrlext_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbbffbcfc & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    _regval = (_regval & 0xfbffbcfc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register fla: Flash access
 * Type: e1000.fla (Implicit type of Flash access register)
 *   fl_sk	(size 1, offset 0, init 0):	RW	Clock input to Flash
 *   fl_ce	(size 1, offset 1, init 0):	RW	Chip select to Flash
 *   fl_si	(size 1, offset 2, init 0):	RW	Data input to Flash
 *   fl_so	(size 1, offset 3, init 0):	RW	Data output bit from Flash
 *   fl_req	(size 1, offset 4, init 0):	RW	Request Flash access
 *   fl_gnt	(size 1, offset 5, init 0):	RW	Grant Flash access
 *   fl_addr_sz	(size 1, offset 6, init 0):	RW	Flash address size
 *   _anon7	(size 2, offset 7, init 0):	RSVD	_
 *   sw_wr_done	(size 1, offset 9, init 0):	RW	Last write done
 *   rd_status	(size 1, offset 10, init 0):	RW	Flash status
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 *   ide_bo	(size 14, offset 16, init 0):	RW	Base address of IDE Boot expansion ROM
 *   fl_busy	(size 1, offset 30, init 0):	RW	Flash busy
 *   fl_er	(size 1, offset 31, init 0):	RW	Flash erase command
 */
static inline e1000_fla_t e1000_fla_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline e1000_fla_t e1000_fla_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fla_t e1000_fla_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1c));
}

static inline void e1000_fla_rawwr(__DN(t) *_dev, e1000_fla_t _regval) __attribute__ ((always_inline));
static inline void e1000_fla_rawwr(__DN(t) *_dev, e1000_fla_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline void e1000_fla_wr(__DN(t) *_dev, e1000_fla_t _regval) __attribute__ ((always_inline));
static inline void e1000_fla_wr(__DN(t) *_dev, e1000_fla_t _regval)
{
    _regval = (_regval & 0xffff067f);
    // No MB1 fields present
    _regval = (_regval | (0xf980 & mackerel_read_addr_32(_dev->base, 0x1c)));
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
}

static inline int e1000_fla_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fla_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fla (Flash access): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_sk =\t%" PRIx8 "\t(Clock input to Flash)\n", e1000_fla_fl_sk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_ce =\t%" PRIx8 "\t(Chip select to Flash)\n", e1000_fla_fl_ce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_si =\t%" PRIx8 "\t(Data input to Flash)\n", e1000_fla_fl_si_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_so =\t%" PRIx8 "\t(Data output bit from Flash)\n", e1000_fla_fl_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_req =\t%" PRIx8 "\t(Request Flash access)\n", e1000_fla_fl_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_gnt =\t%" PRIx8 "\t(Grant Flash access)\n", e1000_fla_fl_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_addr_sz =\t%" PRIx8 "\t(Flash address size)\n", e1000_fla_fl_addr_sz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_wr_done =\t%" PRIx8 "\t(Last write done)\n", e1000_fla_sw_wr_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rd_status =\t%" PRIx8 "\t(Flash status)\n", e1000_fla_rd_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ide_bo =\t%" PRIx16 "\t(Base address of IDE Boot expansion ROM)\n", e1000_fla_ide_bo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_busy =\t%" PRIx8 "\t(Flash busy)\n", e1000_fla_fl_busy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_er =\t%" PRIx8 "\t(Flash erase command)\n", e1000_fla_fl_er_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_fla_fl_sk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_sk_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_sk_extract(_regval));
}

static inline uint8_t e1000_fla_fl_ce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_ce_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_ce_extract(_regval));
}

static inline uint8_t e1000_fla_fl_si_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_si_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_si_extract(_regval));
}

static inline uint8_t e1000_fla_fl_so_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_so_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_so_extract(_regval));
}

static inline uint8_t e1000_fla_fl_req_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_req_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_req_extract(_regval));
}

static inline uint8_t e1000_fla_fl_gnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_gnt_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_gnt_extract(_regval));
}

static inline uint8_t e1000_fla_fl_addr_sz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_addr_sz_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_addr_sz_extract(_regval));
}

static inline uint8_t e1000_fla_sw_wr_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_sw_wr_done_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_sw_wr_done_extract(_regval));
}

static inline uint8_t e1000_fla_rd_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_rd_status_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_rd_status_extract(_regval));
}

static inline uint16_t e1000_fla_ide_bo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_fla_ide_bo_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_ide_bo_extract(_regval));
}

static inline uint8_t e1000_fla_fl_busy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_busy_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_busy_extract(_regval));
}

static inline uint8_t e1000_fla_fl_er_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fla_fl_er_rdf(__DN(t) *_dev)
{
    e1000_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1c);
    return(e1000_fla_fl_er_extract(_regval));
}

static inline void e1000_fla_fl_sk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_sk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x1 & (((e1000_fla_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_ce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_ce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x2 & (((e1000_fla_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_si_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_si_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x4 & (((e1000_fla_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_so_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_so_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x8 & (((e1000_fla_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_req_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_req_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x10 & (((e1000_fla_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_gnt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_gnt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x20 & (((e1000_fla_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_addr_sz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_addr_sz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x40 & (((e1000_fla_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_sw_wr_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_sw_wr_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x200 & (((e1000_fla_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_rd_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_rd_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x400 & (((e1000_fla_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_ide_bo_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_ide_bo_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_fla_t _regval = 0x3fff0000 & (((e1000_fla_t )(_fieldval)) << 16);
    _regval = (_regval | (0xc000ffff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_busy_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_busy_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x40000000 & (((e1000_fla_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

static inline void e1000_fla_fl_er_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fla_fl_er_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fla_t _regval = 0x80000000 & (((e1000_fla_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1c, _regval);
    // No shadow register to write to
}

/*
 * Register mdic: MDI control
 * Type: e1000.mdic (Implicit type of MDI control register)
 *   data	(size 16, offset 0, init 0):	RW	Data
 *   regadd	(size 5, offset 16, init 0):	RW	PHY register address
 *   phyadd	(size 5, offset 21, init 0):	RW	PHY address
 *   op	(size 2, offset 26, init 0):	RW	Opcode
 *   r	(size 1, offset 28, init 0):	RW	Ready bit
 *   i	(size 1, offset 29, init 0):	RW	Interript enable
 *   e	(size 1, offset 30, init 0):	RW	Error
 *   _anon31	(size 1, offset 31, init 0):	MBZ	_
 */
static inline e1000_mdic_t e1000_mdic_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline e1000_mdic_t e1000_mdic_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_mdic_t e1000_mdic_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void e1000_mdic_rawwr(__DN(t) *_dev, e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline void e1000_mdic_rawwr(__DN(t) *_dev, e1000_mdic_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void e1000_mdic_wr(__DN(t) *_dev, e1000_mdic_t _regval) __attribute__ ((always_inline));
static inline void e1000_mdic_wr(__DN(t) *_dev, e1000_mdic_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int e1000_mdic_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mdic_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mdic (MDI control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Data)\n", e1000_mdic_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " regadd =\t%" PRIx8 "\t(PHY register address)\n", e1000_mdic_regadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phyadd =\t%" PRIx8 "\t(PHY address)\n", e1000_mdic_phyadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " op =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_phyop_prtval(_s + _r, _avail, e1000_mdic_op_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Opcode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " r =\t%" PRIx8 "\t(Ready bit)\n", e1000_mdic_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i =\t%" PRIx8 "\t(Interript enable)\n", e1000_mdic_i_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " e =\t%" PRIx8 "\t(Error)\n", e1000_mdic_e_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint16_t e1000_mdic_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_mdic_data_rdf(__DN(t) *_dev)
{
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e1000_mdic_data_extract(_regval));
}

static inline uint8_t e1000_mdic_regadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_regadd_rdf(__DN(t) *_dev)
{
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e1000_mdic_regadd_extract(_regval));
}

static inline uint8_t e1000_mdic_phyadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_phyadd_rdf(__DN(t) *_dev)
{
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e1000_mdic_phyadd_extract(_regval));
}

static inline e1000_phyop_t e1000_mdic_op_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_phyop_t e1000_mdic_op_rdf(__DN(t) *_dev)
{
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e1000_mdic_op_extract(_regval));
}

static inline uint8_t e1000_mdic_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_r_rdf(__DN(t) *_dev)
{
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e1000_mdic_r_extract(_regval));
}

static inline uint8_t e1000_mdic_i_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_i_rdf(__DN(t) *_dev)
{
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e1000_mdic_i_extract(_regval));
}

static inline uint8_t e1000_mdic_e_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mdic_e_rdf(__DN(t) *_dev)
{
    e1000_mdic_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e1000_mdic_e_extract(_regval));
}

static inline void e1000_mdic_data_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdic_data_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_mdic_t _regval = 0xffff & (((e1000_mdic_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e1000_mdic_regadd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdic_regadd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mdic_t _regval = 0x1f0000 & (((e1000_mdic_t )(_fieldval)) << 16);
    _regval = (_regval | (0x7fe0ffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e1000_mdic_phyadd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdic_phyadd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mdic_t _regval = 0x3e00000 & (((e1000_mdic_t )(_fieldval)) << 21);
    _regval = (_regval | (0x7c1fffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e1000_mdic_op_wrf(__DN(t) *_dev, e1000_phyop_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdic_op_wrf(__DN(t) *_dev, e1000_phyop_t _fieldval)
{
    e1000_mdic_t _regval = 0xc000000 & (((e1000_mdic_t )(_fieldval)) << 26);
    _regval = (_regval | (0x73ffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e1000_mdic_r_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdic_r_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mdic_t _regval = 0x10000000 & (((e1000_mdic_t )(_fieldval)) << 28);
    _regval = (_regval | (0x6fffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e1000_mdic_i_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdic_i_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mdic_t _regval = 0x20000000 & (((e1000_mdic_t )(_fieldval)) << 29);
    _regval = (_regval | (0x5fffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e1000_mdic_e_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdic_e_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mdic_t _regval = 0x40000000 & (((e1000_mdic_t )(_fieldval)) << 30);
    _regval = (_regval | (0x3fffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register serdesctl: SERDES ANA
 * Type: e1000.serdesctl (Implicit type of SERDES ANA register)
 *   data	(size 8, offset 0, init 0):	RW	Data to SerDes
 *   addr	(size 8, offset 8, init 0):	RW	Address to SerDes
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Done
 */
static inline e1000_serdesctl_t e1000_serdesctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_serdesctl_t e1000_serdesctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline e1000_serdesctl_t e1000_serdesctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_serdesctl_t e1000_serdesctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x24));
}

static inline void e1000_serdesctl_rawwr(__DN(t) *_dev, e1000_serdesctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_serdesctl_rawwr(__DN(t) *_dev, e1000_serdesctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline void e1000_serdesctl_wr(__DN(t) *_dev, e1000_serdesctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_serdesctl_wr(__DN(t) *_dev, e1000_serdesctl_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x24)));
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
}

static inline int e1000_serdesctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_serdesctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_serdesctl_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register serdesctl (SERDES ANA): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to SerDes)\n", e1000_serdesctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx8 "\t(Address to SerDes)\n", e1000_serdesctl_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done)\n", e1000_serdesctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_serdesctl_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_serdesctl_data_rdf(__DN(t) *_dev)
{
    e1000_serdesctl_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(e1000_serdesctl_data_extract(_regval));
}

static inline uint8_t e1000_serdesctl_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_serdesctl_addr_rdf(__DN(t) *_dev)
{
    e1000_serdesctl_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(e1000_serdesctl_addr_extract(_regval));
}

static inline uint8_t e1000_serdesctl_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_serdesctl_done_rdf(__DN(t) *_dev)
{
    e1000_serdesctl_t _regval = mackerel_read_addr_32(_dev->base, 0x24);
    return(e1000_serdesctl_done_extract(_regval));
}

static inline void e1000_serdesctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_serdesctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_serdesctl_t _regval = 0xff & (((e1000_serdesctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void e1000_serdesctl_addr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_serdesctl_addr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_serdesctl_t _regval = 0xff00 & (((e1000_serdesctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

static inline void e1000_serdesctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_serdesctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_serdesctl_t _regval = 0x80000000 & (((e1000_serdesctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x24, _regval);
    // No shadow register to write to
}

/*
 * Register fcal: Flow control address low
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_fcal_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fcal_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline uint32_t e1000_fcal_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fcal_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void e1000_fcal_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcal_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void e1000_fcal_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcal_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int e1000_fcal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fcal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcal (Flow control address low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register fcah: Flow control address low
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_fcah_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fcah_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline uint32_t e1000_fcah_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fcah_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c));
}

static inline void e1000_fcah_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcah_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline void e1000_fcah_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcah_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c, _regval);
}

static inline int e1000_fcah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fcah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcah (Flow control address low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register fct: Flow control type
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_fct_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fct_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline uint32_t e1000_fct_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fct_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void e1000_fct_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_fct_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline void e1000_fct_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_fct_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

static inline int e1000_fct_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fct_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fct (Flow control type): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register kumctrlsta: GLCI control and status
 * Type: e1000.kumctrlsta (Implicit type of GLCI control and status register)
 *   data	(size 16, offset 0, init 0):	RW	Data
 *   offset	(size 5, offset 16, init 0):	RW	Offset of internal register
 *   ren	(size 1, offset 21, init 0):	RW	Read enable (1=read)
 *   _anon22	(size 10, offset 22, init 0):	RSVD	_
 */
static inline e1000_kumctrlsta_t e1000_kumctrlsta_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_kumctrlsta_t e1000_kumctrlsta_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline e1000_kumctrlsta_t e1000_kumctrlsta_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_kumctrlsta_t e1000_kumctrlsta_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x34));
}

static inline void e1000_kumctrlsta_rawwr(__DN(t) *_dev, e1000_kumctrlsta_t _regval) __attribute__ ((always_inline));
static inline void e1000_kumctrlsta_rawwr(__DN(t) *_dev, e1000_kumctrlsta_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline void e1000_kumctrlsta_wr(__DN(t) *_dev, e1000_kumctrlsta_t _regval) __attribute__ ((always_inline));
static inline void e1000_kumctrlsta_wr(__DN(t) *_dev, e1000_kumctrlsta_t _regval)
{
    _regval = (_regval & 0x3fffff);
    // No MB1 fields present
    _regval = (_regval | (0xffc00000 & mackerel_read_addr_32(_dev->base, 0x34)));
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
}

static inline int e1000_kumctrlsta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_kumctrlsta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_kumctrlsta_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register kumctrlsta (GLCI control and status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Data)\n", e1000_kumctrlsta_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " offset =\t%" PRIx8 "\t(Offset of internal register)\n", e1000_kumctrlsta_offset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ren =\t%" PRIx8 "\t(Read enable (1=read))\n", e1000_kumctrlsta_ren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    return(_r);
}

static inline uint16_t e1000_kumctrlsta_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_kumctrlsta_data_rdf(__DN(t) *_dev)
{
    e1000_kumctrlsta_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(e1000_kumctrlsta_data_extract(_regval));
}

static inline uint8_t e1000_kumctrlsta_offset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_kumctrlsta_offset_rdf(__DN(t) *_dev)
{
    e1000_kumctrlsta_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(e1000_kumctrlsta_offset_extract(_regval));
}

static inline uint8_t e1000_kumctrlsta_ren_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_kumctrlsta_ren_rdf(__DN(t) *_dev)
{
    e1000_kumctrlsta_t _regval = mackerel_read_addr_32(_dev->base, 0x34);
    return(e1000_kumctrlsta_ren_extract(_regval));
}

static inline void e1000_kumctrlsta_data_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_kumctrlsta_data_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_kumctrlsta_t _regval = 0xffff & (((e1000_kumctrlsta_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void e1000_kumctrlsta_offset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_kumctrlsta_offset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_kumctrlsta_t _regval = 0x1f0000 & (((e1000_kumctrlsta_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffe0ffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

static inline void e1000_kumctrlsta_ren_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_kumctrlsta_ren_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_kumctrlsta_t _regval = 0x200000 & (((e1000_kumctrlsta_t )(_fieldval)) << 21);
    _regval = (_regval | (0xffdfffff & mackerel_read_addr_32(_dev->base, 0x34)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x34, _regval);
    // No shadow register to write to
}

/*
 * Register vet: VLAN Ether type
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_vet_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_vet_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline uint32_t e1000_vet_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_vet_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x38));
}

static inline void e1000_vet_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_vet_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline void e1000_vet_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_vet_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x38, _regval);
}

static inline int e1000_vet_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_vet_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vet (VLAN Ether type): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mdphya: MDC/MDIO PHY address
 * Type: e1000.mdphya (Implicit type of MDC/MDIO PHY address register)
 *   phya	(size 5, offset 0, init 0):	RW	PHY address
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline e1000_mdphya_t e1000_mdphya_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_mdphya_t e1000_mdphya_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline e1000_mdphya_t e1000_mdphya_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_mdphya_t e1000_mdphya_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c));
}

static inline void e1000_mdphya_rawwr(__DN(t) *_dev, e1000_mdphya_t _regval) __attribute__ ((always_inline));
static inline void e1000_mdphya_rawwr(__DN(t) *_dev, e1000_mdphya_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline void e1000_mdphya_wr(__DN(t) *_dev, e1000_mdphya_t _regval) __attribute__ ((always_inline));
static inline void e1000_mdphya_wr(__DN(t) *_dev, e1000_mdphya_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x3c)));
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
}

static inline int e1000_mdphya_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mdphya_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_mdphya_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mdphya (MDC/MDIO PHY address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phya =\t%" PRIx8 "\t(PHY address)\n", e1000_mdphya_phya_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t e1000_mdphya_phya_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mdphya_phya_rdf(__DN(t) *_dev)
{
    e1000_mdphya_t _regval = mackerel_read_addr_32(_dev->base, 0x3c);
    return(e1000_mdphya_phya_extract(_regval));
}

static inline void e1000_mdphya_phya_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mdphya_phya_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mdphya_t _regval = 0x1f & (((e1000_mdphya_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x3c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c, _regval);
    // No shadow register to write to
}

/*
 * Register ufuse3: ULT Fuse register 3
 * Type: e1000.ufuse3 (Implicit type of ULT Fuse register 3 register)
 *   drred	(size 15, offset 0, init 0):	RO	Data RAM redundancy fuses
 *   crred	(size 13, offset 15, init 0):	RO	Code RAM redundancy fuses
 *   enad	(size 1, offset 28, init 0):	RO	Enable Data RAM redundancy fuses
 *   enac	(size 1, offset 29, init 0):	RO	Enable Code RAM redundancy fuses
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
static inline e1000_ufuse3_t e1000_ufuse3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ufuse3_t e1000_ufuse3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline e1000_ufuse3_t e1000_ufuse3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ufuse3_t e1000_ufuse3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline void e1000_ufuse3_rawwr(__DN(t) *_dev, e1000_ufuse3_t _regval) __attribute__ ((always_inline));
static inline void e1000_ufuse3_rawwr(__DN(t) *_dev, e1000_ufuse3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
}

// Register ufuse3 is not writeable
static inline int e1000_ufuse3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ufuse3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ufuse3_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ufuse3 (ULT Fuse register 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drred =\t%" PRIx16 "\t(Data RAM redundancy fuses)\n", e1000_ufuse3_drred_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crred =\t%" PRIx16 "\t(Code RAM redundancy fuses)\n", e1000_ufuse3_crred_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enad =\t%" PRIx8 "\t(Enable Data RAM redundancy fuses)\n", e1000_ufuse3_enad_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enac =\t%" PRIx8 "\t(Enable Code RAM redundancy fuses)\n", e1000_ufuse3_enac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline uint16_t e1000_ufuse3_drred_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_ufuse3_drred_rdf(__DN(t) *_dev)
{
    e1000_ufuse3_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(e1000_ufuse3_drred_extract(_regval));
}

static inline uint16_t e1000_ufuse3_crred_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_ufuse3_crred_rdf(__DN(t) *_dev)
{
    e1000_ufuse3_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(e1000_ufuse3_crred_extract(_regval));
}

static inline uint8_t e1000_ufuse3_enad_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ufuse3_enad_rdf(__DN(t) *_dev)
{
    e1000_ufuse3_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(e1000_ufuse3_enad_extract(_regval));
}

static inline uint8_t e1000_ufuse3_enac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ufuse3_enac_rdf(__DN(t) *_dev)
{
    e1000_ufuse3_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(e1000_ufuse3_enac_extract(_regval));
}

/*
 * Register fcttv: Flow control transmit timer value
 * Type: e1000.fcttv (Implicit type of Flow control transmit timer value register)
 *   ttv	(size 16, offset 0, init 0):	RW	Transmit timer value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline e1000_fcttv_t e1000_fcttv_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fcttv_t e1000_fcttv_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline e1000_fcttv_t e1000_fcttv_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fcttv_t e1000_fcttv_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x170));
}

static inline void e1000_fcttv_rawwr(__DN(t) *_dev, e1000_fcttv_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcttv_rawwr(__DN(t) *_dev, e1000_fcttv_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline void e1000_fcttv_wr(__DN(t) *_dev, e1000_fcttv_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcttv_wr(__DN(t) *_dev, e1000_fcttv_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
}

static inline int e1000_fcttv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fcttv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_fcttv_t _regval = mackerel_read_addr_32(_dev->base, 0x170);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcttv (Flow control transmit timer value): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ttv =\t%" PRIx16 "\t(Transmit timer value)\n", e1000_fcttv_ttv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e1000_fcttv_ttv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_fcttv_ttv_rdf(__DN(t) *_dev)
{
    e1000_fcttv_t _regval = mackerel_read_addr_32(_dev->base, 0x170);
    return(e1000_fcttv_ttv_extract(_regval));
}

static inline void e1000_fcttv_ttv_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fcttv_ttv_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_fcttv_t _regval = 0xffff & (((e1000_fcttv_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x170, _regval);
    // No shadow register to write to
}

/*
 * Register txcw: Transmit config word
 * Type: e1000.txcw (Implicit type of Transmit config word register)
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   txcw_fd	(size 1, offset 5, init 0):	RW	TXCW full-duplex
 *   txcw_hd	(size 1, offset 6, init 0):	RW	TXCW half-duplex
 *   txcw_pause	(size 2, offset 7, init 0):	RW	TXCW pause
 *   _anon9	(size 3, offset 9, init 0):	MBZ	_
 *   txcw_rfi	(size 2, offset 12, init 0):	RW	TXCW remote fault indication
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   txcw_npr	(size 1, offset 15, init 0):	RW	TXCW next page request
 *   _anon16	(size 14, offset 16, init 0):	MBZ	_
 *   txconfig	(size 1, offset 30, init 0):	RW	Transmit config control bit
 *   ane	(size 1, offset 31, init 0):	RW	Auto-negotiation enable
 */
static inline e1000_txcw_t e1000_txcw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x178));
}

static inline e1000_txcw_t e1000_txcw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_txcw_t e1000_txcw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x178));
}

static inline void e1000_txcw_rawwr(__DN(t) *_dev, e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline void e1000_txcw_rawwr(__DN(t) *_dev, e1000_txcw_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
}

static inline void e1000_txcw_wr(__DN(t) *_dev, e1000_txcw_t _regval) __attribute__ ((always_inline));
static inline void e1000_txcw_wr(__DN(t) *_dev, e1000_txcw_t _regval)
{
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
}

static inline int e1000_txcw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_txcw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register txcw (Transmit config word): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_fd =\t%" PRIx8 "\t(TXCW full-duplex)\n", e1000_txcw_txcw_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_hd =\t%" PRIx8 "\t(TXCW half-duplex)\n", e1000_txcw_txcw_hd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_pause =\t%" PRIx8 "\t(TXCW pause)\n", e1000_txcw_txcw_pause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_rfi =\t%" PRIx8 "\t(TXCW remote fault indication)\n", e1000_txcw_txcw_rfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcw_npr =\t%" PRIx8 "\t(TXCW next page request)\n", e1000_txcw_txcw_npr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txconfig =\t%" PRIx8 "\t(Transmit config control bit)\n", e1000_txcw_txconfig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ane =\t%" PRIx8 "\t(Auto-negotiation enable)\n", e1000_txcw_ane_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_txcw_txcw_fd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_fd_rdf(__DN(t) *_dev)
{
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    return(e1000_txcw_txcw_fd_extract(_regval));
}

static inline uint8_t e1000_txcw_txcw_hd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_hd_rdf(__DN(t) *_dev)
{
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    return(e1000_txcw_txcw_hd_extract(_regval));
}

static inline uint8_t e1000_txcw_txcw_pause_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_pause_rdf(__DN(t) *_dev)
{
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    return(e1000_txcw_txcw_pause_extract(_regval));
}

static inline uint8_t e1000_txcw_txcw_rfi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_rfi_rdf(__DN(t) *_dev)
{
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    return(e1000_txcw_txcw_rfi_extract(_regval));
}

static inline uint8_t e1000_txcw_txcw_npr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txcw_npr_rdf(__DN(t) *_dev)
{
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    return(e1000_txcw_txcw_npr_extract(_regval));
}

static inline uint8_t e1000_txcw_txconfig_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_txconfig_rdf(__DN(t) *_dev)
{
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    return(e1000_txcw_txconfig_extract(_regval));
}

static inline uint8_t e1000_txcw_ane_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_txcw_ane_rdf(__DN(t) *_dev)
{
    e1000_txcw_t _regval = mackerel_read_addr_32(_dev->base, 0x178);
    return(e1000_txcw_ane_extract(_regval));
}

static inline void e1000_txcw_txcw_fd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txcw_txcw_fd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_txcw_t _regval = 0x20 & (((e1000_txcw_t )(_fieldval)) << 5);
    _regval = (_regval | (0xc000b1c0 & mackerel_read_addr_32(_dev->base, 0x178)));
    // No read of register shadow required
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
    // No shadow register to write to
}

static inline void e1000_txcw_txcw_hd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txcw_txcw_hd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_txcw_t _regval = 0x40 & (((e1000_txcw_t )(_fieldval)) << 6);
    _regval = (_regval | (0xc000b1a0 & mackerel_read_addr_32(_dev->base, 0x178)));
    // No read of register shadow required
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
    // No shadow register to write to
}

static inline void e1000_txcw_txcw_pause_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txcw_txcw_pause_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_txcw_t _regval = 0x180 & (((e1000_txcw_t )(_fieldval)) << 7);
    _regval = (_regval | (0xc000b060 & mackerel_read_addr_32(_dev->base, 0x178)));
    // No read of register shadow required
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
    // No shadow register to write to
}

static inline void e1000_txcw_txcw_rfi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txcw_txcw_rfi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_txcw_t _regval = 0x3000 & (((e1000_txcw_t )(_fieldval)) << 12);
    _regval = (_regval | (0xc00081e0 & mackerel_read_addr_32(_dev->base, 0x178)));
    // No read of register shadow required
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
    // No shadow register to write to
}

static inline void e1000_txcw_txcw_npr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txcw_txcw_npr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_txcw_t _regval = 0x8000 & (((e1000_txcw_t )(_fieldval)) << 15);
    _regval = (_regval | (0xc00031e0 & mackerel_read_addr_32(_dev->base, 0x178)));
    // No read of register shadow required
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
    // No shadow register to write to
}

static inline void e1000_txcw_txconfig_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txcw_txconfig_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_txcw_t _regval = 0x40000000 & (((e1000_txcw_t )(_fieldval)) << 30);
    _regval = (_regval | (0x8000b1e0 & mackerel_read_addr_32(_dev->base, 0x178)));
    // No read of register shadow required
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
    // No shadow register to write to
}

static inline void e1000_txcw_ane_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txcw_ane_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_txcw_t _regval = 0x80000000 & (((e1000_txcw_t )(_fieldval)) << 31);
    _regval = (_regval | (0x4000b1e0 & mackerel_read_addr_32(_dev->base, 0x178)));
    // No read of register shadow required
    _regval = (_regval & 0xc000b1e0);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x178, _regval);
    // No shadow register to write to
}

/*
 * Register rxcw: Receive config word
 * Type: e1000.rxcw (Implicit type of Receive config word register)
 *   _anon0	(size 5, offset 0, init 0):	MBZ	_
 *   rxcw_fd	(size 1, offset 5, init 0):	RO	RXCW full-duplex
 *   rxcw_hd	(size 1, offset 6, init 0):	RO	RXCW half-duplex
 *   rxcw_pause	(size 2, offset 7, init 0):	RO	RXCW pause
 *   _anon9	(size 3, offset 9, init 0):	MBZ	_
 *   rxcw_rfi	(size 2, offset 12, init 0):	RO	RXCW remote fault indication
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   rxcw_npr	(size 1, offset 15, init 0):	RO	RXCW next page request
 *   _anon16	(size 10, offset 16, init 0):	MBZ	_
 *   nc	(size 1, offset 26, init 0):	RO	Carrier sense indicator
 *   inv	(size 1, offset 27, init 0):	RO	Invalid symbol during config process
 *   chg	(size 1, offset 28, init 0):	RO	Change to RXCW indication
 *   rxconfig	(size 1, offset 29, init 0):	RO	Reception indication
 *   sync	(size 1, offset 30, init 0):	RO	Lost bit sync indication
 *   anc	(size 1, offset 31, init 0):	RO	Auto-negotiation complete
 */
static inline e1000_rxcw_t e1000_rxcw_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline e1000_rxcw_t e1000_rxcw_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rxcw_t e1000_rxcw_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x180));
}

static inline void e1000_rxcw_rawwr(__DN(t) *_dev, e1000_rxcw_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxcw_rawwr(__DN(t) *_dev, e1000_rxcw_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x180, _regval);
}

// Register rxcw is not writeable
static inline int e1000_rxcw_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rxcw_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxcw (Receive config word): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_fd =\t%" PRIx8 "\t(RXCW full-duplex)\n", e1000_rxcw_rxcw_fd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_hd =\t%" PRIx8 "\t(RXCW half-duplex)\n", e1000_rxcw_rxcw_hd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_pause =\t%" PRIx8 "\t(RXCW pause)\n", e1000_rxcw_rxcw_pause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_rfi =\t%" PRIx8 "\t(RXCW remote fault indication)\n", e1000_rxcw_rxcw_rfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcw_npr =\t%" PRIx8 "\t(RXCW next page request)\n", e1000_rxcw_rxcw_npr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nc =\t%" PRIx8 "\t(Carrier sense indicator)\n", e1000_rxcw_nc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " inv =\t%" PRIx8 "\t(Invalid symbol during config process)\n", e1000_rxcw_inv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " chg =\t%" PRIx8 "\t(Change to RXCW indication)\n", e1000_rxcw_chg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxconfig =\t%" PRIx8 "\t(Reception indication)\n", e1000_rxcw_rxconfig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sync =\t%" PRIx8 "\t(Lost bit sync indication)\n", e1000_rxcw_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anc =\t%" PRIx8 "\t(Auto-negotiation complete)\n", e1000_rxcw_anc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_rxcw_rxcw_fd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_fd_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_rxcw_fd_extract(_regval));
}

static inline uint8_t e1000_rxcw_rxcw_hd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_hd_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_rxcw_hd_extract(_regval));
}

static inline uint8_t e1000_rxcw_rxcw_pause_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_pause_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_rxcw_pause_extract(_regval));
}

static inline uint8_t e1000_rxcw_rxcw_rfi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_rfi_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_rxcw_rfi_extract(_regval));
}

static inline uint8_t e1000_rxcw_rxcw_npr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxcw_npr_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_rxcw_npr_extract(_regval));
}

static inline uint8_t e1000_rxcw_nc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_nc_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_nc_extract(_regval));
}

static inline uint8_t e1000_rxcw_inv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_inv_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_inv_extract(_regval));
}

static inline uint8_t e1000_rxcw_chg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_chg_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_chg_extract(_regval));
}

static inline uint8_t e1000_rxcw_rxconfig_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_rxconfig_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_rxconfig_extract(_regval));
}

static inline uint8_t e1000_rxcw_sync_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_sync_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_sync_extract(_regval));
}

static inline uint8_t e1000_rxcw_anc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcw_anc_rdf(__DN(t) *_dev)
{
    e1000_rxcw_t _regval = mackerel_read_addr_32(_dev->base, 0x180);
    return(e1000_rxcw_anc_extract(_regval));
}

/*
 * Register ledctl: LED control
 * Type: e1000.ledctl (Implicit type of LED control register)
 *   led0_mode	(size 4, offset 0, init 0):	RW	LED0/LINK# mode
 *   _anon4	(size 1, offset 4, init 0):	MBZ	_
 *   global_blink_mode	(size 1, offset 5, init 0):	RW	Global blink mode
 *   led0_ivrt	(size 1, offset 6, init 0):	RW	LED0 invert
 *   led0_blink	(size 1, offset 7, init 0):	RW	LED0 blink
 *   led1_mode	(size 4, offset 8, init 0):	RW	LED1/LINK# mode
 *   _anon12	(size 1, offset 12, init 0):	MBZ	_
 *   led1_blink_mode	(size 1, offset 13, init 0):	RW	Global blink mode
 *   led1_ivrt	(size 1, offset 14, init 0):	RW	LED1 invert
 *   led1_blink	(size 1, offset 15, init 0):	RW	LED1 blink
 *   led2_mode	(size 4, offset 16, init 0):	RW	LED2/LINK# mode
 *   _anon20	(size 1, offset 20, init 0):	MBZ	_
 *   led2_blink_mode	(size 1, offset 21, init 0):	RW	Global blink mode
 *   led2_ivrt	(size 1, offset 22, init 0):	RW	LED2 invert
 *   led2_blink	(size 1, offset 23, init 0):	RW	LED2 blink
 *   led3_mode	(size 4, offset 24, init 0):	RW	LED3/LINK# mode
 *   _anon28	(size 1, offset 28, init 0):	MBZ	_
 *   led3_blink_mode	(size 1, offset 29, init 0):	RW	Global blink mode
 *   led3_ivrt	(size 1, offset 30, init 0):	RW	LED3 invert
 *   led3_blink	(size 1, offset 31, init 0):	RW	LED3 blink
 */
static inline e1000_ledctl_t e1000_ledctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe00));
}

static inline e1000_ledctl_t e1000_ledctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ledctl_t e1000_ledctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe00));
}

static inline void e1000_ledctl_rawwr(__DN(t) *_dev, e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_ledctl_rawwr(__DN(t) *_dev, e1000_ledctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
}

static inline void e1000_ledctl_wr(__DN(t) *_dev, e1000_ledctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_ledctl_wr(__DN(t) *_dev, e1000_ledctl_t _regval)
{
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
}

static inline int e1000_ledctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ledctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ledctl (LED control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led0_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED0/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " global_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_global_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_ivrt =\t%" PRIx8 "\t(LED0 invert)\n", e1000_ledctl_led0_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_blink =\t%" PRIx8 "\t(LED0 blink)\n", e1000_ledctl_led0_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led1_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED1/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_led1_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_ivrt =\t%" PRIx8 "\t(LED1 invert)\n", e1000_ledctl_led1_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_blink =\t%" PRIx8 "\t(LED1 blink)\n", e1000_ledctl_led1_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led2_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED2/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_led2_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_ivrt =\t%" PRIx8 "\t(LED2 invert)\n", e1000_ledctl_led2_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_blink =\t%" PRIx8 "\t(LED2 blink)\n", e1000_ledctl_led2_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledmode_prtval(_s + _r, _avail, e1000_ledctl_led3_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED3/LINK# mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_blink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_blmode_prtval(_s + _r, _avail, e1000_ledctl_led3_blink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Global blink mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_ivrt =\t%" PRIx8 "\t(LED3 invert)\n", e1000_ledctl_led3_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_blink =\t%" PRIx8 "\t(LED3 blink)\n", e1000_ledctl_led3_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline e1000_ledmode_t e1000_ledctl_led0_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led0_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led0_mode_extract(_regval));
}

static inline e1000_blmode_t e1000_ledctl_global_blink_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_global_blink_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_global_blink_mode_extract(_regval));
}

static inline uint8_t e1000_ledctl_led0_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led0_ivrt_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led0_ivrt_extract(_regval));
}

static inline uint8_t e1000_ledctl_led0_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led0_blink_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led0_blink_extract(_regval));
}

static inline e1000_ledmode_t e1000_ledctl_led1_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led1_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led1_mode_extract(_regval));
}

static inline e1000_blmode_t e1000_ledctl_led1_blink_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_led1_blink_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led1_blink_mode_extract(_regval));
}

static inline uint8_t e1000_ledctl_led1_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led1_ivrt_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led1_ivrt_extract(_regval));
}

static inline uint8_t e1000_ledctl_led1_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led1_blink_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led1_blink_extract(_regval));
}

static inline e1000_ledmode_t e1000_ledctl_led2_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led2_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led2_mode_extract(_regval));
}

static inline e1000_blmode_t e1000_ledctl_led2_blink_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_led2_blink_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led2_blink_mode_extract(_regval));
}

static inline uint8_t e1000_ledctl_led2_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led2_ivrt_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led2_ivrt_extract(_regval));
}

static inline uint8_t e1000_ledctl_led2_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led2_blink_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led2_blink_extract(_regval));
}

static inline e1000_ledmode_t e1000_ledctl_led3_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ledmode_t e1000_ledctl_led3_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led3_mode_extract(_regval));
}

static inline e1000_blmode_t e1000_ledctl_led3_blink_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_blmode_t e1000_ledctl_led3_blink_mode_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led3_blink_mode_extract(_regval));
}

static inline uint8_t e1000_ledctl_led3_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led3_ivrt_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led3_ivrt_extract(_regval));
}

static inline uint8_t e1000_ledctl_led3_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ledctl_led3_blink_rdf(__DN(t) *_dev)
{
    e1000_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0xe00);
    return(e1000_ledctl_led3_blink_extract(_regval));
}

static inline void e1000_ledctl_led0_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led0_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0xf & (((e1000_ledctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xefefefe0 & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_global_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_global_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0x20 & (((e1000_ledctl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xefefefcf & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led0_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led0_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x40 & (((e1000_ledctl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xefefefaf & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led0_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led0_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x80 & (((e1000_ledctl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xefefef6f & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led1_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led1_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0xf00 & (((e1000_ledctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xefefe0ef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led1_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led1_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0x2000 & (((e1000_ledctl_t )(_fieldval)) << 13);
    _regval = (_regval | (0xefefcfef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led1_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led1_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x4000 & (((e1000_ledctl_t )(_fieldval)) << 14);
    _regval = (_regval | (0xefefafef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led1_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led1_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x8000 & (((e1000_ledctl_t )(_fieldval)) << 15);
    _regval = (_regval | (0xefef6fef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led2_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led2_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0xf0000 & (((e1000_ledctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xefe0efef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led2_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led2_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0x200000 & (((e1000_ledctl_t )(_fieldval)) << 21);
    _regval = (_regval | (0xefcfefef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led2_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led2_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x400000 & (((e1000_ledctl_t )(_fieldval)) << 22);
    _regval = (_regval | (0xefafefef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led2_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led2_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x800000 & (((e1000_ledctl_t )(_fieldval)) << 23);
    _regval = (_regval | (0xef6fefef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led3_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led3_mode_wrf(__DN(t) *_dev, e1000_ledmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0xf000000 & (((e1000_ledctl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xe0efefef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led3_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led3_blink_mode_wrf(__DN(t) *_dev, e1000_blmode_t _fieldval)
{
    e1000_ledctl_t _regval = 0x20000000 & (((e1000_ledctl_t )(_fieldval)) << 29);
    _regval = (_regval | (0xcfefefef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led3_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led3_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x40000000 & (((e1000_ledctl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xafefefef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

static inline void e1000_ledctl_led3_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ledctl_led3_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ledctl_t _regval = 0x80000000 & (((e1000_ledctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x6fefefef & mackerel_read_addr_32(_dev->base, 0xe00)));
    // No read of register shadow required
    _regval = (_regval & 0xefefefef);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe00, _regval);
    // No shadow register to write to
}

/*
 * Register extcnf_ctrl: Extended config control
 * Type: e1000.extcnf_ctrl (Implicit type of Extended config control register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   phy_we	(size 1, offset 1, init 0):	RW	PHY write enable
 *   dud_en	(size 1, offset 2, init 0):	RW	Extended dock/undock configuration enable
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   dock_own	(size 1, offset 4, init 0):	RW	Dock config owner
 *   mdio_swown	(size 1, offset 5, init 0):	RW	MDIO software ownership
 *   mdio_hwown	(size 1, offset 6, init 0):	RW	MDIO hoftware ownership
 *   _anon7	(size 9, offset 7, init 0):	RSVD	_
 *   ecp	(size 12, offset 16, init 0):	RW	Extended configuration pointer
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf00));
}

static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_extcnf_ctrl_t e1000_extcnf_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf00));
}

static inline void e1000_extcnf_ctrl_rawwr(__DN(t) *_dev, e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_rawwr(__DN(t) *_dev, e1000_extcnf_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
}

static inline void e1000_extcnf_ctrl_wr(__DN(t) *_dev, e1000_extcnf_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_wr(__DN(t) *_dev, e1000_extcnf_ctrl_t _regval)
{
    _regval = (_regval & 0xfff0076);
    // No MB1 fields present
    _regval = (_regval | (0xf000ff88 & mackerel_read_addr_32(_dev->base, 0xf00)));
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
}

static inline int e1000_extcnf_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_extcnf_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_extcnf_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register extcnf_ctrl (Extended config control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_we =\t%" PRIx8 "\t(PHY write enable)\n", e1000_extcnf_ctrl_phy_we_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dud_en =\t%" PRIx8 "\t(Extended dock/undock configuration enable)\n", e1000_extcnf_ctrl_dud_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dock_own =\t%" PRIx8 "\t(Dock config owner)\n", e1000_extcnf_ctrl_dock_own_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdio_swown =\t%" PRIx8 "\t(MDIO software ownership)\n", e1000_extcnf_ctrl_mdio_swown_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdio_hwown =\t%" PRIx8 "\t(MDIO hoftware ownership)\n", e1000_extcnf_ctrl_mdio_hwown_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ecp =\t%" PRIx16 "\t(Extended configuration pointer)\n", e1000_extcnf_ctrl_ecp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint8_t e1000_extcnf_ctrl_phy_we_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_phy_we_rdf(__DN(t) *_dev)
{
    e1000_extcnf_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf00);
    return(e1000_extcnf_ctrl_phy_we_extract(_regval));
}

static inline uint8_t e1000_extcnf_ctrl_dud_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_dud_en_rdf(__DN(t) *_dev)
{
    e1000_extcnf_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf00);
    return(e1000_extcnf_ctrl_dud_en_extract(_regval));
}

static inline uint8_t e1000_extcnf_ctrl_dock_own_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_dock_own_rdf(__DN(t) *_dev)
{
    e1000_extcnf_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf00);
    return(e1000_extcnf_ctrl_dock_own_extract(_regval));
}

static inline uint8_t e1000_extcnf_ctrl_mdio_swown_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_mdio_swown_rdf(__DN(t) *_dev)
{
    e1000_extcnf_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf00);
    return(e1000_extcnf_ctrl_mdio_swown_extract(_regval));
}

static inline uint8_t e1000_extcnf_ctrl_mdio_hwown_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_ctrl_mdio_hwown_rdf(__DN(t) *_dev)
{
    e1000_extcnf_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf00);
    return(e1000_extcnf_ctrl_mdio_hwown_extract(_regval));
}

static inline uint16_t e1000_extcnf_ctrl_ecp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_extcnf_ctrl_ecp_rdf(__DN(t) *_dev)
{
    e1000_extcnf_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xf00);
    return(e1000_extcnf_ctrl_ecp_extract(_regval));
}

static inline void e1000_extcnf_ctrl_phy_we_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_phy_we_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_extcnf_ctrl_t _regval = 0x2 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xf00)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
    // No shadow register to write to
}

static inline void e1000_extcnf_ctrl_dud_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_dud_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_extcnf_ctrl_t _regval = 0x4 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffa & mackerel_read_addr_32(_dev->base, 0xf00)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
    // No shadow register to write to
}

static inline void e1000_extcnf_ctrl_dock_own_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_dock_own_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_extcnf_ctrl_t _regval = 0x10 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffee & mackerel_read_addr_32(_dev->base, 0xf00)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
    // No shadow register to write to
}

static inline void e1000_extcnf_ctrl_mdio_swown_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_mdio_swown_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_extcnf_ctrl_t _regval = 0x20 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffde & mackerel_read_addr_32(_dev->base, 0xf00)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
    // No shadow register to write to
}

static inline void e1000_extcnf_ctrl_mdio_hwown_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_mdio_hwown_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_extcnf_ctrl_t _regval = 0x40 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbe & mackerel_read_addr_32(_dev->base, 0xf00)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
    // No shadow register to write to
}

static inline void e1000_extcnf_ctrl_ecp_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_ctrl_ecp_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_extcnf_ctrl_t _regval = 0xfff0000 & (((e1000_extcnf_ctrl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf000fffe & mackerel_read_addr_32(_dev->base, 0xf00)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf00, _regval);
    // No shadow register to write to
}

/*
 * Register extcnf_size: Extended config size
 * Type: e1000.extcnf_size (Implicit type of Extended config size register)
 *   phy_len	(size 8, offset 0, init 0):	RW	Extended PHY configuration area length
 *   dock_len	(size 8, offset 8, init 0):	RW	Extended dock configuration area length
 *   _anon16	(size 8, offset 16, init 0):	MBZ	_
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline e1000_extcnf_size_t e1000_extcnf_size_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_extcnf_size_t e1000_extcnf_size_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf08));
}

static inline e1000_extcnf_size_t e1000_extcnf_size_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_extcnf_size_t e1000_extcnf_size_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf08));
}

static inline void e1000_extcnf_size_rawwr(__DN(t) *_dev, e1000_extcnf_size_t _regval) __attribute__ ((always_inline));
static inline void e1000_extcnf_size_rawwr(__DN(t) *_dev, e1000_extcnf_size_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf08, _regval);
}

static inline void e1000_extcnf_size_wr(__DN(t) *_dev, e1000_extcnf_size_t _regval) __attribute__ ((always_inline));
static inline void e1000_extcnf_size_wr(__DN(t) *_dev, e1000_extcnf_size_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xff000000 & mackerel_read_addr_32(_dev->base, 0xf08)));
    mackerel_write_addr_32(_dev->base, 0xf08, _regval);
}

static inline int e1000_extcnf_size_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_extcnf_size_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_extcnf_size_t _regval = mackerel_read_addr_32(_dev->base, 0xf08);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register extcnf_size (Extended config size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phy_len =\t%" PRIx8 "\t(Extended PHY configuration area length)\n", e1000_extcnf_size_phy_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dock_len =\t%" PRIx8 "\t(Extended dock configuration area length)\n", e1000_extcnf_size_dock_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t e1000_extcnf_size_phy_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_size_phy_len_rdf(__DN(t) *_dev)
{
    e1000_extcnf_size_t _regval = mackerel_read_addr_32(_dev->base, 0xf08);
    return(e1000_extcnf_size_phy_len_extract(_regval));
}

static inline uint8_t e1000_extcnf_size_dock_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_extcnf_size_dock_len_rdf(__DN(t) *_dev)
{
    e1000_extcnf_size_t _regval = mackerel_read_addr_32(_dev->base, 0xf08);
    return(e1000_extcnf_size_dock_len_extract(_regval));
}

static inline void e1000_extcnf_size_phy_len_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_size_phy_len_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_extcnf_size_t _regval = 0xff & (((e1000_extcnf_size_t )(_fieldval)) << 0);
    _regval = (_regval | (0xff00ff00 & mackerel_read_addr_32(_dev->base, 0xf08)));
    // No read of register shadow required
    _regval = (_regval & 0xff00ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf08, _regval);
    // No shadow register to write to
}

static inline void e1000_extcnf_size_dock_len_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_extcnf_size_dock_len_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_extcnf_size_t _regval = 0xff00 & (((e1000_extcnf_size_t )(_fieldval)) << 8);
    _regval = (_regval | (0xff0000ff & mackerel_read_addr_32(_dev->base, 0xf08)));
    // No read of register shadow required
    _regval = (_regval & 0xff00ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf08, _regval);
    // No shadow register to write to
}

/*
 * Register pba: Packet buffer allocation
 * Type: e1000.pba (Implicit type of Packet buffer allocation register)
 *   rxa	(size 16, offset 0, init 0):	RW	Rx packet buffer allocation in KB
 *   txa	(size 16, offset 16, init 0):	RW	Tx packet buffer allocation in KB
 */
static inline e1000_pba_t e1000_pba_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_pba_t e1000_pba_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1000));
}

static inline e1000_pba_t e1000_pba_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_pba_t e1000_pba_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1000));
}

static inline void e1000_pba_rawwr(__DN(t) *_dev, e1000_pba_t _regval) __attribute__ ((always_inline));
static inline void e1000_pba_rawwr(__DN(t) *_dev, e1000_pba_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1000, _regval);
}

static inline void e1000_pba_wr(__DN(t) *_dev, e1000_pba_t _regval) __attribute__ ((always_inline));
static inline void e1000_pba_wr(__DN(t) *_dev, e1000_pba_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1000, _regval);
}

static inline int e1000_pba_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_pba_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_pba_t _regval = mackerel_read_addr_32(_dev->base, 0x1000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pba (Packet buffer allocation): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxa =\t%" PRIx16 "\t(Rx packet buffer allocation in KB)\n", e1000_pba_rxa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txa =\t%" PRIx16 "\t(Tx packet buffer allocation in KB)\n", e1000_pba_txa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e1000_pba_rxa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_pba_rxa_rdf(__DN(t) *_dev)
{
    e1000_pba_t _regval = mackerel_read_addr_32(_dev->base, 0x1000);
    return(e1000_pba_rxa_extract(_regval));
}

static inline uint16_t e1000_pba_txa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_pba_txa_rdf(__DN(t) *_dev)
{
    e1000_pba_t _regval = mackerel_read_addr_32(_dev->base, 0x1000);
    return(e1000_pba_txa_extract(_regval));
}

static inline void e1000_pba_rxa_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_pba_rxa_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_pba_t _regval = 0xffff & (((e1000_pba_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x1000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1000, _regval);
    // No shadow register to write to
}

static inline void e1000_pba_txa_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_pba_txa_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_pba_t _regval = 0xffff0000 & (((e1000_pba_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x1000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1000, _regval);
    // No shadow register to write to
}

/*
 * Register eemngctl: MNG EEPROM control
 * Type: e1000.eemngctl (Implicit type of MNG EEPROM control register)
 *   _anon0	(size 18, offset 0, init 0):	RSVD	_
 *   crg_done	(size 1, offset 18, init 0):	RW	MNG configuration cycle done
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
static inline e1000_eemngctl_t e1000_eemngctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eemngctl_t e1000_eemngctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1010));
}

static inline e1000_eemngctl_t e1000_eemngctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_eemngctl_t e1000_eemngctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1010));
}

static inline void e1000_eemngctl_rawwr(__DN(t) *_dev, e1000_eemngctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_eemngctl_rawwr(__DN(t) *_dev, e1000_eemngctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1010, _regval);
}

static inline void e1000_eemngctl_wr(__DN(t) *_dev, e1000_eemngctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_eemngctl_wr(__DN(t) *_dev, e1000_eemngctl_t _regval)
{
    _regval = (_regval & 0x40000);
    // No MB1 fields present
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x1010)));
    mackerel_write_addr_32(_dev->base, 0x1010, _regval);
}

static inline int e1000_eemngctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_eemngctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1010);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eemngctl (MNG EEPROM control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crg_done =\t%" PRIx8 "\t(MNG configuration cycle done)\n", e1000_eemngctl_crg_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline uint8_t e1000_eemngctl_crg_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_eemngctl_crg_done_rdf(__DN(t) *_dev)
{
    e1000_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1010);
    return(e1000_eemngctl_crg_done_extract(_regval));
}

static inline void e1000_eemngctl_crg_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eemngctl_crg_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_eemngctl_t _regval = 0x40000 & (((e1000_eemngctl_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x1010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1010, _regval);
    // No shadow register to write to
}

/*
 * Register sw_fw_sync: Software/firmware sync
 * Type: e1000.sw_fw_sync (Implicit type of Software/firmware sync register)
 *   sw_eep_sm	(size 1, offset 0, init 0):	RW	EEPROM access owned by software
 *   sw_phy_sm0	(size 1, offset 1, init 0):	RW	PHY 0 access owned by software
 *   sw_phy_sm1	(size 1, offset 2, init 0):	RW	PHY 1 access owned by software
 *   sw_mac_csr_sm	(size 1, offset 3, init 0):	RW	Shared CSR access owned by software
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   fw_eep_sm	(size 1, offset 16, init 0):	RW	EEPROM access owned by firmware
 *   fw_phy_sm0	(size 1, offset 17, init 0):	RW	PHY 0 access owned by firmware
 *   fw_phy_sm1	(size 1, offset 18, init 0):	RW	PHY 1 access owned by firmware
 *   fw_mac_csr_sm	(size 1, offset 19, init 0):	RW	Shared CSR access owned by firmware
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b5c));
}

static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_sw_fw_sync_t e1000_sw_fw_sync_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b5c));
}

static inline void e1000_sw_fw_sync_rawwr(__DN(t) *_dev, e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_rawwr(__DN(t) *_dev, e1000_sw_fw_sync_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
}

static inline void e1000_sw_fw_sync_wr(__DN(t) *_dev, e1000_sw_fw_sync_t _regval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_wr(__DN(t) *_dev, e1000_sw_fw_sync_t _regval)
{
    _regval = (_regval & 0xf000f);
    // No MB1 fields present
    _regval = (_regval | (0xfff0fff0 & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
}

static inline int e1000_sw_fw_sync_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_sw_fw_sync_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sw_fw_sync (Software/firmware sync): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_eep_sm =\t%" PRIx8 "\t(EEPROM access owned by software)\n", e1000_sw_fw_sync_sw_eep_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_phy_sm0 =\t%" PRIx8 "\t(PHY 0 access owned by software)\n", e1000_sw_fw_sync_sw_phy_sm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_phy_sm1 =\t%" PRIx8 "\t(PHY 1 access owned by software)\n", e1000_sw_fw_sync_sw_phy_sm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_mac_csr_sm =\t%" PRIx8 "\t(Shared CSR access owned by software)\n", e1000_sw_fw_sync_sw_mac_csr_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_eep_sm =\t%" PRIx8 "\t(EEPROM access owned by firmware)\n", e1000_sw_fw_sync_fw_eep_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_phy_sm0 =\t%" PRIx8 "\t(PHY 0 access owned by firmware)\n", e1000_sw_fw_sync_fw_phy_sm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_phy_sm1 =\t%" PRIx8 "\t(PHY 1 access owned by firmware)\n", e1000_sw_fw_sync_fw_phy_sm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_mac_csr_sm =\t%" PRIx8 "\t(Shared CSR access owned by firmware)\n", e1000_sw_fw_sync_fw_mac_csr_sm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t e1000_sw_fw_sync_sw_eep_sm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_eep_sm_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_sw_eep_sm_extract(_regval));
}

static inline uint8_t e1000_sw_fw_sync_sw_phy_sm0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_phy_sm0_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_sw_phy_sm0_extract(_regval));
}

static inline uint8_t e1000_sw_fw_sync_sw_phy_sm1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_phy_sm1_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_sw_phy_sm1_extract(_regval));
}

static inline uint8_t e1000_sw_fw_sync_sw_mac_csr_sm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_sw_mac_csr_sm_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_sw_mac_csr_sm_extract(_regval));
}

static inline uint8_t e1000_sw_fw_sync_fw_eep_sm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_eep_sm_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_fw_eep_sm_extract(_regval));
}

static inline uint8_t e1000_sw_fw_sync_fw_phy_sm0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_phy_sm0_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_fw_phy_sm0_extract(_regval));
}

static inline uint8_t e1000_sw_fw_sync_fw_phy_sm1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_phy_sm1_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_fw_phy_sm1_extract(_regval));
}

static inline uint8_t e1000_sw_fw_sync_fw_mac_csr_sm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_sw_fw_sync_fw_mac_csr_sm_rdf(__DN(t) *_dev)
{
    e1000_sw_fw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x5b5c);
    return(e1000_sw_fw_sync_fw_mac_csr_sm_extract(_regval));
}

static inline void e1000_sw_fw_sync_sw_eep_sm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_sw_eep_sm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x1 & (((e1000_sw_fw_sync_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

static inline void e1000_sw_fw_sync_sw_phy_sm0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_sw_phy_sm0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x2 & (((e1000_sw_fw_sync_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

static inline void e1000_sw_fw_sync_sw_phy_sm1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_sw_phy_sm1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x4 & (((e1000_sw_fw_sync_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

static inline void e1000_sw_fw_sync_sw_mac_csr_sm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_sw_mac_csr_sm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x8 & (((e1000_sw_fw_sync_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

static inline void e1000_sw_fw_sync_fw_eep_sm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_fw_eep_sm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x10000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

static inline void e1000_sw_fw_sync_fw_phy_sm0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_fw_phy_sm0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x20000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

static inline void e1000_sw_fw_sync_fw_phy_sm1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_fw_phy_sm1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x40000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

static inline void e1000_sw_fw_sync_fw_mac_csr_sm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_sw_fw_sync_fw_mac_csr_sm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_sw_fw_sync_t _regval = 0x80000 & (((e1000_sw_fw_sync_t )(_fieldval)) << 19);
    _regval = (_regval | (0xfff7ffff & mackerel_read_addr_32(_dev->base, 0x5b5c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b5c, _regval);
    // No shadow register to write to
}

/*
 * Register icr: Interrupt cause read
 * Type: e1000.intreg (Interrupt register format)
 *   txdw	(size 1, offset 0, init 0):	RO	Transmit descriptor written back
 *   txqe	(size 1, offset 1, init 0):	RO	Transmit queue empty
 *   lsc	(size 1, offset 2, init 0):	RO	Link status change
 *   rxseq	(size 1, offset 3, init 0):	RO	Receive sequence error
 *   rxdmt0	(size 1, offset 4, init 0):	RO	Receive descriptor minimum threshold reached
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   rxo	(size 1, offset 6, init 0):	RO	Receiver overrun
 *   rxt0	(size 1, offset 7, init 0):	RO	Receiver timer interrupt
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   mdac	(size 1, offset 9, init 0):	RO	MDI/O access complete
 *   rxcfg	(size 1, offset 10, init 0):	RO	Received configuration symbols
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   gpi_sdp2	(size 1, offset 13, init 0):	RO	General-purpose interrupt on SPD2
 *   gpi_sdp3	(size 1, offset 14, init 0):	RO	General-purpose interrupt on SPD3
 *   txd_low	(size 1, offset 15, init 0):	RO	Transmit descriptor low threshold
 *   srpd	(size 1, offset 16, init 0):	RO	Small receive packet detected
 *   ack	(size 1, offset 17, init 0):	RO	Receive ack frame detected
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   rx_desc_fifo_par0	(size 1, offset 20, init 0):	RO	Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0	(size 1, offset 21, init 0):	RO	Tx descriptor FIFO parity error 0
 *   pcie_master_par	(size 1, offset 22, init 0):	RO	PCIe master data FIFO parity error
 *   pbpar	(size 1, offset 23, init 0):	RO	Packet buffer parity error
 *   rx_desc_fifo_par1	(size 1, offset 24, init 0):	RO	Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1	(size 1, offset 25, init 0):	RO	Tx descriptor FIFO parity error 1
 *   _anon26	(size 5, offset 26, init 0):	RSVD	_
 *   int_asserted	(size 1, offset 31, init 0):	RO	Interrupt asserted
 */
static inline e1000_intreg_t e1000_icr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_icr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc0));
}

static inline e1000_intreg_t e1000_icr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_icr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc0));
}

static inline void e1000_icr_rawwr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_icr_rawwr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc0, _regval);
}

// Register icr is not writeable
static inline int e1000_icr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_icr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register icr (Interrupt cause read): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdw =\t%" PRIx8 "\t(Transmit descriptor written back)\n", e1000_intreg_txdw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txqe =\t%" PRIx8 "\t(Transmit queue empty)\n", e1000_intreg_txqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link status change)\n", e1000_intreg_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxseq =\t%" PRIx8 "\t(Receive sequence error)\n", e1000_intreg_rxseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmt0 =\t%" PRIx8 "\t(Receive descriptor minimum threshold reached)\n", e1000_intreg_rxdmt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxo =\t%" PRIx8 "\t(Receiver overrun)\n", e1000_intreg_rxo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxt0 =\t%" PRIx8 "\t(Receiver timer interrupt)\n", e1000_intreg_rxt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdac =\t%" PRIx8 "\t(MDI/O access complete)\n", e1000_intreg_mdac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcfg =\t%" PRIx8 "\t(Received configuration symbols)\n", e1000_intreg_rxcfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp2 =\t%" PRIx8 "\t(General-purpose interrupt on SPD2)\n", e1000_intreg_gpi_sdp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp3 =\t%" PRIx8 "\t(General-purpose interrupt on SPD3)\n", e1000_intreg_gpi_sdp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_low =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_intreg_txd_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srpd =\t%" PRIx8 "\t(Small receive packet detected)\n", e1000_intreg_srpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(Receive ack frame detected)\n", e1000_intreg_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par0 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 0)\n", e1000_intreg_rx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par0 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 0)\n", e1000_intreg_tx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_master_par =\t%" PRIx8 "\t(PCIe master data FIFO parity error)\n", e1000_intreg_pcie_master_par_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pbpar =\t%" PRIx8 "\t(Packet buffer parity error)\n", e1000_intreg_pbpar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par1 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 1)\n", e1000_intreg_rx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par1 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 1)\n", e1000_intreg_tx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_asserted =\t%" PRIx8 "\t(Interrupt asserted)\n", e1000_intreg_int_asserted_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_icr_txdw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_txdw_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_txdw_extract(_regval));
}

static inline uint8_t e1000_icr_txqe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_txqe_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_txqe_extract(_regval));
}

static inline uint8_t e1000_icr_lsc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_lsc_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_lsc_extract(_regval));
}

static inline uint8_t e1000_icr_rxseq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_rxseq_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_rxseq_extract(_regval));
}

static inline uint8_t e1000_icr_rxdmt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_rxdmt0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_rxdmt0_extract(_regval));
}

static inline uint8_t e1000_icr_rxo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_rxo_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_rxo_extract(_regval));
}

static inline uint8_t e1000_icr_rxt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_rxt0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_rxt0_extract(_regval));
}

static inline uint8_t e1000_icr_mdac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_mdac_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_mdac_extract(_regval));
}

static inline uint8_t e1000_icr_rxcfg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_rxcfg_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_rxcfg_extract(_regval));
}

static inline uint8_t e1000_icr_gpi_sdp2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_gpi_sdp2_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_gpi_sdp2_extract(_regval));
}

static inline uint8_t e1000_icr_gpi_sdp3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_gpi_sdp3_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_gpi_sdp3_extract(_regval));
}

static inline uint8_t e1000_icr_txd_low_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_txd_low_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_txd_low_extract(_regval));
}

static inline uint8_t e1000_icr_srpd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_srpd_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_srpd_extract(_regval));
}

static inline uint8_t e1000_icr_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_ack_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_ack_extract(_regval));
}

static inline uint8_t e1000_icr_rx_desc_fifo_par0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_rx_desc_fifo_par0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_rx_desc_fifo_par0_extract(_regval));
}

static inline uint8_t e1000_icr_tx_desc_fifo_par0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_tx_desc_fifo_par0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_tx_desc_fifo_par0_extract(_regval));
}

static inline uint8_t e1000_icr_pcie_master_par_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_pcie_master_par_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_pcie_master_par_extract(_regval));
}

static inline uint8_t e1000_icr_pbpar_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_pbpar_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_pbpar_extract(_regval));
}

static inline uint8_t e1000_icr_rx_desc_fifo_par1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_rx_desc_fifo_par1_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_rx_desc_fifo_par1_extract(_regval));
}

static inline uint8_t e1000_icr_tx_desc_fifo_par1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_tx_desc_fifo_par1_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_tx_desc_fifo_par1_extract(_regval));
}

static inline uint8_t e1000_icr_int_asserted_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_icr_int_asserted_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xc0);
    return(e1000_intreg_int_asserted_extract(_regval));
}

/*
 * Register itr: Interrupt throttling rate
 * Type: e1000.itr (Implicit type of Interrupt throttling rate register)
 *   interval	(size 16, offset 0, init 0):	RW	Minimum inter-interrupt interval (x256ns)
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline e1000_itr_t e1000_itr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_itr_t e1000_itr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc4));
}

static inline e1000_itr_t e1000_itr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_itr_t e1000_itr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc4));
}

static inline void e1000_itr_rawwr(__DN(t) *_dev, e1000_itr_t _regval) __attribute__ ((always_inline));
static inline void e1000_itr_rawwr(__DN(t) *_dev, e1000_itr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc4, _regval);
}

static inline void e1000_itr_wr(__DN(t) *_dev, e1000_itr_t _regval) __attribute__ ((always_inline));
static inline void e1000_itr_wr(__DN(t) *_dev, e1000_itr_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xc4, _regval);
}

static inline int e1000_itr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_itr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_itr_t _regval = mackerel_read_addr_32(_dev->base, 0xc4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register itr (Interrupt throttling rate): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " interval =\t%" PRIx16 "\t(Minimum inter-interrupt interval (x256ns))\n", e1000_itr_interval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e1000_itr_interval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_itr_interval_rdf(__DN(t) *_dev)
{
    e1000_itr_t _regval = mackerel_read_addr_32(_dev->base, 0xc4);
    return(e1000_itr_interval_extract(_regval));
}

static inline void e1000_itr_interval_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_itr_interval_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_itr_t _regval = 0xffff & (((e1000_itr_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc4, _regval);
    // No shadow register to write to
}

/*
 * Register ics: Interrupt cause write
 * Type: e1000.intreg (Interrupt register format)
 *   txdw	(size 1, offset 0, init 0):	WO	Transmit descriptor written back
 *   txqe	(size 1, offset 1, init 0):	WO	Transmit queue empty
 *   lsc	(size 1, offset 2, init 0):	WO	Link status change
 *   rxseq	(size 1, offset 3, init 0):	WO	Receive sequence error
 *   rxdmt0	(size 1, offset 4, init 0):	WO	Receive descriptor minimum threshold reached
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   rxo	(size 1, offset 6, init 0):	WO	Receiver overrun
 *   rxt0	(size 1, offset 7, init 0):	WO	Receiver timer interrupt
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   mdac	(size 1, offset 9, init 0):	WO	MDI/O access complete
 *   rxcfg	(size 1, offset 10, init 0):	WO	Received configuration symbols
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   gpi_sdp2	(size 1, offset 13, init 0):	WO	General-purpose interrupt on SPD2
 *   gpi_sdp3	(size 1, offset 14, init 0):	WO	General-purpose interrupt on SPD3
 *   txd_low	(size 1, offset 15, init 0):	WO	Transmit descriptor low threshold
 *   srpd	(size 1, offset 16, init 0):	WO	Small receive packet detected
 *   ack	(size 1, offset 17, init 0):	WO	Receive ack frame detected
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   rx_desc_fifo_par0	(size 1, offset 20, init 0):	WO	Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0	(size 1, offset 21, init 0):	WO	Tx descriptor FIFO parity error 0
 *   pcie_master_par	(size 1, offset 22, init 0):	WO	PCIe master data FIFO parity error
 *   pbpar	(size 1, offset 23, init 0):	WO	Packet buffer parity error
 *   rx_desc_fifo_par1	(size 1, offset 24, init 0):	WO	Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1	(size 1, offset 25, init 0):	WO	Tx descriptor FIFO parity error 1
 *   _anon26	(size 5, offset 26, init 0):	RSVD	_
 *   int_asserted	(size 1, offset 31, init 0):	WO	Interrupt asserted
 */
static inline e1000_intreg_t e1000_ics_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_ics_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc8));
}

static inline e1000_intreg_t e1000_ics_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_ics_rd(__DN(t) *_dev)
{
    return(_dev->ics_shadow);
}

static inline void e1000_ics_rawwr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_ics_rawwr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
}

static inline void e1000_ics_wr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_ics_wr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    _regval = (_regval & 0x83f3e6df);
    // No MB1 fields present
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
}

static inline int e1000_ics_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ics_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_intreg_t _regval = _dev->ics_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ics (Interrupt cause write): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdw =\t%" PRIx8 "\t(Transmit descriptor written back)\n", e1000_intreg_txdw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txqe =\t%" PRIx8 "\t(Transmit queue empty)\n", e1000_intreg_txqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link status change)\n", e1000_intreg_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxseq =\t%" PRIx8 "\t(Receive sequence error)\n", e1000_intreg_rxseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmt0 =\t%" PRIx8 "\t(Receive descriptor minimum threshold reached)\n", e1000_intreg_rxdmt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxo =\t%" PRIx8 "\t(Receiver overrun)\n", e1000_intreg_rxo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxt0 =\t%" PRIx8 "\t(Receiver timer interrupt)\n", e1000_intreg_rxt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdac =\t%" PRIx8 "\t(MDI/O access complete)\n", e1000_intreg_mdac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcfg =\t%" PRIx8 "\t(Received configuration symbols)\n", e1000_intreg_rxcfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp2 =\t%" PRIx8 "\t(General-purpose interrupt on SPD2)\n", e1000_intreg_gpi_sdp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp3 =\t%" PRIx8 "\t(General-purpose interrupt on SPD3)\n", e1000_intreg_gpi_sdp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_low =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_intreg_txd_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srpd =\t%" PRIx8 "\t(Small receive packet detected)\n", e1000_intreg_srpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(Receive ack frame detected)\n", e1000_intreg_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par0 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 0)\n", e1000_intreg_rx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par0 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 0)\n", e1000_intreg_tx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_master_par =\t%" PRIx8 "\t(PCIe master data FIFO parity error)\n", e1000_intreg_pcie_master_par_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pbpar =\t%" PRIx8 "\t(Packet buffer parity error)\n", e1000_intreg_pbpar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par1 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 1)\n", e1000_intreg_rx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par1 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 1)\n", e1000_intreg_tx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_asserted =\t%" PRIx8 "\t(Interrupt asserted)\n", e1000_intreg_int_asserted_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_ics_txdw_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_txdw_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_txdw_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_txqe_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_txqe_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_txqe_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_lsc_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_lsc_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_lsc_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_rxseq_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_rxseq_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxseq_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_rxdmt0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_rxdmt0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxdmt0_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_rxo_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_rxo_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxo_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_rxt0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_rxt0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxt0_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_mdac_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_mdac_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_mdac_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_rxcfg_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_rxcfg_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxcfg_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_gpi_sdp2_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_gpi_sdp2_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_gpi_sdp2_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_gpi_sdp3_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_gpi_sdp3_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_gpi_sdp3_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_txd_low_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_txd_low_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_txd_low_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_srpd_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_srpd_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_srpd_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_ack_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_ack_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_ack_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_rx_desc_fifo_par0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_rx_desc_fifo_par0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rx_desc_fifo_par0_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_tx_desc_fifo_par0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_tx_desc_fifo_par0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_tx_desc_fifo_par0_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_pcie_master_par_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_pcie_master_par_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_pcie_master_par_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_pbpar_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_pbpar_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_pbpar_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_rx_desc_fifo_par1_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_rx_desc_fifo_par1_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rx_desc_fifo_par1_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_tx_desc_fifo_par1_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_tx_desc_fifo_par1_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_tx_desc_fifo_par1_extract(_dev->ics_shadow));
}

static inline uint8_t e1000_ics_int_asserted_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ics_int_asserted_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_int_asserted_extract(_dev->ics_shadow));
}

static inline void e1000_ics_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1 & (((e1000_intreg_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e6de & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2 & (((e1000_intreg_t )(_fieldval)) << 1);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e6dd & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4 & (((e1000_intreg_t )(_fieldval)) << 2);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e6db & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8 & (((e1000_intreg_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e6d7 & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10 & (((e1000_intreg_t )(_fieldval)) << 4);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e6cf & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x40 & (((e1000_intreg_t )(_fieldval)) << 6);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e69f & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80 & (((e1000_intreg_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e65f & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200 & (((e1000_intreg_t )(_fieldval)) << 9);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e4df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400 & (((e1000_intreg_t )(_fieldval)) << 10);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3e2df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000 & (((e1000_intreg_t )(_fieldval)) << 13);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3c6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4000 & (((e1000_intreg_t )(_fieldval)) << 14);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f3a6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8000 & (((e1000_intreg_t )(_fieldval)) << 15);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f366df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10000 & (((e1000_intreg_t )(_fieldval)) << 16);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f2e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_ack_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_ack_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x20000 & (((e1000_intreg_t )(_fieldval)) << 17);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83f1e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x100000 & (((e1000_intreg_t )(_fieldval)) << 20);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83e3e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200000 & (((e1000_intreg_t )(_fieldval)) << 21);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83d3e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400000 & (((e1000_intreg_t )(_fieldval)) << 22);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x83b3e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x800000 & (((e1000_intreg_t )(_fieldval)) << 23);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x8373e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1000000 & (((e1000_intreg_t )(_fieldval)) << 24);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x82f3e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000000 & (((e1000_intreg_t )(_fieldval)) << 25);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x81f3e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

static inline void e1000_ics_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ics_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80000000 & (((e1000_intreg_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xc8)));
    _regval = (_regval | (0x3f3e6df & (_dev->ics_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc8, _regval);
    _dev->ics_shadow = _regval;
}

/*
 * Register ims: Interrupt mask set/read
 * Type: e1000.intreg (Interrupt register format)
 *   txdw	(size 1, offset 0, init 0):	RW	Transmit descriptor written back
 *   txqe	(size 1, offset 1, init 0):	RW	Transmit queue empty
 *   lsc	(size 1, offset 2, init 0):	RW	Link status change
 *   rxseq	(size 1, offset 3, init 0):	RW	Receive sequence error
 *   rxdmt0	(size 1, offset 4, init 0):	RW	Receive descriptor minimum threshold reached
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   rxo	(size 1, offset 6, init 0):	RW	Receiver overrun
 *   rxt0	(size 1, offset 7, init 0):	RW	Receiver timer interrupt
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   mdac	(size 1, offset 9, init 0):	RW	MDI/O access complete
 *   rxcfg	(size 1, offset 10, init 0):	RW	Received configuration symbols
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   gpi_sdp2	(size 1, offset 13, init 0):	RW	General-purpose interrupt on SPD2
 *   gpi_sdp3	(size 1, offset 14, init 0):	RW	General-purpose interrupt on SPD3
 *   txd_low	(size 1, offset 15, init 0):	RW	Transmit descriptor low threshold
 *   srpd	(size 1, offset 16, init 0):	RW	Small receive packet detected
 *   ack	(size 1, offset 17, init 0):	RW	Receive ack frame detected
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   rx_desc_fifo_par0	(size 1, offset 20, init 0):	RW	Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0	(size 1, offset 21, init 0):	RW	Tx descriptor FIFO parity error 0
 *   pcie_master_par	(size 1, offset 22, init 0):	RW	PCIe master data FIFO parity error
 *   pbpar	(size 1, offset 23, init 0):	RW	Packet buffer parity error
 *   rx_desc_fifo_par1	(size 1, offset 24, init 0):	RW	Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1	(size 1, offset 25, init 0):	RW	Tx descriptor FIFO parity error 1
 *   _anon26	(size 5, offset 26, init 0):	RSVD	_
 *   int_asserted	(size 1, offset 31, init 0):	RW	Interrupt asserted
 */
static inline e1000_intreg_t e1000_ims_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_ims_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline e1000_intreg_t e1000_ims_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_ims_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline void e1000_ims_rawwr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_ims_rawwr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
}

static inline void e1000_ims_wr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_ims_wr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    _regval = (_regval & 0x83f3e6df);
    // No MB1 fields present
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd0)));
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
}

static inline int e1000_ims_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ims_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ims (Interrupt mask set/read): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdw =\t%" PRIx8 "\t(Transmit descriptor written back)\n", e1000_intreg_txdw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txqe =\t%" PRIx8 "\t(Transmit queue empty)\n", e1000_intreg_txqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link status change)\n", e1000_intreg_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxseq =\t%" PRIx8 "\t(Receive sequence error)\n", e1000_intreg_rxseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmt0 =\t%" PRIx8 "\t(Receive descriptor minimum threshold reached)\n", e1000_intreg_rxdmt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxo =\t%" PRIx8 "\t(Receiver overrun)\n", e1000_intreg_rxo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxt0 =\t%" PRIx8 "\t(Receiver timer interrupt)\n", e1000_intreg_rxt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdac =\t%" PRIx8 "\t(MDI/O access complete)\n", e1000_intreg_mdac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcfg =\t%" PRIx8 "\t(Received configuration symbols)\n", e1000_intreg_rxcfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp2 =\t%" PRIx8 "\t(General-purpose interrupt on SPD2)\n", e1000_intreg_gpi_sdp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp3 =\t%" PRIx8 "\t(General-purpose interrupt on SPD3)\n", e1000_intreg_gpi_sdp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_low =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_intreg_txd_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srpd =\t%" PRIx8 "\t(Small receive packet detected)\n", e1000_intreg_srpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(Receive ack frame detected)\n", e1000_intreg_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par0 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 0)\n", e1000_intreg_rx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par0 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 0)\n", e1000_intreg_tx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_master_par =\t%" PRIx8 "\t(PCIe master data FIFO parity error)\n", e1000_intreg_pcie_master_par_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pbpar =\t%" PRIx8 "\t(Packet buffer parity error)\n", e1000_intreg_pbpar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par1 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 1)\n", e1000_intreg_rx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par1 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 1)\n", e1000_intreg_tx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_asserted =\t%" PRIx8 "\t(Interrupt asserted)\n", e1000_intreg_int_asserted_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_ims_txdw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_txdw_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_txdw_extract(_regval));
}

static inline uint8_t e1000_ims_txqe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_txqe_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_txqe_extract(_regval));
}

static inline uint8_t e1000_ims_lsc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_lsc_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_lsc_extract(_regval));
}

static inline uint8_t e1000_ims_rxseq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_rxseq_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_rxseq_extract(_regval));
}

static inline uint8_t e1000_ims_rxdmt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_rxdmt0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_rxdmt0_extract(_regval));
}

static inline uint8_t e1000_ims_rxo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_rxo_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_rxo_extract(_regval));
}

static inline uint8_t e1000_ims_rxt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_rxt0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_rxt0_extract(_regval));
}

static inline uint8_t e1000_ims_mdac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_mdac_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_mdac_extract(_regval));
}

static inline uint8_t e1000_ims_rxcfg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_rxcfg_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_rxcfg_extract(_regval));
}

static inline uint8_t e1000_ims_gpi_sdp2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_gpi_sdp2_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_gpi_sdp2_extract(_regval));
}

static inline uint8_t e1000_ims_gpi_sdp3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_gpi_sdp3_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_gpi_sdp3_extract(_regval));
}

static inline uint8_t e1000_ims_txd_low_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_txd_low_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_txd_low_extract(_regval));
}

static inline uint8_t e1000_ims_srpd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_srpd_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_srpd_extract(_regval));
}

static inline uint8_t e1000_ims_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_ack_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_ack_extract(_regval));
}

static inline uint8_t e1000_ims_rx_desc_fifo_par0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_rx_desc_fifo_par0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_rx_desc_fifo_par0_extract(_regval));
}

static inline uint8_t e1000_ims_tx_desc_fifo_par0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_tx_desc_fifo_par0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_tx_desc_fifo_par0_extract(_regval));
}

static inline uint8_t e1000_ims_pcie_master_par_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_pcie_master_par_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_pcie_master_par_extract(_regval));
}

static inline uint8_t e1000_ims_pbpar_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_pbpar_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_pbpar_extract(_regval));
}

static inline uint8_t e1000_ims_rx_desc_fifo_par1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_rx_desc_fifo_par1_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_rx_desc_fifo_par1_extract(_regval));
}

static inline uint8_t e1000_ims_tx_desc_fifo_par1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_tx_desc_fifo_par1_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_tx_desc_fifo_par1_extract(_regval));
}

static inline uint8_t e1000_ims_int_asserted_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ims_int_asserted_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(e1000_intreg_int_asserted_extract(_regval));
}

static inline void e1000_ims_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1 & (((e1000_intreg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2 & (((e1000_intreg_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4 & (((e1000_intreg_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8 & (((e1000_intreg_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10 & (((e1000_intreg_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x40 & (((e1000_intreg_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80 & (((e1000_intreg_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200 & (((e1000_intreg_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400 & (((e1000_intreg_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000 & (((e1000_intreg_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4000 & (((e1000_intreg_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8000 & (((e1000_intreg_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10000 & (((e1000_intreg_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_ack_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_ack_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x20000 & (((e1000_intreg_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x100000 & (((e1000_intreg_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffefffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200000 & (((e1000_intreg_t )(_fieldval)) << 21);
    _regval = (_regval | (0xffdfffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400000 & (((e1000_intreg_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffbfffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x800000 & (((e1000_intreg_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1000000 & (((e1000_intreg_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfeffffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000000 & (((e1000_intreg_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

static inline void e1000_ims_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ims_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80000000 & (((e1000_intreg_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

/*
 * Register imc: Interrupt mask clear
 * Type: e1000.intreg (Interrupt register format)
 *   txdw	(size 1, offset 0, init 0):	WO	Transmit descriptor written back
 *   txqe	(size 1, offset 1, init 0):	WO	Transmit queue empty
 *   lsc	(size 1, offset 2, init 0):	WO	Link status change
 *   rxseq	(size 1, offset 3, init 0):	WO	Receive sequence error
 *   rxdmt0	(size 1, offset 4, init 0):	WO	Receive descriptor minimum threshold reached
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   rxo	(size 1, offset 6, init 0):	WO	Receiver overrun
 *   rxt0	(size 1, offset 7, init 0):	WO	Receiver timer interrupt
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   mdac	(size 1, offset 9, init 0):	WO	MDI/O access complete
 *   rxcfg	(size 1, offset 10, init 0):	WO	Received configuration symbols
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   gpi_sdp2	(size 1, offset 13, init 0):	WO	General-purpose interrupt on SPD2
 *   gpi_sdp3	(size 1, offset 14, init 0):	WO	General-purpose interrupt on SPD3
 *   txd_low	(size 1, offset 15, init 0):	WO	Transmit descriptor low threshold
 *   srpd	(size 1, offset 16, init 0):	WO	Small receive packet detected
 *   ack	(size 1, offset 17, init 0):	WO	Receive ack frame detected
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   rx_desc_fifo_par0	(size 1, offset 20, init 0):	WO	Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0	(size 1, offset 21, init 0):	WO	Tx descriptor FIFO parity error 0
 *   pcie_master_par	(size 1, offset 22, init 0):	WO	PCIe master data FIFO parity error
 *   pbpar	(size 1, offset 23, init 0):	WO	Packet buffer parity error
 *   rx_desc_fifo_par1	(size 1, offset 24, init 0):	WO	Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1	(size 1, offset 25, init 0):	WO	Tx descriptor FIFO parity error 1
 *   _anon26	(size 5, offset 26, init 0):	RSVD	_
 *   int_asserted	(size 1, offset 31, init 0):	WO	Interrupt asserted
 */
static inline e1000_intreg_t e1000_imc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_imc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd8));
}

static inline e1000_intreg_t e1000_imc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_imc_rd(__DN(t) *_dev)
{
    return(_dev->imc_shadow);
}

static inline void e1000_imc_rawwr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_imc_rawwr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
}

static inline void e1000_imc_wr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_imc_wr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    _regval = (_regval & 0x83f3e6df);
    // No MB1 fields present
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
}

static inline int e1000_imc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_imc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_intreg_t _regval = _dev->imc_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register imc (Interrupt mask clear): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdw =\t%" PRIx8 "\t(Transmit descriptor written back)\n", e1000_intreg_txdw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txqe =\t%" PRIx8 "\t(Transmit queue empty)\n", e1000_intreg_txqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link status change)\n", e1000_intreg_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxseq =\t%" PRIx8 "\t(Receive sequence error)\n", e1000_intreg_rxseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmt0 =\t%" PRIx8 "\t(Receive descriptor minimum threshold reached)\n", e1000_intreg_rxdmt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxo =\t%" PRIx8 "\t(Receiver overrun)\n", e1000_intreg_rxo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxt0 =\t%" PRIx8 "\t(Receiver timer interrupt)\n", e1000_intreg_rxt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdac =\t%" PRIx8 "\t(MDI/O access complete)\n", e1000_intreg_mdac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcfg =\t%" PRIx8 "\t(Received configuration symbols)\n", e1000_intreg_rxcfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp2 =\t%" PRIx8 "\t(General-purpose interrupt on SPD2)\n", e1000_intreg_gpi_sdp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp3 =\t%" PRIx8 "\t(General-purpose interrupt on SPD3)\n", e1000_intreg_gpi_sdp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_low =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_intreg_txd_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srpd =\t%" PRIx8 "\t(Small receive packet detected)\n", e1000_intreg_srpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(Receive ack frame detected)\n", e1000_intreg_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par0 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 0)\n", e1000_intreg_rx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par0 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 0)\n", e1000_intreg_tx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_master_par =\t%" PRIx8 "\t(PCIe master data FIFO parity error)\n", e1000_intreg_pcie_master_par_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pbpar =\t%" PRIx8 "\t(Packet buffer parity error)\n", e1000_intreg_pbpar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par1 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 1)\n", e1000_intreg_rx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par1 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 1)\n", e1000_intreg_tx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_asserted =\t%" PRIx8 "\t(Interrupt asserted)\n", e1000_intreg_int_asserted_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_imc_txdw_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_txdw_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_txdw_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_txqe_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_txqe_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_txqe_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_lsc_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_lsc_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_lsc_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_rxseq_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_rxseq_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxseq_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_rxdmt0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_rxdmt0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxdmt0_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_rxo_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_rxo_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxo_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_rxt0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_rxt0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxt0_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_mdac_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_mdac_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_mdac_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_rxcfg_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_rxcfg_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rxcfg_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_gpi_sdp2_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_gpi_sdp2_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_gpi_sdp2_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_gpi_sdp3_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_gpi_sdp3_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_gpi_sdp3_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_txd_low_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_txd_low_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_txd_low_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_srpd_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_srpd_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_srpd_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_ack_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_ack_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_ack_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_rx_desc_fifo_par0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_rx_desc_fifo_par0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rx_desc_fifo_par0_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_tx_desc_fifo_par0_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_tx_desc_fifo_par0_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_tx_desc_fifo_par0_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_pcie_master_par_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_pcie_master_par_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_pcie_master_par_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_pbpar_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_pbpar_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_pbpar_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_rx_desc_fifo_par1_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_rx_desc_fifo_par1_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_rx_desc_fifo_par1_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_tx_desc_fifo_par1_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_tx_desc_fifo_par1_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_tx_desc_fifo_par1_extract(_dev->imc_shadow));
}

static inline uint8_t e1000_imc_int_asserted_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_imc_int_asserted_rd_shadow(__DN(t) *_dev)
{
    return(e1000_intreg_int_asserted_extract(_dev->imc_shadow));
}

static inline void e1000_imc_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1 & (((e1000_intreg_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e6de & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2 & (((e1000_intreg_t )(_fieldval)) << 1);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e6dd & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4 & (((e1000_intreg_t )(_fieldval)) << 2);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e6db & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8 & (((e1000_intreg_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e6d7 & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10 & (((e1000_intreg_t )(_fieldval)) << 4);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e6cf & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x40 & (((e1000_intreg_t )(_fieldval)) << 6);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e69f & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80 & (((e1000_intreg_t )(_fieldval)) << 7);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e65f & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200 & (((e1000_intreg_t )(_fieldval)) << 9);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e4df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400 & (((e1000_intreg_t )(_fieldval)) << 10);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3e2df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000 & (((e1000_intreg_t )(_fieldval)) << 13);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3c6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4000 & (((e1000_intreg_t )(_fieldval)) << 14);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f3a6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8000 & (((e1000_intreg_t )(_fieldval)) << 15);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f366df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10000 & (((e1000_intreg_t )(_fieldval)) << 16);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f2e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_ack_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_ack_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x20000 & (((e1000_intreg_t )(_fieldval)) << 17);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83f1e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x100000 & (((e1000_intreg_t )(_fieldval)) << 20);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83e3e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200000 & (((e1000_intreg_t )(_fieldval)) << 21);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83d3e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400000 & (((e1000_intreg_t )(_fieldval)) << 22);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x83b3e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x800000 & (((e1000_intreg_t )(_fieldval)) << 23);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x8373e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1000000 & (((e1000_intreg_t )(_fieldval)) << 24);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x82f3e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000000 & (((e1000_intreg_t )(_fieldval)) << 25);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x81f3e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

static inline void e1000_imc_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_imc_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80000000 & (((e1000_intreg_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xd8)));
    _regval = (_regval | (0x3f3e6df & (_dev->imc_shadow)));
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd8, _regval);
    _dev->imc_shadow = _regval;
}

/*
 * Register iam: Interrupt ack auto mask
 * Type: e1000.intreg (Interrupt register format)
 *   txdw	(size 1, offset 0, init 0):	RW	Transmit descriptor written back
 *   txqe	(size 1, offset 1, init 0):	RW	Transmit queue empty
 *   lsc	(size 1, offset 2, init 0):	RW	Link status change
 *   rxseq	(size 1, offset 3, init 0):	RW	Receive sequence error
 *   rxdmt0	(size 1, offset 4, init 0):	RW	Receive descriptor minimum threshold reached
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   rxo	(size 1, offset 6, init 0):	RW	Receiver overrun
 *   rxt0	(size 1, offset 7, init 0):	RW	Receiver timer interrupt
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   mdac	(size 1, offset 9, init 0):	RW	MDI/O access complete
 *   rxcfg	(size 1, offset 10, init 0):	RW	Received configuration symbols
 *   _anon11	(size 2, offset 11, init 0):	RSVD	_
 *   gpi_sdp2	(size 1, offset 13, init 0):	RW	General-purpose interrupt on SPD2
 *   gpi_sdp3	(size 1, offset 14, init 0):	RW	General-purpose interrupt on SPD3
 *   txd_low	(size 1, offset 15, init 0):	RW	Transmit descriptor low threshold
 *   srpd	(size 1, offset 16, init 0):	RW	Small receive packet detected
 *   ack	(size 1, offset 17, init 0):	RW	Receive ack frame detected
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   rx_desc_fifo_par0	(size 1, offset 20, init 0):	RW	Rx descriptor FIFO parity error 0
 *   tx_desc_fifo_par0	(size 1, offset 21, init 0):	RW	Tx descriptor FIFO parity error 0
 *   pcie_master_par	(size 1, offset 22, init 0):	RW	PCIe master data FIFO parity error
 *   pbpar	(size 1, offset 23, init 0):	RW	Packet buffer parity error
 *   rx_desc_fifo_par1	(size 1, offset 24, init 0):	RW	Rx descriptor FIFO parity error 1
 *   tx_desc_fifo_par1	(size 1, offset 25, init 0):	RW	Tx descriptor FIFO parity error 1
 *   _anon26	(size 5, offset 26, init 0):	RSVD	_
 *   int_asserted	(size 1, offset 31, init 0):	RW	Interrupt asserted
 */
static inline e1000_intreg_t e1000_iam_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_iam_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline e1000_intreg_t e1000_iam_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_intreg_t e1000_iam_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline void e1000_iam_rawwr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_iam_rawwr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline void e1000_iam_wr(__DN(t) *_dev, e1000_intreg_t _regval) __attribute__ ((always_inline));
static inline void e1000_iam_wr(__DN(t) *_dev, e1000_intreg_t _regval)
{
    _regval = (_regval & 0x83f3e6df);
    // No MB1 fields present
    _regval = (_regval | (0x7c0c1920 & mackerel_read_addr_32(_dev->base, 0xe0)));
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline int e1000_iam_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_iam_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register iam (Interrupt ack auto mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdw =\t%" PRIx8 "\t(Transmit descriptor written back)\n", e1000_intreg_txdw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txqe =\t%" PRIx8 "\t(Transmit queue empty)\n", e1000_intreg_txqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link status change)\n", e1000_intreg_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxseq =\t%" PRIx8 "\t(Receive sequence error)\n", e1000_intreg_rxseq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdmt0 =\t%" PRIx8 "\t(Receive descriptor minimum threshold reached)\n", e1000_intreg_rxdmt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxo =\t%" PRIx8 "\t(Receiver overrun)\n", e1000_intreg_rxo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxt0 =\t%" PRIx8 "\t(Receiver timer interrupt)\n", e1000_intreg_rxt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdac =\t%" PRIx8 "\t(MDI/O access complete)\n", e1000_intreg_mdac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcfg =\t%" PRIx8 "\t(Received configuration symbols)\n", e1000_intreg_rxcfg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp2 =\t%" PRIx8 "\t(General-purpose interrupt on SPD2)\n", e1000_intreg_gpi_sdp2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_sdp3 =\t%" PRIx8 "\t(General-purpose interrupt on SPD3)\n", e1000_intreg_gpi_sdp3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_low =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_intreg_txd_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srpd =\t%" PRIx8 "\t(Small receive packet detected)\n", e1000_intreg_srpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(Receive ack frame detected)\n", e1000_intreg_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par0 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 0)\n", e1000_intreg_rx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par0 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 0)\n", e1000_intreg_tx_desc_fifo_par0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_master_par =\t%" PRIx8 "\t(PCIe master data FIFO parity error)\n", e1000_intreg_pcie_master_par_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pbpar =\t%" PRIx8 "\t(Packet buffer parity error)\n", e1000_intreg_pbpar_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_desc_fifo_par1 =\t%" PRIx8 "\t(Rx descriptor FIFO parity error 1)\n", e1000_intreg_rx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_desc_fifo_par1 =\t%" PRIx8 "\t(Tx descriptor FIFO parity error 1)\n", e1000_intreg_tx_desc_fifo_par1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int_asserted =\t%" PRIx8 "\t(Interrupt asserted)\n", e1000_intreg_int_asserted_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_iam_txdw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_txdw_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_txdw_extract(_regval));
}

static inline uint8_t e1000_iam_txqe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_txqe_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_txqe_extract(_regval));
}

static inline uint8_t e1000_iam_lsc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_lsc_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_lsc_extract(_regval));
}

static inline uint8_t e1000_iam_rxseq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_rxseq_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_rxseq_extract(_regval));
}

static inline uint8_t e1000_iam_rxdmt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_rxdmt0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_rxdmt0_extract(_regval));
}

static inline uint8_t e1000_iam_rxo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_rxo_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_rxo_extract(_regval));
}

static inline uint8_t e1000_iam_rxt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_rxt0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_rxt0_extract(_regval));
}

static inline uint8_t e1000_iam_mdac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_mdac_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_mdac_extract(_regval));
}

static inline uint8_t e1000_iam_rxcfg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_rxcfg_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_rxcfg_extract(_regval));
}

static inline uint8_t e1000_iam_gpi_sdp2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_gpi_sdp2_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_gpi_sdp2_extract(_regval));
}

static inline uint8_t e1000_iam_gpi_sdp3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_gpi_sdp3_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_gpi_sdp3_extract(_regval));
}

static inline uint8_t e1000_iam_txd_low_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_txd_low_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_txd_low_extract(_regval));
}

static inline uint8_t e1000_iam_srpd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_srpd_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_srpd_extract(_regval));
}

static inline uint8_t e1000_iam_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_ack_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_ack_extract(_regval));
}

static inline uint8_t e1000_iam_rx_desc_fifo_par0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_rx_desc_fifo_par0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_rx_desc_fifo_par0_extract(_regval));
}

static inline uint8_t e1000_iam_tx_desc_fifo_par0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_tx_desc_fifo_par0_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_tx_desc_fifo_par0_extract(_regval));
}

static inline uint8_t e1000_iam_pcie_master_par_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_pcie_master_par_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_pcie_master_par_extract(_regval));
}

static inline uint8_t e1000_iam_pbpar_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_pbpar_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_pbpar_extract(_regval));
}

static inline uint8_t e1000_iam_rx_desc_fifo_par1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_rx_desc_fifo_par1_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_rx_desc_fifo_par1_extract(_regval));
}

static inline uint8_t e1000_iam_tx_desc_fifo_par1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_tx_desc_fifo_par1_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_tx_desc_fifo_par1_extract(_regval));
}

static inline uint8_t e1000_iam_int_asserted_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_iam_int_asserted_rdf(__DN(t) *_dev)
{
    e1000_intreg_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(e1000_intreg_int_asserted_extract(_regval));
}

static inline void e1000_iam_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_txdw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1 & (((e1000_intreg_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_txqe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2 & (((e1000_intreg_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4 & (((e1000_intreg_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_rxseq_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8 & (((e1000_intreg_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_rxdmt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10 & (((e1000_intreg_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_rxo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x40 & (((e1000_intreg_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_rxt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80 & (((e1000_intreg_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_mdac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200 & (((e1000_intreg_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_rxcfg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400 & (((e1000_intreg_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_gpi_sdp2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000 & (((e1000_intreg_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_gpi_sdp3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x4000 & (((e1000_intreg_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_txd_low_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x8000 & (((e1000_intreg_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_srpd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x10000 & (((e1000_intreg_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_ack_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_ack_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x20000 & (((e1000_intreg_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_rx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x100000 & (((e1000_intreg_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffefffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_tx_desc_fifo_par0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x200000 & (((e1000_intreg_t )(_fieldval)) << 21);
    _regval = (_regval | (0xffdfffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_pcie_master_par_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x400000 & (((e1000_intreg_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffbfffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_pbpar_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x800000 & (((e1000_intreg_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_rx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x1000000 & (((e1000_intreg_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfeffffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_tx_desc_fifo_par1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x2000000 & (((e1000_intreg_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

static inline void e1000_iam_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_iam_int_asserted_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_intreg_t _regval = 0x80000000 & (((e1000_intreg_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xe0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

/*
 * Register array eitr: Extended Interrupt Throttle
 * Type: e1000.eitr (Implicit type of Extended Interrupt Throttle register array)
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   interval	(size 13, offset 2, init 0):	RW	Interval
 *   _anon15	(size 1, offset 15, init 0):	MBZ	_
 *   counter	(size 16, offset 16, init 0):	RW	Down counter
 */
static const size_t e1000_eitr_length = 9;
static inline e1000_eitr_t e1000_eitr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_eitr_t e1000_eitr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1680 + (_i * 4)));
}

static inline e1000_eitr_t e1000_eitr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_eitr_t e1000_eitr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1680 + (_i * 4)));
}

static inline void e1000_eitr_rawwr(__DN(t) *_dev, int _i, e1000_eitr_t _regval) __attribute__ ((always_inline));
static inline void e1000_eitr_rawwr(__DN(t) *_dev, int _i, e1000_eitr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1680 + (_i * 4), _regval);
}

static inline void e1000_eitr_wr(__DN(t) *_dev, int _i, e1000_eitr_t _regval) __attribute__ ((always_inline));
static inline void e1000_eitr_wr(__DN(t) *_dev, int _i, e1000_eitr_t _regval)
{
    _regval = (_regval & 0xffff7ffc);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1680 + (_i * 4), _regval);
}

static inline int e1000_eitr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_eitr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_eitr_t _regval = mackerel_read_addr_32(_dev->base, 0x1680 + (_i * 4));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "eitr", _i, "Extended Interrupt Throttle");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " interval =\t%" PRIx16 "\t(Interval)\n", e1000_eitr_interval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " counter =\t%" PRIx16 "\t(Down counter)\n", e1000_eitr_counter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_eitr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_eitr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 9; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_eitr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_eitr_interval_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_eitr_interval_rdf(__DN(t) *_dev, int _i)
{
    e1000_eitr_t _regval = mackerel_read_addr_32(_dev->base, 0x1680 + (_i * 4));
    return(e1000_eitr_interval_extract(_regval));
}

static inline uint16_t e1000_eitr_counter_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_eitr_counter_rdf(__DN(t) *_dev, int _i)
{
    e1000_eitr_t _regval = mackerel_read_addr_32(_dev->base, 0x1680 + (_i * 4));
    return(e1000_eitr_counter_extract(_regval));
}

static inline void e1000_eitr_interval_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eitr_interval_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_eitr_t _regval = 0x7ffc & (((e1000_eitr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x1680 + (_i * 4))));
    // No read of register shadow required
    _regval = (_regval & 0xffff7ffc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1680 + (_i * 4), _regval);
    // No shadow register to write to
}

static inline void e1000_eitr_counter_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_eitr_counter_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_eitr_t _regval = 0xffff0000 & (((e1000_eitr_t )(_fieldval)) << 16);
    _regval = (_regval | (0x7ffc & mackerel_read_addr_32(_dev->base, 0x1680 + (_i * 4))));
    // No read of register shadow required
    _regval = (_regval & 0xffff7ffc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1680 + (_i * 4), _regval);
    // No shadow register to write to
}

/*
 * Register rctl: Receive control
 * Type: e1000.rctl (Implicit type of Receive control register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   en	(size 1, offset 1, init 0):	RW	Receiver enable
 *   sbp	(size 1, offset 2, init 0):	RW	Store bad packets
 *   upe	(size 1, offset 3, init 0):	RW	Unicast promiscuous enabled
 *   mpe	(size 1, offset 4, init 0):	RW	Multicast promiscuous enabled
 *   lpe	(size 1, offset 5, init 0):	RW	Long packet reception enable
 *   lbm	(size 2, offset 6, init 0):	RW	Loopback mode
 *   rdmts	(size 2, offset 8, init 0):	RW	Receive descriptor minimum threshold size
 *   dtyp	(size 2, offset 10, init 0):	RW	Descriptor type
 *   mo	(size 2, offset 12, init 0):	RW	Multicast offset (12 bits starting at 36-val)
 *   _anon14	(size 1, offset 14, init 0):	MBZ	_
 *   bam	(size 1, offset 15, init 0):	RW	Broadcast accept mode
 *   bsize	(size 2, offset 16, init 0):	RW	Receive buffer size (see BSEX)
 *   vfe	(size 1, offset 18, init 0):	RW	VLAN filter enable
 *   cfien	(size 1, offset 19, init 0):	RW	Canonical form indicator enable
 *   cfi	(size 1, offset 20, init 0):	RW	Canonical form indicator value
 *   _anon21	(size 1, offset 21, init 0):	MBZ	_
 *   dpf	(size 1, offset 22, init 0):	RW	Discard pause frames
 *   pmcf	(size 1, offset 23, init 0):	RW	Pass MAC control frames
 *   _anon24	(size 1, offset 24, init 0):	MBZ	_
 *   bsex	(size 1, offset 25, init 0):	RW	Buffer size extension
 *   secrc	(size 1, offset 26, init 0):	RW	Strip Ethernet CRC from packet
 *   flxbuf	(size 4, offset 27, init 0):	RW	Flexible buffer size (in KB)
 *   _anon31	(size 1, offset 31, init 0):	MBZ	_
 */
static inline e1000_rctl_t e1000_rctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline e1000_rctl_t e1000_rctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rctl_t e1000_rctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x100));
}

static inline void e1000_rctl_rawwr(__DN(t) *_dev, e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_rctl_rawwr(__DN(t) *_dev, e1000_rctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline void e1000_rctl_wr(__DN(t) *_dev, e1000_rctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_rctl_wr(__DN(t) *_dev, e1000_rctl_t _regval)
{
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
}

static inline int e1000_rctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rctl (Receive control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Receiver enable)\n", e1000_rctl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sbp =\t%" PRIx8 "\t(Store bad packets)\n", e1000_rctl_sbp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " upe =\t%" PRIx8 "\t(Unicast promiscuous enabled)\n", e1000_rctl_upe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpe =\t%" PRIx8 "\t(Multicast promiscuous enabled)\n", e1000_rctl_mpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpe =\t%" PRIx8 "\t(Long packet reception enable)\n", e1000_rctl_lpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_lbmode_prtval(_s + _r, _avail, e1000_rctl_lbm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Loopback mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdmts =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxthresh_prtval(_s + _r, _avail, e1000_rctl_rdmts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive descriptor minimum threshold size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dtyp =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_dtype_prtval(_s + _r, _avail, e1000_rctl_dtyp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Descriptor type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mo =\t%" PRIx8 "\t(Multicast offset (12 bits starting at 36-val))\n", e1000_rctl_mo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bam =\t%" PRIx8 "\t(Broadcast accept mode)\n", e1000_rctl_bam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxbsize_prtval(_s + _r, _avail, e1000_rctl_bsize_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Receive buffer size (see BSEX))\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vfe =\t%" PRIx8 "\t(VLAN filter enable)\n", e1000_rctl_vfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfien =\t%" PRIx8 "\t(Canonical form indicator enable)\n", e1000_rctl_cfien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfi =\t%" PRIx8 "\t(Canonical form indicator value)\n", e1000_rctl_cfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpf =\t%" PRIx8 "\t(Discard pause frames)\n", e1000_rctl_dpf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmcf =\t%" PRIx8 "\t(Pass MAC control frames)\n", e1000_rctl_pmcf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsex =\t%" PRIx8 "\t(Buffer size extension)\n", e1000_rctl_bsex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " secrc =\t%" PRIx8 "\t(Strip Ethernet CRC from packet)\n", e1000_rctl_secrc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flxbuf =\t%" PRIx8 "\t(Flexible buffer size (in KB))\n", e1000_rctl_flxbuf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t e1000_rctl_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_en_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_en_extract(_regval));
}

static inline uint8_t e1000_rctl_sbp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_sbp_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_sbp_extract(_regval));
}

static inline uint8_t e1000_rctl_upe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_upe_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_upe_extract(_regval));
}

static inline uint8_t e1000_rctl_mpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_mpe_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_mpe_extract(_regval));
}

static inline uint8_t e1000_rctl_lpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_lpe_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_lpe_extract(_regval));
}

static inline e1000_lbmode_t e1000_rctl_lbm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_lbmode_t e1000_rctl_lbm_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_lbm_extract(_regval));
}

static inline e1000_rxthresh_t e1000_rctl_rdmts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rxthresh_t e1000_rctl_rdmts_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_rdmts_extract(_regval));
}

static inline e1000_dtype_t e1000_rctl_dtyp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_dtype_t e1000_rctl_dtyp_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_dtyp_extract(_regval));
}

static inline uint8_t e1000_rctl_mo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_mo_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_mo_extract(_regval));
}

static inline uint8_t e1000_rctl_bam_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_bam_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_bam_extract(_regval));
}

static inline e1000_rxbsize_t e1000_rctl_bsize_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rxbsize_t e1000_rctl_bsize_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_bsize_extract(_regval));
}

static inline uint8_t e1000_rctl_vfe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_vfe_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_vfe_extract(_regval));
}

static inline uint8_t e1000_rctl_cfien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_cfien_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_cfien_extract(_regval));
}

static inline uint8_t e1000_rctl_cfi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_cfi_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_cfi_extract(_regval));
}

static inline uint8_t e1000_rctl_dpf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_dpf_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_dpf_extract(_regval));
}

static inline uint8_t e1000_rctl_pmcf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_pmcf_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_pmcf_extract(_regval));
}

static inline uint8_t e1000_rctl_bsex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_bsex_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_bsex_extract(_regval));
}

static inline uint8_t e1000_rctl_secrc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_secrc_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_secrc_extract(_regval));
}

static inline uint8_t e1000_rctl_flxbuf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rctl_flxbuf_rdf(__DN(t) *_dev)
{
    e1000_rctl_t _regval = mackerel_read_addr_32(_dev->base, 0x100);
    return(e1000_rctl_flxbuf_extract(_regval));
}

static inline void e1000_rctl_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x2 & (((e1000_rctl_t )(_fieldval)) << 1);
    _regval = (_regval | (0x7edfbffc & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_sbp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_sbp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x4 & (((e1000_rctl_t )(_fieldval)) << 2);
    _regval = (_regval | (0x7edfbffa & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_upe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_upe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x8 & (((e1000_rctl_t )(_fieldval)) << 3);
    _regval = (_regval | (0x7edfbff6 & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_mpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_mpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x10 & (((e1000_rctl_t )(_fieldval)) << 4);
    _regval = (_regval | (0x7edfbfee & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_lpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_lpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x20 & (((e1000_rctl_t )(_fieldval)) << 5);
    _regval = (_regval | (0x7edfbfde & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_lbm_wrf(__DN(t) *_dev, e1000_lbmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_lbm_wrf(__DN(t) *_dev, e1000_lbmode_t _fieldval)
{
    e1000_rctl_t _regval = 0xc0 & (((e1000_rctl_t )(_fieldval)) << 6);
    _regval = (_regval | (0x7edfbf3e & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_rdmts_wrf(__DN(t) *_dev, e1000_rxthresh_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_rdmts_wrf(__DN(t) *_dev, e1000_rxthresh_t _fieldval)
{
    e1000_rctl_t _regval = 0x300 & (((e1000_rctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7edfbcfe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_dtyp_wrf(__DN(t) *_dev, e1000_dtype_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_dtyp_wrf(__DN(t) *_dev, e1000_dtype_t _fieldval)
{
    e1000_rctl_t _regval = 0xc00 & (((e1000_rctl_t )(_fieldval)) << 10);
    _regval = (_regval | (0x7edfb3fe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_mo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_mo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x3000 & (((e1000_rctl_t )(_fieldval)) << 12);
    _regval = (_regval | (0x7edf8ffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_bam_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_bam_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x8000 & (((e1000_rctl_t )(_fieldval)) << 15);
    _regval = (_regval | (0x7edf3ffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_bsize_wrf(__DN(t) *_dev, e1000_rxbsize_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_bsize_wrf(__DN(t) *_dev, e1000_rxbsize_t _fieldval)
{
    e1000_rctl_t _regval = 0x30000 & (((e1000_rctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0x7edcbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_vfe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_vfe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x40000 & (((e1000_rctl_t )(_fieldval)) << 18);
    _regval = (_regval | (0x7edbbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_cfien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_cfien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x80000 & (((e1000_rctl_t )(_fieldval)) << 19);
    _regval = (_regval | (0x7ed7bffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_cfi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_cfi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x100000 & (((e1000_rctl_t )(_fieldval)) << 20);
    _regval = (_regval | (0x7ecfbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_dpf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_dpf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x400000 & (((e1000_rctl_t )(_fieldval)) << 22);
    _regval = (_regval | (0x7e9fbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_pmcf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_pmcf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x800000 & (((e1000_rctl_t )(_fieldval)) << 23);
    _regval = (_regval | (0x7e5fbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_bsex_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_bsex_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x2000000 & (((e1000_rctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0x7cdfbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_secrc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_secrc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x4000000 & (((e1000_rctl_t )(_fieldval)) << 26);
    _regval = (_regval | (0x7adfbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

static inline void e1000_rctl_flxbuf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rctl_flxbuf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rctl_t _regval = 0x78000000 & (((e1000_rctl_t )(_fieldval)) << 27);
    _regval = (_regval | (0x6dfbffe & mackerel_read_addr_32(_dev->base, 0x100)));
    // No read of register shadow required
    _regval = (_regval & 0x7edfbffe);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100, _regval);
    // No shadow register to write to
}

/*
 * Register ert: Early receive threshold
 * Type: e1000.ert (Implicit type of Early receive threshold register)
 *   rxthresh	(size 13, offset 0, init 0):	RW	Receive threshold value (x 8 bytes)
 *   _anon13	(size 1, offset 13, init 0):	RSVD	_
 *   _anon14	(size 18, offset 14, init 0):	MBZ	_
 */
static inline e1000_ert_t e1000_ert_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ert_t e1000_ert_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2008));
}

static inline e1000_ert_t e1000_ert_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ert_t e1000_ert_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2008));
}

static inline void e1000_ert_rawwr(__DN(t) *_dev, e1000_ert_t _regval) __attribute__ ((always_inline));
static inline void e1000_ert_rawwr(__DN(t) *_dev, e1000_ert_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2008, _regval);
}

static inline void e1000_ert_wr(__DN(t) *_dev, e1000_ert_t _regval) __attribute__ ((always_inline));
static inline void e1000_ert_wr(__DN(t) *_dev, e1000_ert_t _regval)
{
    _regval = (_regval & 0x1fff);
    // No MB1 fields present
    _regval = (_regval | (0x2000 & mackerel_read_addr_32(_dev->base, 0x2008)));
    mackerel_write_addr_32(_dev->base, 0x2008, _regval);
}

static inline int e1000_ert_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ert_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ert_t _regval = mackerel_read_addr_32(_dev->base, 0x2008);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ert (Early receive threshold): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxthresh =\t%" PRIx16 "\t(Receive threshold value (x 8 bytes))\n", e1000_ert_rxthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    // _anon14 is anonymous
    return(_r);
}

static inline uint16_t e1000_ert_rxthresh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_ert_rxthresh_rdf(__DN(t) *_dev)
{
    e1000_ert_t _regval = mackerel_read_addr_32(_dev->base, 0x2008);
    return(e1000_ert_rxthresh_extract(_regval));
}

static inline void e1000_ert_rxthresh_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ert_rxthresh_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_ert_t _regval = 0x1fff & (((e1000_ert_t )(_fieldval)) << 0);
    _regval = (_regval | (0x2000 & mackerel_read_addr_32(_dev->base, 0x2008)));
    // No read of register shadow required
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2008, _regval);
    // No shadow register to write to
}

/*
 * Register fcrtl: Flow control rx threshold low
 * Type: e1000.fcrtl (Implicit type of Flow control rx threshold low register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   rtl	(size 13, offset 3, init 0):	RW	Recieve threshold low
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   xone	(size 1, offset 31, init 0):	RW	XON enable
 */
static inline e1000_fcrtl_t e1000_fcrtl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fcrtl_t e1000_fcrtl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2160));
}

static inline e1000_fcrtl_t e1000_fcrtl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fcrtl_t e1000_fcrtl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2160));
}

static inline void e1000_fcrtl_rawwr(__DN(t) *_dev, e1000_fcrtl_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcrtl_rawwr(__DN(t) *_dev, e1000_fcrtl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2160, _regval);
}

static inline void e1000_fcrtl_wr(__DN(t) *_dev, e1000_fcrtl_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcrtl_wr(__DN(t) *_dev, e1000_fcrtl_t _regval)
{
    _regval = (_regval & 0x8000fff8);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2160, _regval);
}

static inline int e1000_fcrtl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fcrtl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_fcrtl_t _regval = mackerel_read_addr_32(_dev->base, 0x2160);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcrtl (Flow control rx threshold low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtl =\t%" PRIx16 "\t(Recieve threshold low)\n", e1000_fcrtl_rtl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xone =\t%" PRIx8 "\t(XON enable)\n", e1000_fcrtl_xone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e1000_fcrtl_rtl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_fcrtl_rtl_rdf(__DN(t) *_dev)
{
    e1000_fcrtl_t _regval = mackerel_read_addr_32(_dev->base, 0x2160);
    return(e1000_fcrtl_rtl_extract(_regval));
}

static inline uint8_t e1000_fcrtl_xone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fcrtl_xone_rdf(__DN(t) *_dev)
{
    e1000_fcrtl_t _regval = mackerel_read_addr_32(_dev->base, 0x2160);
    return(e1000_fcrtl_xone_extract(_regval));
}

static inline void e1000_fcrtl_rtl_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fcrtl_rtl_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_fcrtl_t _regval = 0xfff8 & (((e1000_fcrtl_t )(_fieldval)) << 3);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x2160)));
    // No read of register shadow required
    _regval = (_regval & 0x8000fff8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2160, _regval);
    // No shadow register to write to
}

static inline void e1000_fcrtl_xone_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fcrtl_xone_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fcrtl_t _regval = 0x80000000 & (((e1000_fcrtl_t )(_fieldval)) << 31);
    _regval = (_regval | (0xfff8 & mackerel_read_addr_32(_dev->base, 0x2160)));
    // No read of register shadow required
    _regval = (_regval & 0x8000fff8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2160, _regval);
    // No shadow register to write to
}

/*
 * Register fcrth: Flow control rx threshold high
 * Type: e1000.fcrth (Implicit type of Flow control rx threshold high register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   rth	(size 13, offset 3, init 0):	RW	Recieve threshold high
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   flowcntdis	(size 1, offset 31, init 0):	RW	Flow control disable
 */
static inline e1000_fcrth_t e1000_fcrth_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fcrth_t e1000_fcrth_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2168));
}

static inline e1000_fcrth_t e1000_fcrth_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fcrth_t e1000_fcrth_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2168));
}

static inline void e1000_fcrth_rawwr(__DN(t) *_dev, e1000_fcrth_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcrth_rawwr(__DN(t) *_dev, e1000_fcrth_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2168, _regval);
}

static inline void e1000_fcrth_wr(__DN(t) *_dev, e1000_fcrth_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcrth_wr(__DN(t) *_dev, e1000_fcrth_t _regval)
{
    _regval = (_regval & 0x8000fff8);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2168, _regval);
}

static inline int e1000_fcrth_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fcrth_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_fcrth_t _regval = mackerel_read_addr_32(_dev->base, 0x2168);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcrth (Flow control rx threshold high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rth =\t%" PRIx16 "\t(Recieve threshold high)\n", e1000_fcrth_rth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flowcntdis =\t%" PRIx8 "\t(Flow control disable)\n", e1000_fcrth_flowcntdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e1000_fcrth_rth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_fcrth_rth_rdf(__DN(t) *_dev)
{
    e1000_fcrth_t _regval = mackerel_read_addr_32(_dev->base, 0x2168);
    return(e1000_fcrth_rth_extract(_regval));
}

static inline uint8_t e1000_fcrth_flowcntdis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fcrth_flowcntdis_rdf(__DN(t) *_dev)
{
    e1000_fcrth_t _regval = mackerel_read_addr_32(_dev->base, 0x2168);
    return(e1000_fcrth_flowcntdis_extract(_regval));
}

static inline void e1000_fcrth_rth_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fcrth_rth_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_fcrth_t _regval = 0xfff8 & (((e1000_fcrth_t )(_fieldval)) << 3);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x2168)));
    // No read of register shadow required
    _regval = (_regval & 0x8000fff8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2168, _regval);
    // No shadow register to write to
}

static inline void e1000_fcrth_flowcntdis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fcrth_flowcntdis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fcrth_t _regval = 0x80000000 & (((e1000_fcrth_t )(_fieldval)) << 31);
    _regval = (_regval | (0xfff8 & mackerel_read_addr_32(_dev->base, 0x2168)));
    // No read of register shadow required
    _regval = (_regval & 0x8000fff8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2168, _regval);
    // No shadow register to write to
}

/*
 * Register psrctl: Packet split rx control
 * Type: e1000.psrctl (Implicit type of Packet split rx control register)
 *   bsize0	(size 7, offset 0, init 0):	RW	Receive buffer 0 size (x 128 bytes)
 *   _anon7	(size 1, offset 7, init 0):	MBZ	_
 *   bsize1	(size 7, offset 8, init 0):	RW	Receive buffer 1 size (x 1 kbytes)
 *   _anon15	(size 1, offset 15, init 0):	MBZ	_
 *   bsize2	(size 7, offset 16, init 0):	RW	Receive buffer 2 size (x 1 kbytes)
 *   _anon23	(size 1, offset 23, init 0):	MBZ	_
 *   bsize3	(size 7, offset 24, init 0):	RW	Receive buffer 3 size (x 1 kbytes)
 *   _anon31	(size 1, offset 31, init 0):	MBZ	_
 */
static inline e1000_psrctl_t e1000_psrctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_psrctl_t e1000_psrctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2170));
}

static inline e1000_psrctl_t e1000_psrctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_psrctl_t e1000_psrctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2170));
}

static inline void e1000_psrctl_rawwr(__DN(t) *_dev, e1000_psrctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_psrctl_rawwr(__DN(t) *_dev, e1000_psrctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2170, _regval);
}

static inline void e1000_psrctl_wr(__DN(t) *_dev, e1000_psrctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_psrctl_wr(__DN(t) *_dev, e1000_psrctl_t _regval)
{
    _regval = (_regval & 0x7f7f7f7f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2170, _regval);
}

static inline int e1000_psrctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_psrctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_psrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2170);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register psrctl (Packet split rx control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize0 =\t%" PRIx8 "\t(Receive buffer 0 size (x 128 bytes))\n", e1000_psrctl_bsize0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize1 =\t%" PRIx8 "\t(Receive buffer 1 size (x 1 kbytes))\n", e1000_psrctl_bsize1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize2 =\t%" PRIx8 "\t(Receive buffer 2 size (x 1 kbytes))\n", e1000_psrctl_bsize2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsize3 =\t%" PRIx8 "\t(Receive buffer 3 size (x 1 kbytes))\n", e1000_psrctl_bsize3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t e1000_psrctl_bsize0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize0_rdf(__DN(t) *_dev)
{
    e1000_psrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2170);
    return(e1000_psrctl_bsize0_extract(_regval));
}

static inline uint8_t e1000_psrctl_bsize1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize1_rdf(__DN(t) *_dev)
{
    e1000_psrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2170);
    return(e1000_psrctl_bsize1_extract(_regval));
}

static inline uint8_t e1000_psrctl_bsize2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize2_rdf(__DN(t) *_dev)
{
    e1000_psrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2170);
    return(e1000_psrctl_bsize2_extract(_regval));
}

static inline uint8_t e1000_psrctl_bsize3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_psrctl_bsize3_rdf(__DN(t) *_dev)
{
    e1000_psrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2170);
    return(e1000_psrctl_bsize3_extract(_regval));
}

static inline void e1000_psrctl_bsize0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_psrctl_bsize0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_psrctl_t _regval = 0x7f & (((e1000_psrctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x7f7f7f00 & mackerel_read_addr_32(_dev->base, 0x2170)));
    // No read of register shadow required
    _regval = (_regval & 0x7f7f7f7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2170, _regval);
    // No shadow register to write to
}

static inline void e1000_psrctl_bsize1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_psrctl_bsize1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_psrctl_t _regval = 0x7f00 & (((e1000_psrctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x7f7f007f & mackerel_read_addr_32(_dev->base, 0x2170)));
    // No read of register shadow required
    _regval = (_regval & 0x7f7f7f7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2170, _regval);
    // No shadow register to write to
}

static inline void e1000_psrctl_bsize2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_psrctl_bsize2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_psrctl_t _regval = 0x7f0000 & (((e1000_psrctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0x7f007f7f & mackerel_read_addr_32(_dev->base, 0x2170)));
    // No read of register shadow required
    _regval = (_regval & 0x7f7f7f7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2170, _regval);
    // No shadow register to write to
}

static inline void e1000_psrctl_bsize3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_psrctl_bsize3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_psrctl_t _regval = 0x7f000000 & (((e1000_psrctl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x7f7f7f & mackerel_read_addr_32(_dev->base, 0x2170)));
    // No read of register shadow required
    _regval = (_regval & 0x7f7f7f7f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2170, _regval);
    // No shadow register to write to
}

/*
 * Register array rdbal: Rx descr. base addr low
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_rdbal_length = 2;
static inline uint32_t e1000_rdbal_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_rdbal_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2800 + (_i * 256)));
}

static inline uint32_t e1000_rdbal_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_rdbal_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2800 + (_i * 256)));
}

static inline void e1000_rdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2800 + (_i * 256), _regval);
}

static inline void e1000_rdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2800 + (_i * 256), _regval);
}

static inline int e1000_rdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2800 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdbal", _i, "Rx descr. base addr low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_rdbal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rdbal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rdbal_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdbah: Rx descr. base addr high
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_rdbah_length = 2;
static inline uint32_t e1000_rdbah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_rdbah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2804 + (_i * 256)));
}

static inline uint32_t e1000_rdbah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_rdbah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2804 + (_i * 256)));
}

static inline void e1000_rdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2804 + (_i * 256), _regval);
}

static inline void e1000_rdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2804 + (_i * 256), _regval);
}

static inline int e1000_rdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2804 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdbah", _i, "Rx descr. base addr high");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_rdbah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rdbah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rdbah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdlen: Rx descriptor length
 * Type: e1000.dqlen (Descriptor length value)
 *   _anon0	(size 7, offset 0, init 0):	MBZ	_
 *   len	(size 13, offset 7, init 0):	RW	Num. descriptors (x8)
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static const size_t e1000_rdlen_length = 2;
static inline e1000_dqlen_t e1000_rdlen_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqlen_t e1000_rdlen_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2808 + (_i * 256)));
}

static inline e1000_dqlen_t e1000_rdlen_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqlen_t e1000_rdlen_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2808 + (_i * 256)));
}

static inline void e1000_rdlen_rawwr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdlen_rawwr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2808 + (_i * 256), _regval);
}

static inline void e1000_rdlen_wr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdlen_wr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval)
{
    _regval = (_regval & 0xfff80);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2808 + (_i * 256), _regval);
}

static inline int e1000_rdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_dqlen_t _regval = mackerel_read_addr_32(_dev->base, 0x2808 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdlen", _i, "Rx descriptor length");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx16 "\t(Num. descriptors (x8))\n", e1000_dqlen_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline int e1000_rdlen_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rdlen_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rdlen_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_rdlen_len_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_rdlen_len_rdf(__DN(t) *_dev, int _i)
{
    e1000_dqlen_t _regval = mackerel_read_addr_32(_dev->base, 0x2808 + (_i * 256));
    return(e1000_dqlen_len_extract(_regval));
}

static inline void e1000_rdlen_len_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdlen_len_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_dqlen_t _regval = 0xfff80 & (((e1000_dqlen_t )(_fieldval)) << 7);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfff80);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2808 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register array rdh: Rx descr. head
 * Type: e1000.dqval (Descriptor head/tail value)
 *   val	(size 16, offset 0, init 0):	RW	value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static const size_t e1000_rdh_length = 2;
static inline e1000_dqval_t e1000_rdh_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_rdh_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2810 + (_i * 256)));
}

static inline e1000_dqval_t e1000_rdh_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_rdh_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2810 + (_i * 256)));
}

static inline void e1000_rdh_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdh_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2810 + (_i * 256), _regval);
}

static inline void e1000_rdh_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdh_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2810 + (_i * 256), _regval);
}

static inline int e1000_rdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x2810 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdh", _i, "Rx descr. head");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t(value)\n", e1000_dqval_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int e1000_rdh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rdh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rdh_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_rdh_val_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_rdh_val_rdf(__DN(t) *_dev, int _i)
{
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x2810 + (_i * 256));
    return(e1000_dqval_val_extract(_regval));
}

static inline void e1000_rdh_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdh_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_dqval_t _regval = 0xffff & (((e1000_dqval_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2810 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register array rdt: Rx descr. tail
 * Type: e1000.dqval (Descriptor head/tail value)
 *   val	(size 16, offset 0, init 0):	RW	value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static const size_t e1000_rdt_length = 2;
static inline e1000_dqval_t e1000_rdt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_rdt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2818 + (_i * 256)));
}

static inline e1000_dqval_t e1000_rdt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_rdt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2818 + (_i * 256)));
}

static inline void e1000_rdt_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdt_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2818 + (_i * 256), _regval);
}

static inline void e1000_rdt_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdt_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2818 + (_i * 256), _regval);
}

static inline int e1000_rdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x2818 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdt", _i, "Rx descr. tail");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t(value)\n", e1000_dqval_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int e1000_rdt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rdt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rdt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_rdt_val_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_rdt_val_rdf(__DN(t) *_dev, int _i)
{
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x2818 + (_i * 256));
    return(e1000_dqval_val_extract(_regval));
}

static inline void e1000_rdt_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdt_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_dqval_t _regval = 0xffff & (((e1000_dqval_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2818 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register rdtr: Rx. interrupt delay timer
 * Type: e1000.rdtr (Implicit type of Rx. interrupt delay timer register)
 *   delay	(size 16, offset 0, init 0):	RW	delay timer (x 1.024us)
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   fpd	(size 1, offset 31, init 0):	RW	Flush partial descriptor block
 */
static inline e1000_rdtr_t e1000_rdtr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rdtr_t e1000_rdtr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2820));
}

static inline e1000_rdtr_t e1000_rdtr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rdtr_t e1000_rdtr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2820));
}

static inline void e1000_rdtr_rawwr(__DN(t) *_dev, e1000_rdtr_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdtr_rawwr(__DN(t) *_dev, e1000_rdtr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2820, _regval);
}

static inline void e1000_rdtr_wr(__DN(t) *_dev, e1000_rdtr_t _regval) __attribute__ ((always_inline));
static inline void e1000_rdtr_wr(__DN(t) *_dev, e1000_rdtr_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2820, _regval);
}

static inline int e1000_rdtr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rdtr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rdtr_t _regval = mackerel_read_addr_32(_dev->base, 0x2820);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rdtr (Rx. interrupt delay timer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " delay =\t%" PRIx16 "\t(delay timer (x 1.024us))\n", e1000_rdtr_delay_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fpd =\t%" PRIx8 "\t(Flush partial descriptor block)\n", e1000_rdtr_fpd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e1000_rdtr_delay_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_rdtr_delay_rdf(__DN(t) *_dev)
{
    e1000_rdtr_t _regval = mackerel_read_addr_32(_dev->base, 0x2820);
    return(e1000_rdtr_delay_extract(_regval));
}

static inline uint8_t e1000_rdtr_fpd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rdtr_fpd_rdf(__DN(t) *_dev)
{
    e1000_rdtr_t _regval = mackerel_read_addr_32(_dev->base, 0x2820);
    return(e1000_rdtr_fpd_extract(_regval));
}

static inline void e1000_rdtr_delay_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdtr_delay_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_rdtr_t _regval = 0xffff & (((e1000_rdtr_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x2820)));
    // No read of register shadow required
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2820, _regval);
    // No shadow register to write to
}

static inline void e1000_rdtr_fpd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rdtr_fpd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rdtr_t _regval = 0x80000000 & (((e1000_rdtr_t )(_fieldval)) << 31);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x2820)));
    // No read of register shadow required
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2820, _regval);
    // No shadow register to write to
}

/*
 * Register array rxdctl: Rx descriptor control
 * Type: e1000.rxdctl (Implicit type of Rx descriptor control register array)
 *   pthresh	(size 6, offset 0, init 0):	RW	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 6, offset 8, init 0):	RW	Host threshold
 *   _anon14	(size 2, offset 14, init 0):	MBZ	_
 *   wthresh	(size 6, offset 16, init 0):	RW	Write back threshold
 *   _anon22	(size 2, offset 22, init 0):	MBZ	_
 *   gran	(size 1, offset 24, init 0):	RW	Granularity
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static const size_t e1000_rxdctl_length = 2;
static inline e1000_rxdctl_t e1000_rxdctl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_rxdctl_t e1000_rxdctl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256)));
}

static inline e1000_rxdctl_t e1000_rxdctl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_rxdctl_t e1000_rxdctl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256)));
}

static inline void e1000_rxdctl_rawwr(__DN(t) *_dev, int _i, e1000_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_rawwr(__DN(t) *_dev, int _i, e1000_rxdctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
}

static inline void e1000_rxdctl_wr(__DN(t) *_dev, int _i, e1000_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_wr(__DN(t) *_dev, int _i, e1000_rxdctl_t _regval)
{
    _regval = (_regval & 0x13f3f3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
}

static inline int e1000_rxdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rxdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rxdctl", _i, "Rx descriptor control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_rxdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_rxdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_rxdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gran =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_threshgran_prtval(_s + _r, _avail, e1000_rxdctl_gran_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Granularity)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline int e1000_rxdctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rxdctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rxdctl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_rxdctl_pthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_pthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_pthresh_extract(_regval));
}

static inline uint8_t e1000_rxdctl_hthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_hthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_hthresh_extract(_regval));
}

static inline uint8_t e1000_rxdctl_wthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_wthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_wthresh_extract(_regval));
}

static inline e1000_threshgran_t e1000_rxdctl_gran_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_threshgran_t e1000_rxdctl_gran_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_gran_extract(_regval));
}

static inline void e1000_rxdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_t _regval = 0x3f & (((e1000_rxdctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0x13f3f00 & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x13f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_rxdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_t _regval = 0x3f00 & (((e1000_rxdctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x13f003f & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x13f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_rxdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_t _regval = 0x3f0000 & (((e1000_rxdctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0x1003f3f & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x13f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_rxdctl_gran_wrf(__DN(t) *_dev, int _i, e1000_threshgran_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_gran_wrf(__DN(t) *_dev, int _i, e1000_threshgran_t _fieldval)
{
    e1000_rxdctl_t _regval = 0x1000000 & (((e1000_rxdctl_t )(_fieldval)) << 24);
    _regval = (_regval | (0x3f3f3f & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x13f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register array rxdctl_82575: Rx descriptor control
 * Type: e1000.rxdctl_82575 (Implicit type of Rx descriptor control register array)
 *   pthresh	(size 6, offset 0, init 0):	RW	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 6, offset 8, init 0):	RW	Host threshold
 *   _anon14	(size 2, offset 14, init 0):	MBZ	_
 *   wthresh	(size 6, offset 16, init 0):	RW	Write back threshold
 *   _anon22	(size 3, offset 22, init 0):	MBZ	_
 *   enable	(size 1, offset 25, init 0):	RW	Granularity
 *   swflush	(size 1, offset 26, init 0):	RW	Receive Software Flush
 *   _anon27	(size 5, offset 27, init 0):	MBZ	_
 */
static const size_t e1000_rxdctl_82575_length = 2;
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256)));
}

static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_rxdctl_82575_t e1000_rxdctl_82575_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256)));
}

static inline void e1000_rxdctl_82575_rawwr(__DN(t) *_dev, int _i, e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_82575_rawwr(__DN(t) *_dev, int _i, e1000_rxdctl_82575_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
}

static inline void e1000_rxdctl_82575_wr(__DN(t) *_dev, int _i, e1000_rxdctl_82575_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_82575_wr(__DN(t) *_dev, int _i, e1000_rxdctl_82575_t _regval)
{
    _regval = (_regval & 0x63f3f3f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
}

static inline int e1000_rxdctl_82575_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rxdctl_82575_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rxdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rxdctl_82575", _i, "Rx descriptor control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_rxdctl_82575_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_rxdctl_82575_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_rxdctl_82575_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Granularity)\n", e1000_rxdctl_82575_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflush =\t%" PRIx8 "\t(Receive Software Flush)\n", e1000_rxdctl_82575_swflush_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline int e1000_rxdctl_82575_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rxdctl_82575_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rxdctl_82575_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_rxdctl_82575_pthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_pthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_82575_pthresh_extract(_regval));
}

static inline uint8_t e1000_rxdctl_82575_hthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_hthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_82575_hthresh_extract(_regval));
}

static inline uint8_t e1000_rxdctl_82575_wthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_wthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_82575_wthresh_extract(_regval));
}

static inline uint8_t e1000_rxdctl_82575_enable_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_enable_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_82575_enable_extract(_regval));
}

static inline uint8_t e1000_rxdctl_82575_swflush_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rxdctl_82575_swflush_rdf(__DN(t) *_dev, int _i)
{
    e1000_rxdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256));
    return(e1000_rxdctl_82575_swflush_extract(_regval));
}

static inline void e1000_rxdctl_82575_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_82575_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_82575_t _regval = 0x3f & (((e1000_rxdctl_82575_t )(_fieldval)) << 0);
    _regval = (_regval | (0x63f3f00 & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x63f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_rxdctl_82575_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_82575_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_82575_t _regval = 0x3f00 & (((e1000_rxdctl_82575_t )(_fieldval)) << 8);
    _regval = (_regval | (0x63f003f & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x63f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_rxdctl_82575_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_82575_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_82575_t _regval = 0x3f0000 & (((e1000_rxdctl_82575_t )(_fieldval)) << 16);
    _regval = (_regval | (0x6003f3f & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x63f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_rxdctl_82575_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_82575_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_82575_t _regval = 0x2000000 & (((e1000_rxdctl_82575_t )(_fieldval)) << 25);
    _regval = (_regval | (0x43f3f3f & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x63f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_rxdctl_82575_swflush_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxdctl_82575_swflush_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rxdctl_82575_t _regval = 0x4000000 & (((e1000_rxdctl_82575_t )(_fieldval)) << 26);
    _regval = (_regval | (0x23f3f3f & mackerel_read_addr_32(_dev->base, 0x2828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x63f3f3f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2828 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register radv: Rx absolute intr. delay
 * Type: e1000.radv (Implicit type of Rx absolute intr. delay register)
 *   idv	(size 16, offset 0, init 0):	RW	Interrupt delay value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline e1000_radv_t e1000_radv_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_radv_t e1000_radv_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x282c));
}

static inline e1000_radv_t e1000_radv_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_radv_t e1000_radv_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x282c));
}

static inline void e1000_radv_rawwr(__DN(t) *_dev, e1000_radv_t _regval) __attribute__ ((always_inline));
static inline void e1000_radv_rawwr(__DN(t) *_dev, e1000_radv_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x282c, _regval);
}

static inline void e1000_radv_wr(__DN(t) *_dev, e1000_radv_t _regval) __attribute__ ((always_inline));
static inline void e1000_radv_wr(__DN(t) *_dev, e1000_radv_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x282c, _regval);
}

static inline int e1000_radv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_radv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_radv_t _regval = mackerel_read_addr_32(_dev->base, 0x282c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register radv (Rx absolute intr. delay): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interrupt delay value)\n", e1000_radv_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e1000_radv_idv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_radv_idv_rdf(__DN(t) *_dev)
{
    e1000_radv_t _regval = mackerel_read_addr_32(_dev->base, 0x282c);
    return(e1000_radv_idv_extract(_regval));
}

static inline void e1000_radv_idv_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_radv_idv_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_radv_t _regval = 0xffff & (((e1000_radv_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x282c, _regval);
    // No shadow register to write to
}

/*
 * Register rsrpd: Rx small packet detect interrupt
 * Type: e1000.rsrpd (Implicit type of Rx small packet detect interrupt register)
 *   size	(size 12, offset 0, init 0):	RW	Max size of small packet
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
static inline e1000_rsrpd_t e1000_rsrpd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rsrpd_t e1000_rsrpd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c00));
}

static inline e1000_rsrpd_t e1000_rsrpd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rsrpd_t e1000_rsrpd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c00));
}

static inline void e1000_rsrpd_rawwr(__DN(t) *_dev, e1000_rsrpd_t _regval) __attribute__ ((always_inline));
static inline void e1000_rsrpd_rawwr(__DN(t) *_dev, e1000_rsrpd_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c00, _regval);
}

static inline void e1000_rsrpd_wr(__DN(t) *_dev, e1000_rsrpd_t _regval) __attribute__ ((always_inline));
static inline void e1000_rsrpd_wr(__DN(t) *_dev, e1000_rsrpd_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c00, _regval);
}

static inline int e1000_rsrpd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rsrpd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rsrpd_t _regval = mackerel_read_addr_32(_dev->base, 0x2c00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rsrpd (Rx small packet detect interrupt): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Max size of small packet)\n", e1000_rsrpd_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint16_t e1000_rsrpd_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_rsrpd_size_rdf(__DN(t) *_dev)
{
    e1000_rsrpd_t _regval = mackerel_read_addr_32(_dev->base, 0x2c00);
    return(e1000_rsrpd_size_extract(_regval));
}

static inline void e1000_rsrpd_size_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rsrpd_size_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_rsrpd_t _regval = 0xfff & (((e1000_rsrpd_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c00, _regval);
    // No shadow register to write to
}

/*
 * Register raid: Rx ACK interrupt delay
 * Type: e1000.raid (Implicit type of Rx ACK interrupt delay register)
 *   idv	(size 16, offset 0, init 0):	RW	Interrupt delay value (x 1.024us)
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline e1000_raid_t e1000_raid_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_raid_t e1000_raid_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c08));
}

static inline e1000_raid_t e1000_raid_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_raid_t e1000_raid_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c08));
}

static inline void e1000_raid_rawwr(__DN(t) *_dev, e1000_raid_t _regval) __attribute__ ((always_inline));
static inline void e1000_raid_rawwr(__DN(t) *_dev, e1000_raid_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c08, _regval);
}

static inline void e1000_raid_wr(__DN(t) *_dev, e1000_raid_t _regval) __attribute__ ((always_inline));
static inline void e1000_raid_wr(__DN(t) *_dev, e1000_raid_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c08, _regval);
}

static inline int e1000_raid_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_raid_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_raid_t _regval = mackerel_read_addr_32(_dev->base, 0x2c08);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register raid (Rx ACK interrupt delay): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interrupt delay value (x 1.024us))\n", e1000_raid_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e1000_raid_idv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_raid_idv_rdf(__DN(t) *_dev)
{
    e1000_raid_t _regval = mackerel_read_addr_32(_dev->base, 0x2c08);
    return(e1000_raid_idv_extract(_regval));
}

static inline void e1000_raid_idv_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_raid_idv_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_raid_t _regval = 0xffff & (((e1000_raid_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2c08, _regval);
    // No shadow register to write to
}

/*
 * Register cpuvec: CPU vector
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_cpuvec_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_cpuvec_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c10));
}

static inline uint32_t e1000_cpuvec_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_cpuvec_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2c10));
}

static inline void e1000_cpuvec_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_cpuvec_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2c10, _regval);
}

static inline void e1000_cpuvec_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_cpuvec_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x2c10, _regval);
}

static inline int e1000_cpuvec_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_cpuvec_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2c10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cpuvec (CPU vector): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rxcsum: Receive checksum control
 * Type: e1000.rxcsum (Implicit type of Receive checksum control register)
 *   pcss	(size 8, offset 0, init 0):	RW	Packet checksum start
 *   ipofld	(size 1, offset 8, init 0):	RW	IP checksum offload enable
 *   tuofld	(size 1, offset 9, init 0):	RW	TCP/UDP checksum offload enable
 *   _anon10	(size 22, offset 10, init 0):	MBZ	_
 */
static inline e1000_rxcsum_t e1000_rxcsum_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rxcsum_t e1000_rxcsum_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5000));
}

static inline e1000_rxcsum_t e1000_rxcsum_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rxcsum_t e1000_rxcsum_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5000));
}

static inline void e1000_rxcsum_rawwr(__DN(t) *_dev, e1000_rxcsum_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxcsum_rawwr(__DN(t) *_dev, e1000_rxcsum_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
}

static inline void e1000_rxcsum_wr(__DN(t) *_dev, e1000_rxcsum_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxcsum_wr(__DN(t) *_dev, e1000_rxcsum_t _regval)
{
    _regval = (_regval & 0x3ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
}

static inline int e1000_rxcsum_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rxcsum_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rxcsum_t _regval = mackerel_read_addr_32(_dev->base, 0x5000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxcsum (Receive checksum control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcss =\t%" PRIx8 "\t(Packet checksum start)\n", e1000_rxcsum_pcss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipofld =\t%" PRIx8 "\t(IP checksum offload enable)\n", e1000_rxcsum_ipofld_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tuofld =\t%" PRIx8 "\t(TCP/UDP checksum offload enable)\n", e1000_rxcsum_tuofld_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline uint8_t e1000_rxcsum_pcss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcsum_pcss_rdf(__DN(t) *_dev)
{
    e1000_rxcsum_t _regval = mackerel_read_addr_32(_dev->base, 0x5000);
    return(e1000_rxcsum_pcss_extract(_regval));
}

static inline uint8_t e1000_rxcsum_ipofld_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcsum_ipofld_rdf(__DN(t) *_dev)
{
    e1000_rxcsum_t _regval = mackerel_read_addr_32(_dev->base, 0x5000);
    return(e1000_rxcsum_ipofld_extract(_regval));
}

static inline uint8_t e1000_rxcsum_tuofld_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rxcsum_tuofld_rdf(__DN(t) *_dev)
{
    e1000_rxcsum_t _regval = mackerel_read_addr_32(_dev->base, 0x5000);
    return(e1000_rxcsum_tuofld_extract(_regval));
}

static inline void e1000_rxcsum_pcss_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxcsum_pcss_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rxcsum_t _regval = 0xff & (((e1000_rxcsum_t )(_fieldval)) << 0);
    _regval = (_regval | (0x300 & mackerel_read_addr_32(_dev->base, 0x5000)));
    // No read of register shadow required
    _regval = (_regval & 0x3ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
    // No shadow register to write to
}

static inline void e1000_rxcsum_ipofld_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxcsum_ipofld_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rxcsum_t _regval = 0x100 & (((e1000_rxcsum_t )(_fieldval)) << 8);
    _regval = (_regval | (0x2ff & mackerel_read_addr_32(_dev->base, 0x5000)));
    // No read of register shadow required
    _regval = (_regval & 0x3ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
    // No shadow register to write to
}

static inline void e1000_rxcsum_tuofld_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rxcsum_tuofld_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rxcsum_t _regval = 0x200 & (((e1000_rxcsum_t )(_fieldval)) << 9);
    _regval = (_regval | (0x1ff & mackerel_read_addr_32(_dev->base, 0x5000)));
    // No read of register shadow required
    _regval = (_regval & 0x3ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
    // No shadow register to write to
}

/*
 * Register rfctl: Receive filter control
 * Type: e1000.rfctl (Implicit type of Receive filter control register)
 *   iscsi_dis	(size 1, offset 0, init 0):	RW	iSCSI filtering disable
 *   iscsi_dwc	(size 5, offset 1, init 0):	RW	iSCSI dword count
 *   nfsw_dis	(size 1, offset 6, init 0):	RW	NFS write filtering disable
 *   nfsr_dis	(size 1, offset 7, init 0):	RW	NFS read filtering disable
 *   nfs_ver	(size 2, offset 8, init 0):	RW	NFS version (+2)
 *   ipv6_dis	(size 1, offset 10, init 0):	RW	IPv6 filtering disable
 *   ipv6xsum_dis	(size 1, offset 11, init 0):	RW	IPv6 xsum disable
 *   ackdis	(size 1, offset 12, init 0):	RW	ACK accelerator disable
 *   ackd_dis	(size 1, offset 13, init 0):	RW	ACK data disable
 *   ipfrsp_dis	(size 1, offset 14, init 0):	RW	IP fragment split disable
 *   exsten	(size 1, offset 15, init 0):	RW	Extended status enable
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline e1000_rfctl_t e1000_rfctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5008));
}

static inline e1000_rfctl_t e1000_rfctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_rfctl_t e1000_rfctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5008));
}

static inline void e1000_rfctl_rawwr(__DN(t) *_dev, e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_rfctl_rawwr(__DN(t) *_dev, e1000_rfctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
}

static inline void e1000_rfctl_wr(__DN(t) *_dev, e1000_rfctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_rfctl_wr(__DN(t) *_dev, e1000_rfctl_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
}

static inline int e1000_rfctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rfctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rfctl (Receive filter control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iscsi_dis =\t%" PRIx8 "\t(iSCSI filtering disable)\n", e1000_rfctl_iscsi_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iscsi_dwc =\t%" PRIx8 "\t(iSCSI dword count)\n", e1000_rfctl_iscsi_dwc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsw_dis =\t%" PRIx8 "\t(NFS write filtering disable)\n", e1000_rfctl_nfsw_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsr_dis =\t%" PRIx8 "\t(NFS read filtering disable)\n", e1000_rfctl_nfsr_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfs_ver =\t%" PRIx8 "\t(NFS version (+2))\n", e1000_rfctl_nfs_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6_dis =\t%" PRIx8 "\t(IPv6 filtering disable)\n", e1000_rfctl_ipv6_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6xsum_dis =\t%" PRIx8 "\t(IPv6 xsum disable)\n", e1000_rfctl_ipv6xsum_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ackdis =\t%" PRIx8 "\t(ACK accelerator disable)\n", e1000_rfctl_ackdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ackd_dis =\t%" PRIx8 "\t(ACK data disable)\n", e1000_rfctl_ackd_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipfrsp_dis =\t%" PRIx8 "\t(IP fragment split disable)\n", e1000_rfctl_ipfrsp_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " exsten =\t%" PRIx8 "\t(Extended status enable)\n", e1000_rfctl_exsten_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e1000_rfctl_iscsi_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_iscsi_dis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_iscsi_dis_extract(_regval));
}

static inline uint8_t e1000_rfctl_iscsi_dwc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_iscsi_dwc_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_iscsi_dwc_extract(_regval));
}

static inline uint8_t e1000_rfctl_nfsw_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_nfsw_dis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_nfsw_dis_extract(_regval));
}

static inline uint8_t e1000_rfctl_nfsr_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_nfsr_dis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_nfsr_dis_extract(_regval));
}

static inline uint8_t e1000_rfctl_nfs_ver_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_nfs_ver_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_nfs_ver_extract(_regval));
}

static inline uint8_t e1000_rfctl_ipv6_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ipv6_dis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_ipv6_dis_extract(_regval));
}

static inline uint8_t e1000_rfctl_ipv6xsum_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ipv6xsum_dis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_ipv6xsum_dis_extract(_regval));
}

static inline uint8_t e1000_rfctl_ackdis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ackdis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_ackdis_extract(_regval));
}

static inline uint8_t e1000_rfctl_ackd_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ackd_dis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_ackd_dis_extract(_regval));
}

static inline uint8_t e1000_rfctl_ipfrsp_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_ipfrsp_dis_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_ipfrsp_dis_extract(_regval));
}

static inline uint8_t e1000_rfctl_exsten_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_rfctl_exsten_rdf(__DN(t) *_dev)
{
    e1000_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e1000_rfctl_exsten_extract(_regval));
}

static inline void e1000_rfctl_iscsi_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_iscsi_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x1 & (((e1000_rfctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffe & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_iscsi_dwc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_iscsi_dwc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x3e & (((e1000_rfctl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffc1 & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_nfsw_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_nfsw_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x40 & (((e1000_rfctl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffbf & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_nfsr_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_nfsr_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x80 & (((e1000_rfctl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xff7f & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_nfs_ver_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_nfs_ver_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x300 & (((e1000_rfctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfcff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_ipv6_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_ipv6_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x400 & (((e1000_rfctl_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfbff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_ipv6xsum_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_ipv6xsum_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x800 & (((e1000_rfctl_t )(_fieldval)) << 11);
    _regval = (_regval | (0xf7ff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_ackdis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_ackdis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x1000 & (((e1000_rfctl_t )(_fieldval)) << 12);
    _regval = (_regval | (0xefff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_ackd_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_ackd_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x2000 & (((e1000_rfctl_t )(_fieldval)) << 13);
    _regval = (_regval | (0xdfff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_ipfrsp_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_ipfrsp_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x4000 & (((e1000_rfctl_t )(_fieldval)) << 14);
    _regval = (_regval | (0xbfff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e1000_rfctl_exsten_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rfctl_exsten_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_rfctl_t _regval = 0x8000 & (((e1000_rfctl_t )(_fieldval)) << 15);
    _regval = (_regval | (0x7fff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

/*
 * Register tctl: Transmit control
 * Type: e1000.tctl (Implicit type of Transmit control register)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   en	(size 1, offset 1, init 0):	RW	Transmit enable
 *   _anon2	(size 1, offset 2, init 0):	MBZ	_
 *   psp	(size 1, offset 3, init 0):	RW	Pad short packets
 *   ct	(size 8, offset 4, init 0):	RW	Collision threshold
 *   bst	(size 10, offset 12, init 0):	RW	Back-Off Slot time
 *   swxoff	(size 1, offset 22, init 0):	RW	Software XOFF transmission
 *   _anon23	(size 1, offset 23, init 0):	MBZ	_
 *   rtlc	(size 1, offset 24, init 0):	RW	Retransmit on late collision
 *   unortx	(size 1, offset 25, init 0):	RW	Underrun no re-transmit
 *   txcscmt	(size 2, offset 26, init 0):	RW	Tx descriptor minimum threshold
 *   mulr	(size 1, offset 28, init 0):	RW	Multiple request support
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static inline e1000_tctl_t e1000_tctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline e1000_tctl_t e1000_tctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tctl_t e1000_tctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline void e1000_tctl_rawwr(__DN(t) *_dev, e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_tctl_rawwr(__DN(t) *_dev, e1000_tctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline void e1000_tctl_wr(__DN(t) *_dev, e1000_tctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_tctl_wr(__DN(t) *_dev, e1000_tctl_t _regval)
{
    _regval = (_regval & 0x1f7ffffa);
    // No MB1 fields present
    _regval = (_regval | (0xe0000000 & mackerel_read_addr_32(_dev->base, 0x400)));
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

static inline int e1000_tctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tctl (Transmit control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en =\t%" PRIx8 "\t(Transmit enable)\n", e1000_tctl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " psp =\t%" PRIx8 "\t(Pad short packets)\n", e1000_tctl_psp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ct =\t%" PRIx8 "\t(Collision threshold)\n", e1000_tctl_ct_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bst =\t%" PRIx16 "\t(Back-Off Slot time)\n", e1000_tctl_bst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swxoff =\t%" PRIx8 "\t(Software XOFF transmission)\n", e1000_tctl_swxoff_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtlc =\t%" PRIx8 "\t(Retransmit on late collision)\n", e1000_tctl_rtlc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " unortx =\t%" PRIx8 "\t(Underrun no re-transmit)\n", e1000_tctl_unortx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcscmt =\t%" PRIx8 "\t(Tx descriptor minimum threshold)\n", e1000_tctl_txcscmt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mulr =\t%" PRIx8 "\t(Multiple request support)\n", e1000_tctl_mulr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline uint8_t e1000_tctl_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_en_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_en_extract(_regval));
}

static inline uint8_t e1000_tctl_psp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_psp_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_psp_extract(_regval));
}

static inline uint8_t e1000_tctl_ct_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_ct_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_ct_extract(_regval));
}

static inline uint16_t e1000_tctl_bst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_tctl_bst_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_bst_extract(_regval));
}

static inline uint8_t e1000_tctl_swxoff_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_swxoff_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_swxoff_extract(_regval));
}

static inline uint8_t e1000_tctl_rtlc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_rtlc_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_rtlc_extract(_regval));
}

static inline uint8_t e1000_tctl_unortx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_unortx_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_unortx_extract(_regval));
}

static inline uint8_t e1000_tctl_txcscmt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_txcscmt_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_txcscmt_extract(_regval));
}

static inline uint8_t e1000_tctl_mulr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tctl_mulr_rdf(__DN(t) *_dev)
{
    e1000_tctl_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(e1000_tctl_mulr_extract(_regval));
}

static inline void e1000_tctl_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0x2 & (((e1000_tctl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xff7ffff8 & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_psp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_psp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0x8 & (((e1000_tctl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xff7ffff2 & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_ct_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_ct_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0xff0 & (((e1000_tctl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xff7ff00a & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_bst_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_bst_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_tctl_t _regval = 0x3ff000 & (((e1000_tctl_t )(_fieldval)) << 12);
    _regval = (_regval | (0xff400ffa & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_swxoff_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_swxoff_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0x400000 & (((e1000_tctl_t )(_fieldval)) << 22);
    _regval = (_regval | (0xff3ffffa & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_rtlc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_rtlc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0x1000000 & (((e1000_tctl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfe7ffffa & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_unortx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_unortx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0x2000000 & (((e1000_tctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfd7ffffa & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_txcscmt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_txcscmt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0xc000000 & (((e1000_tctl_t )(_fieldval)) << 26);
    _regval = (_regval | (0xf37ffffa & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

static inline void e1000_tctl_mulr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_mulr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tctl_t _regval = 0x10000000 & (((e1000_tctl_t )(_fieldval)) << 28);
    _regval = (_regval | (0xef7ffffa & mackerel_read_addr_32(_dev->base, 0x400)));
    // No read of register shadow required
    _regval = (_regval & 0xff7ffffa);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
    // No shadow register to write to
}

/*
 * Register tctl_ext: Transmit control extended
 * Type: e1000.tctl_ext (Implicit type of Transmit control extended register)
 *   _anon0	(size 10, offset 0, init 0):	MBZ	_
 *   cold	(size 10, offset 10, init 0):	RW	Collision distance
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline e1000_tctl_ext_t e1000_tctl_ext_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tctl_ext_t e1000_tctl_ext_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404));
}

static inline e1000_tctl_ext_t e1000_tctl_ext_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tctl_ext_t e1000_tctl_ext_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404));
}

static inline void e1000_tctl_ext_rawwr(__DN(t) *_dev, e1000_tctl_ext_t _regval) __attribute__ ((always_inline));
static inline void e1000_tctl_ext_rawwr(__DN(t) *_dev, e1000_tctl_ext_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x404, _regval);
}

static inline void e1000_tctl_ext_wr(__DN(t) *_dev, e1000_tctl_ext_t _regval) __attribute__ ((always_inline));
static inline void e1000_tctl_ext_wr(__DN(t) *_dev, e1000_tctl_ext_t _regval)
{
    _regval = (_regval & 0xffc00);
    // No MB1 fields present
    _regval = (_regval | (0xfff00000 & mackerel_read_addr_32(_dev->base, 0x404)));
    mackerel_write_addr_32(_dev->base, 0x404, _regval);
}

static inline int e1000_tctl_ext_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tctl_ext_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_tctl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x404);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tctl_ext (Transmit control extended): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cold =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_coldist_prtval(_s + _r, _avail, e1000_tctl_ext_cold_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Collision distance)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline e1000_coldist_t e1000_tctl_ext_cold_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_coldist_t e1000_tctl_ext_cold_rdf(__DN(t) *_dev)
{
    e1000_tctl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x404);
    return(e1000_tctl_ext_cold_extract(_regval));
}

static inline void e1000_tctl_ext_cold_wrf(__DN(t) *_dev, e1000_coldist_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tctl_ext_cold_wrf(__DN(t) *_dev, e1000_coldist_t _fieldval)
{
    e1000_tctl_ext_t _regval = 0xffc00 & (((e1000_tctl_ext_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfff00000 & mackerel_read_addr_32(_dev->base, 0x404)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc00);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x404, _regval);
    // No shadow register to write to
}

/*
 * Register tipg: Transmit IPQ
 * Type: e1000.tipg (Implicit type of Transmit IPQ register)
 *   ipgt	(size 10, offset 0, init 0):	RW	IPG back to back (x MAC clock, +4)
 *   ipgr1	(size 10, offset 10, init 0):	RW	IPG Part 1
 *   ipgr2	(size 10, offset 20, init 0):	RW	IPG after deferral
 *   _anon30	(size 2, offset 30, init 0):	MBZ	_
 */
static inline e1000_tipg_t e1000_tipg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tipg_t e1000_tipg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline e1000_tipg_t e1000_tipg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tipg_t e1000_tipg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline void e1000_tipg_rawwr(__DN(t) *_dev, e1000_tipg_t _regval) __attribute__ ((always_inline));
static inline void e1000_tipg_rawwr(__DN(t) *_dev, e1000_tipg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline void e1000_tipg_wr(__DN(t) *_dev, e1000_tipg_t _regval) __attribute__ ((always_inline));
static inline void e1000_tipg_wr(__DN(t) *_dev, e1000_tipg_t _regval)
{
    _regval = (_regval & 0x3fffffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline int e1000_tipg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tipg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_tipg_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tipg (Transmit IPQ): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipgt =\t%" PRIx16 "\t(IPG back to back (x MAC clock, +4))\n", e1000_tipg_ipgt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipgr1 =\t%" PRIx16 "\t(IPG Part 1)\n", e1000_tipg_ipgr1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipgr2 =\t%" PRIx16 "\t(IPG after deferral)\n", e1000_tipg_ipgr2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline uint16_t e1000_tipg_ipgt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_tipg_ipgt_rdf(__DN(t) *_dev)
{
    e1000_tipg_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    return(e1000_tipg_ipgt_extract(_regval));
}

static inline uint16_t e1000_tipg_ipgr1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_tipg_ipgr1_rdf(__DN(t) *_dev)
{
    e1000_tipg_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    return(e1000_tipg_ipgr1_extract(_regval));
}

static inline uint16_t e1000_tipg_ipgr2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_tipg_ipgr2_rdf(__DN(t) *_dev)
{
    e1000_tipg_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    return(e1000_tipg_ipgr2_extract(_regval));
}

static inline void e1000_tipg_ipgt_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tipg_ipgt_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_tipg_t _regval = 0x3ff & (((e1000_tipg_t )(_fieldval)) << 0);
    _regval = (_regval | (0x3ffffc00 & mackerel_read_addr_32(_dev->base, 0x410)));
    // No read of register shadow required
    _regval = (_regval & 0x3fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
    // No shadow register to write to
}

static inline void e1000_tipg_ipgr1_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tipg_ipgr1_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_tipg_t _regval = 0xffc00 & (((e1000_tipg_t )(_fieldval)) << 10);
    _regval = (_regval | (0x3ff003ff & mackerel_read_addr_32(_dev->base, 0x410)));
    // No read of register shadow required
    _regval = (_regval & 0x3fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
    // No shadow register to write to
}

static inline void e1000_tipg_ipgr2_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tipg_ipgr2_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_tipg_t _regval = 0x3ff00000 & (((e1000_tipg_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfffff & mackerel_read_addr_32(_dev->base, 0x410)));
    // No read of register shadow required
    _regval = (_regval & 0x3fffffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
    // No shadow register to write to
}

/*
 * Register array tdbal: Tx descr. base addr. low
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_tdbal_length = 2;
static inline uint32_t e1000_tdbal_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_tdbal_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3800 + (_i * 256)));
}

static inline uint32_t e1000_tdbal_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_tdbal_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3800 + (_i * 256)));
}

static inline void e1000_tdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3800 + (_i * 256), _regval);
}

static inline void e1000_tdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3800 + (_i * 256), _regval);
}

static inline int e1000_tdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_tdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3800 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdbal", _i, "Tx descr. base addr. low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_tdbal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tdbal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_tdbal_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array tdbah: Tx descr. base addr. hi
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_tdbah_length = 2;
static inline uint32_t e1000_tdbah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_tdbah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3804 + (_i * 256)));
}

static inline uint32_t e1000_tdbah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_tdbah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3804 + (_i * 256)));
}

static inline void e1000_tdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3804 + (_i * 256), _regval);
}

static inline void e1000_tdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3804 + (_i * 256), _regval);
}

static inline int e1000_tdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_tdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3804 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdbah", _i, "Tx descr. base addr. hi");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_tdbah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tdbah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_tdbah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array tdlen: Tx descr. length
 * Type: e1000.dqlen (Descriptor length value)
 *   _anon0	(size 7, offset 0, init 0):	MBZ	_
 *   len	(size 13, offset 7, init 0):	RW	Num. descriptors (x8)
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static const size_t e1000_tdlen_length = 2;
static inline e1000_dqlen_t e1000_tdlen_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqlen_t e1000_tdlen_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3808 + (_i * 256)));
}

static inline e1000_dqlen_t e1000_tdlen_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqlen_t e1000_tdlen_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3808 + (_i * 256)));
}

static inline void e1000_tdlen_rawwr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdlen_rawwr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3808 + (_i * 256), _regval);
}

static inline void e1000_tdlen_wr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdlen_wr(__DN(t) *_dev, int _i, e1000_dqlen_t _regval)
{
    _regval = (_regval & 0xfff80);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3808 + (_i * 256), _regval);
}

static inline int e1000_tdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_tdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_dqlen_t _regval = mackerel_read_addr_32(_dev->base, 0x3808 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdlen", _i, "Tx descr. length");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx16 "\t(Num. descriptors (x8))\n", e1000_dqlen_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline int e1000_tdlen_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tdlen_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_tdlen_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_tdlen_len_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_tdlen_len_rdf(__DN(t) *_dev, int _i)
{
    e1000_dqlen_t _regval = mackerel_read_addr_32(_dev->base, 0x3808 + (_i * 256));
    return(e1000_dqlen_len_extract(_regval));
}

static inline void e1000_tdlen_len_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tdlen_len_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_dqlen_t _regval = 0xfff80 & (((e1000_dqlen_t )(_fieldval)) << 7);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfff80);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3808 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register array tdh: Tx descr. head
 * Type: e1000.dqval (Descriptor head/tail value)
 *   val	(size 16, offset 0, init 0):	RW	value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static const size_t e1000_tdh_length = 2;
static inline e1000_dqval_t e1000_tdh_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_tdh_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3810 + (_i * 256)));
}

static inline e1000_dqval_t e1000_tdh_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_tdh_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3810 + (_i * 256)));
}

static inline void e1000_tdh_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdh_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3810 + (_i * 256), _regval);
}

static inline void e1000_tdh_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdh_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3810 + (_i * 256), _regval);
}

static inline int e1000_tdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_tdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x3810 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdh", _i, "Tx descr. head");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t(value)\n", e1000_dqval_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int e1000_tdh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tdh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_tdh_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_tdh_val_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_tdh_val_rdf(__DN(t) *_dev, int _i)
{
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x3810 + (_i * 256));
    return(e1000_dqval_val_extract(_regval));
}

static inline void e1000_tdh_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tdh_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_dqval_t _regval = 0xffff & (((e1000_dqval_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3810 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register array tdt: Tx descr. tail
 * Type: e1000.dqval (Descriptor head/tail value)
 *   val	(size 16, offset 0, init 0):	RW	value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static const size_t e1000_tdt_length = 2;
static inline e1000_dqval_t e1000_tdt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_tdt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3818 + (_i * 256)));
}

static inline e1000_dqval_t e1000_tdt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_dqval_t e1000_tdt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3818 + (_i * 256)));
}

static inline void e1000_tdt_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdt_rawwr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3818 + (_i * 256), _regval);
}

static inline void e1000_tdt_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval) __attribute__ ((always_inline));
static inline void e1000_tdt_wr(__DN(t) *_dev, int _i, e1000_dqval_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3818 + (_i * 256), _regval);
}

static inline int e1000_tdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_tdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x3818 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdt", _i, "Tx descr. tail");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val =\t%" PRIx16 "\t(value)\n", e1000_dqval_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline int e1000_tdt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tdt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_tdt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_tdt_val_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_tdt_val_rdf(__DN(t) *_dev, int _i)
{
    e1000_dqval_t _regval = mackerel_read_addr_32(_dev->base, 0x3818 + (_i * 256));
    return(e1000_dqval_val_extract(_regval));
}

static inline void e1000_tdt_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tdt_val_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_dqval_t _regval = 0xffff & (((e1000_dqval_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3818 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register tidv: Transmit interrupt delay value
 * Type: e1000.tidv (Implicit type of Transmit interrupt delay value register)
 *   idv	(size 16, offset 0, init 0):	RW	Interupt delay value
 *   _anon16	(size 15, offset 16, init 0):	MBZ	_
 *   fdp	(size 1, offset 31, init 0):	WO	Flush partial description block
 */
static inline e1000_tidv_t e1000_tidv_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tidv_t e1000_tidv_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3820));
}

static inline e1000_tidv_t e1000_tidv_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tidv_t e1000_tidv_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3820));
}

static inline void e1000_tidv_rawwr(__DN(t) *_dev, e1000_tidv_t _regval) __attribute__ ((always_inline));
static inline void e1000_tidv_rawwr(__DN(t) *_dev, e1000_tidv_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3820, _regval);
}

static inline void e1000_tidv_wr(__DN(t) *_dev, e1000_tidv_t _regval) __attribute__ ((always_inline));
static inline void e1000_tidv_wr(__DN(t) *_dev, e1000_tidv_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3820, _regval);
}

static inline int e1000_tidv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tidv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_tidv_t _regval = mackerel_read_addr_32(_dev->base, 0x3820);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tidv (Transmit interrupt delay value): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interupt delay value)\n", e1000_tidv_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fdp =\t%" PRIx8 "\t(Flush partial description block)\n", e1000_tidv_fdp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e1000_tidv_idv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_tidv_idv_rdf(__DN(t) *_dev)
{
    e1000_tidv_t _regval = mackerel_read_addr_32(_dev->base, 0x3820);
    return(e1000_tidv_idv_extract(_regval));
}

static inline uint8_t e1000_tidv_fdp_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_tidv_fdp_rd_shadow(__DN(t) *_dev)
{
    return(e1000_tidv_fdp_extract(_dev->tidv_shadow));
}

static inline void e1000_tidv_idv_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tidv_idv_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_tidv_t _regval = 0xffff & (((e1000_tidv_t )(_fieldval)) << 0);
    // No pre-read of register required
    _regval = (_regval | (0x80000000 & (_dev->tidv_shadow)));
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3820, _regval);
    _dev->tidv_shadow = _regval;
}

static inline void e1000_tidv_fdp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tidv_fdp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_tidv_t _regval = 0x80000000 & (((e1000_tidv_t )(_fieldval)) << 31);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x3820)));
    // No read of register shadow required
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3820, _regval);
    _dev->tidv_shadow = _regval;
}

/*
 * Register array txdctl: Transmit descr. control queue
 * Type: e1000.txdctl (Implicit type of Transmit descr. control queue register array)
 *   pthresh	(size 6, offset 0, init 0):	RW	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 8, offset 8, init 0):	RW	Host threshold
 *   wthresh	(size 6, offset 16, init 0):	RW	Write back threshold
 *   _anon22	(size 1, offset 22, init 1):	MB1	_
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   gran	(size 1, offset 24, init 0):	RW	Granularity
 *   lwthresh	(size 7, offset 25, init 0):	RW	Transmit descriptor low threshold
 */
static const size_t e1000_txdctl_length = 2;
static inline e1000_txdctl_t e1000_txdctl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_txdctl_t e1000_txdctl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256)));
}

static inline e1000_txdctl_t e1000_txdctl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_txdctl_t e1000_txdctl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256)));
}

static inline void e1000_txdctl_rawwr(__DN(t) *_dev, int _i, e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_txdctl_rawwr(__DN(t) *_dev, int _i, e1000_txdctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
}

static inline void e1000_txdctl_wr(__DN(t) *_dev, int _i, e1000_txdctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_txdctl_wr(__DN(t) *_dev, int _i, e1000_txdctl_t _regval)
{
    _regval = (_regval & 0xff7fff3f);
    _regval = (_regval | 0x400000);
    _regval = (_regval | (0x800000 & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
}

static inline int e1000_txdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_txdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "txdctl", _i, "Transmit descr. control queue");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_txdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_txdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_txdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gran =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_threshgran_prtval(_s + _r, _avail, e1000_txdctl_gran_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Granularity)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lwthresh =\t%" PRIx8 "\t(Transmit descriptor low threshold)\n", e1000_txdctl_lwthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_txdctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_txdctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_txdctl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_txdctl_pthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_pthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_pthresh_extract(_regval));
}

static inline uint8_t e1000_txdctl_hthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_hthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_hthresh_extract(_regval));
}

static inline uint8_t e1000_txdctl_wthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_wthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_wthresh_extract(_regval));
}

static inline e1000_threshgran_t e1000_txdctl_gran_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_threshgran_t e1000_txdctl_gran_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_gran_extract(_regval));
}

static inline uint8_t e1000_txdctl_lwthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_lwthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_lwthresh_extract(_regval));
}

static inline void e1000_txdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_t _regval = 0x3f & (((e1000_txdctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffbfff00 & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x400000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_t _regval = 0xff00 & (((e1000_txdctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffbf003f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x400000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_t _regval = 0x3f0000 & (((e1000_txdctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff80ff3f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x400000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_gran_wrf(__DN(t) *_dev, int _i, e1000_threshgran_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_gran_wrf(__DN(t) *_dev, int _i, e1000_threshgran_t _fieldval)
{
    e1000_txdctl_t _regval = 0x1000000 & (((e1000_txdctl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfebfff3f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x400000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_lwthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_lwthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_t _regval = 0xfe000000 & (((e1000_txdctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0x1bfff3f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x400000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register array txdctl_82575: Transmit descr. control queue for 82575 cards
 * Type: e1000.txdctl_82575 (Implicit type of Transmit descr. control queue for 82575 cards register array)
 *   pthresh	(size 6, offset 0, init 0):	RW	Prefetch threshold
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   hthresh	(size 6, offset 8, init 0):	RW	Host threshold
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 *   wthresh	(size 6, offset 16, init 0):	RW	Write back threshold
 *   _anon22	(size 3, offset 22, init 7):	MB1	_
 *   enable	(size 1, offset 25, init 0):	RW	Enable the queue
 *   swflsh	(size 1, offset 26, init 0):	RW	Transmit Software Flush
 *   priority	(size 1, offset 27, init 0):	RW	Priority
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static const size_t e1000_txdctl_82575_length = 4;
static inline e1000_txdctl_82575_t e1000_txdctl_82575_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256)));
}

static inline e1000_txdctl_82575_t e1000_txdctl_82575_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_txdctl_82575_t e1000_txdctl_82575_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256)));
}

static inline void e1000_txdctl_82575_rawwr(__DN(t) *_dev, int _i, e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_rawwr(__DN(t) *_dev, int _i, e1000_txdctl_82575_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
}

static inline void e1000_txdctl_82575_wr(__DN(t) *_dev, int _i, e1000_txdctl_82575_t _regval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_wr(__DN(t) *_dev, int _i, e1000_txdctl_82575_t _regval)
{
    _regval = (_regval & 0xfff3f3f);
    _regval = (_regval | 0x1c00000);
    _regval = (_regval | (0xf000c000 & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
}

static inline int e1000_txdctl_82575_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_txdctl_82575_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_txdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "txdctl_82575", _i, "Transmit descr. control queue for 82575 cards");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Prefetch threshold)\n", e1000_txdctl_82575_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host threshold)\n", e1000_txdctl_82575_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write back threshold)\n", e1000_txdctl_82575_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Enable the queue)\n", e1000_txdctl_82575_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflsh =\t%" PRIx8 "\t(Transmit Software Flush)\n", e1000_txdctl_82575_swflsh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority)\n", e1000_txdctl_82575_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline int e1000_txdctl_82575_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_txdctl_82575_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_txdctl_82575_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_txdctl_82575_pthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_pthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_82575_pthresh_extract(_regval));
}

static inline uint8_t e1000_txdctl_82575_hthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_hthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_82575_hthresh_extract(_regval));
}

static inline uint8_t e1000_txdctl_82575_wthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_wthresh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_82575_wthresh_extract(_regval));
}

static inline uint8_t e1000_txdctl_82575_enable_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_enable_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_82575_enable_extract(_regval));
}

static inline uint8_t e1000_txdctl_82575_swflsh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_swflsh_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_82575_swflsh_extract(_regval));
}

static inline uint8_t e1000_txdctl_82575_priority_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_txdctl_82575_priority_rdf(__DN(t) *_dev, int _i)
{
    e1000_txdctl_82575_t _regval = mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256));
    return(e1000_txdctl_82575_priority_extract(_regval));
}

static inline void e1000_txdctl_82575_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_82575_t _regval = 0x3f & (((e1000_txdctl_82575_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe3fff00 & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x1c00000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_82575_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_82575_t _regval = 0x3f00 & (((e1000_txdctl_82575_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfe3fc03f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x1c00000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_82575_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_82575_t _regval = 0x3f0000 & (((e1000_txdctl_82575_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfe00ff3f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x1c00000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_82575_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_82575_t _regval = 0x2000000 & (((e1000_txdctl_82575_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfc3fff3f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x1c00000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_82575_swflsh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_swflsh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_82575_t _regval = 0x4000000 & (((e1000_txdctl_82575_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfa3fff3f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x1c00000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_txdctl_82575_priority_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_txdctl_82575_priority_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_txdctl_82575_t _regval = 0x8000000 & (((e1000_txdctl_82575_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf63fff3f & mackerel_read_addr_32(_dev->base, 0x3828 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff3f);
    _regval = (_regval | 0x1c00000);
    mackerel_write_addr_32(_dev->base, 0x3828 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register tadv: Tx absolute intr. delay
 * Type: e1000.tadv (Implicit type of Tx absolute intr. delay register)
 *   idv	(size 16, offset 0, init 0):	RW	Interrupt delay value
 *   _anon16	(size 16, offset 16, init 0):	MBZ	_
 */
static inline e1000_tadv_t e1000_tadv_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tadv_t e1000_tadv_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x382c));
}

static inline e1000_tadv_t e1000_tadv_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_tadv_t e1000_tadv_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x382c));
}

static inline void e1000_tadv_rawwr(__DN(t) *_dev, e1000_tadv_t _regval) __attribute__ ((always_inline));
static inline void e1000_tadv_rawwr(__DN(t) *_dev, e1000_tadv_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x382c, _regval);
}

static inline void e1000_tadv_wr(__DN(t) *_dev, e1000_tadv_t _regval) __attribute__ ((always_inline));
static inline void e1000_tadv_wr(__DN(t) *_dev, e1000_tadv_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x382c, _regval);
}

static inline int e1000_tadv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tadv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_tadv_t _regval = mackerel_read_addr_32(_dev->base, 0x382c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tadv (Tx absolute intr. delay): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " idv =\t%" PRIx16 "\t(Interrupt delay value)\n", e1000_tadv_idv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e1000_tadv_idv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_tadv_idv_rdf(__DN(t) *_dev)
{
    e1000_tadv_t _regval = mackerel_read_addr_32(_dev->base, 0x382c);
    return(e1000_tadv_idv_extract(_regval));
}

static inline void e1000_tadv_idv_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tadv_idv_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_tadv_t _regval = 0xffff & (((e1000_tadv_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x382c, _regval);
    // No shadow register to write to
}

/*
 * Register array tarc: Tx arbitration counter
 * Type: e1000.tarc (Implicit type of Tx arbitration counter register array)
 *   count	(size 7, offset 0, init 0):	RW	Transmit arbitration count
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   ratio	(size 2, offset 8, init 0):	RW	Compensation ratio (1 / 2^val)
 *   enable	(size 1, offset 10, init 1):	MB1	enable
 *   _anon11	(size 10, offset 11, init 0):	MBZ	_
 *   _anon21	(size 1, offset 21, init 1):	MB1	_
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   _anon23	(size 4, offset 23, init f):	MB1	_
 *   _anon27	(size 5, offset 27, init 0):	MBZ	_
 */
static const size_t e1000_tarc_length = 2;
static inline e1000_tarc_t e1000_tarc_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_tarc_t e1000_tarc_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256)));
}

static inline e1000_tarc_t e1000_tarc_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_tarc_t e1000_tarc_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256)));
}

static inline void e1000_tarc_rawwr(__DN(t) *_dev, int _i, e1000_tarc_t _regval) __attribute__ ((always_inline));
static inline void e1000_tarc_rawwr(__DN(t) *_dev, int _i, e1000_tarc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3840 + (_i * 256), _regval);
}

static inline void e1000_tarc_wr(__DN(t) *_dev, int _i, e1000_tarc_t _regval) __attribute__ ((always_inline));
static inline void e1000_tarc_wr(__DN(t) *_dev, int _i, e1000_tarc_t _regval)
{
    _regval = (_regval & 0x7a0077f);
    _regval = (_regval | 0x7a00400);
    _regval = (_regval | (0x80 & mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256))));
    mackerel_write_addr_32(_dev->base, 0x3840 + (_i * 256), _regval);
}

static inline int e1000_tarc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_tarc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_tarc_t _regval = mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tarc", _i, "Tx arbitration counter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count =\t%" PRIx8 "\t(Transmit arbitration count)\n", e1000_tarc_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ratio =\t%" PRIx8 "\t(Compensation ratio (1 / 2^val))\n", e1000_tarc_ratio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(enable)\n", e1000_tarc_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    // _anon21 is anonymous
    // _anon22 is anonymous
    // _anon23 is anonymous
    // _anon27 is anonymous
    return(_r);
}

static inline int e1000_tarc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tarc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_tarc_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_tarc_count_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_tarc_count_rdf(__DN(t) *_dev, int _i)
{
    e1000_tarc_t _regval = mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256));
    return(e1000_tarc_count_extract(_regval));
}

static inline uint8_t e1000_tarc_ratio_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_tarc_ratio_rdf(__DN(t) *_dev, int _i)
{
    e1000_tarc_t _regval = mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256));
    return(e1000_tarc_ratio_extract(_regval));
}

static inline void e1000_tarc_count_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tarc_count_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_tarc_t _regval = 0x7f & (((e1000_tarc_t )(_fieldval)) << 0);
    _regval = (_regval | (0x380 & mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x7a007ff);
    _regval = (_regval | 0x7a00400);
    mackerel_write_addr_32(_dev->base, 0x3840 + (_i * 256), _regval);
    // No shadow register to write to
}

static inline void e1000_tarc_ratio_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_tarc_ratio_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_tarc_t _regval = 0x300 & (((e1000_tarc_t )(_fieldval)) << 8);
    _regval = (_regval | (0xff & mackerel_read_addr_32(_dev->base, 0x3840 + (_i * 256))));
    // No read of register shadow required
    _regval = (_regval & 0x7a007ff);
    _regval = (_regval | 0x7a00400);
    mackerel_write_addr_32(_dev->base, 0x3840 + (_i * 256), _regval);
    // No shadow register to write to
}

/*
 * Register array mta: Multicast table array
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_mta_length = 128;
static inline uint32_t e1000_mta_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_mta_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5200 + (_i * (32 / 8))));
}

static inline uint32_t e1000_mta_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_mta_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5200 + (_i * (32 / 8))));
}

static inline void e1000_mta_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mta_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)), _regval);
}

static inline void e1000_mta_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mta_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)), _regval);
}

static inline int e1000_mta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_mta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mta", _i, "Multicast table array");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_mta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_mta_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ral: Receive address low
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_ral_length = 16;
static inline uint32_t e1000_ral_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_ral_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5400 + (_i * 8)));
}

static inline uint32_t e1000_ral_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_ral_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5400 + (_i * 8)));
}

static inline void e1000_ral_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ral_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5400 + (_i * 8), _regval);
}

static inline void e1000_ral_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ral_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5400 + (_i * 8), _regval);
}

static inline int e1000_ral_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_ral_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5400 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ral", _i, "Receive address low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_ral_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ral_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_ral_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rah: Receive address high
 * Type: e1000.rah (Implicit type of Receive address high register array)
 *   rah	(size 16, offset 0, init 0):	RW	Receive address high
 *   asel	(size 2, offset 16, init 0):	RW	Address select
 *   _anon18	(size 13, offset 18, init 0):	MBZ	_
 *   av	(size 1, offset 31, init 0):	RW	Address valid
 */
static const size_t e1000_rah_length = 16;
static inline e1000_rah_t e1000_rah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_rah_t e1000_rah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8)));
}

static inline e1000_rah_t e1000_rah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_rah_t e1000_rah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8)));
}

static inline void e1000_rah_rawwr(__DN(t) *_dev, int _i, e1000_rah_t _regval) __attribute__ ((always_inline));
static inline void e1000_rah_rawwr(__DN(t) *_dev, int _i, e1000_rah_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5404 + (_i * 8), _regval);
}

static inline void e1000_rah_wr(__DN(t) *_dev, int _i, e1000_rah_t _regval) __attribute__ ((always_inline));
static inline void e1000_rah_wr(__DN(t) *_dev, int _i, e1000_rah_t _regval)
{
    _regval = (_regval & 0x8003ffff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5404 + (_i * 8), _regval);
}

static inline int e1000_rah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_rah_t _regval = mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rah", _i, "Receive address high");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rah =\t%" PRIx16 "\t(Receive address high)\n", e1000_rah_rah_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asel =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_addrsel_prtval(_s + _r, _avail, e1000_rah_asel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Address select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " av =\t%" PRIx8 "\t(Address valid)\n", e1000_rah_av_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_rah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_rah_rah_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_rah_rah_rdf(__DN(t) *_dev, int _i)
{
    e1000_rah_t _regval = mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8));
    return(e1000_rah_rah_extract(_regval));
}

static inline e1000_addrsel_t e1000_rah_asel_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_addrsel_t e1000_rah_asel_rdf(__DN(t) *_dev, int _i)
{
    e1000_rah_t _regval = mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8));
    return(e1000_rah_asel_extract(_regval));
}

static inline uint8_t e1000_rah_av_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rah_av_rdf(__DN(t) *_dev, int _i)
{
    e1000_rah_t _regval = mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8));
    return(e1000_rah_av_extract(_regval));
}

static inline void e1000_rah_rah_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rah_rah_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_rah_t _regval = 0xffff & (((e1000_rah_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80030000 & mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8))));
    // No read of register shadow required
    _regval = (_regval & 0x8003ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5404 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void e1000_rah_asel_wrf(__DN(t) *_dev, int _i, e1000_addrsel_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rah_asel_wrf(__DN(t) *_dev, int _i, e1000_addrsel_t _fieldval)
{
    e1000_rah_t _regval = 0x30000 & (((e1000_rah_t )(_fieldval)) << 16);
    _regval = (_regval | (0x8000ffff & mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8))));
    // No read of register shadow required
    _regval = (_regval & 0x8003ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5404 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void e1000_rah_av_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_rah_av_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_rah_t _regval = 0x80000000 & (((e1000_rah_t )(_fieldval)) << 31);
    _regval = (_regval | (0x3ffff & mackerel_read_addr_32(_dev->base, 0x5404 + (_i * 8))));
    // No read of register shadow required
    _regval = (_regval & 0x8003ffff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5404 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register array vfta: VLAN filter table array
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_vfta_length = 128;
static inline uint32_t e1000_vfta_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_vfta_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5600 + (_i * (32 / 8))));
}

static inline uint32_t e1000_vfta_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_vfta_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5600 + (_i * (32 / 8))));
}

static inline void e1000_vfta_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_vfta_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5600 + (_i * (32 / 8)), _regval);
}

static inline void e1000_vfta_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_vfta_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5600 + (_i * (32 / 8)), _regval);
}

static inline int e1000_vfta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_vfta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5600 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfta", _i, "VLAN filter table array");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_vfta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_vfta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_vfta_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register mrq: Multiple queues receive command
 * Type: e1000.mrq (Implicit type of Multiple queues receive command register)
 *   mrqe	(size 2, offset 0, init 0):	RW	Multiple rx queues enable
 *   rssie	(size 1, offset 2, init 0):	RW	RSS interrupt enable
 *   _anon3	(size 13, offset 3, init 0):	MBZ	_
 *   tcp4	(size 1, offset 16, init 0):	RW	Enable TCP IPv4 hash
 *   ipv4	(size 1, offset 17, init 0):	RW	Enable IPv4 hash
 *   tcp6ex	(size 1, offset 18, init 0):	RW	Enable TCP IPv6 Ex hash
 *   ipv6ex	(size 1, offset 19, init 0):	RW	Enable IPv6 Ex hash
 *   ipv6	(size 1, offset 20, init 0):	RW	Enable IPv6 hash
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
static inline e1000_mrq_t e1000_mrq_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5818));
}

static inline e1000_mrq_t e1000_mrq_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_mrq_t e1000_mrq_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5818));
}

static inline void e1000_mrq_rawwr(__DN(t) *_dev, e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline void e1000_mrq_rawwr(__DN(t) *_dev, e1000_mrq_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
}

static inline void e1000_mrq_wr(__DN(t) *_dev, e1000_mrq_t _regval) __attribute__ ((always_inline));
static inline void e1000_mrq_wr(__DN(t) *_dev, e1000_mrq_t _regval)
{
    _regval = (_regval & 0x1f0007);
    // No MB1 fields present
    _regval = (_regval | (0xffe00000 & mackerel_read_addr_32(_dev->base, 0x5818)));
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
}

static inline int e1000_mrq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mrq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mrq (Multiple queues receive command): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mrqe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mrqen_prtval(_s + _r, _avail, e1000_mrq_mrqe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple rx queues enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rssie =\t%" PRIx8 "\t(RSS interrupt enable)\n", e1000_mrq_rssie_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp4 =\t%" PRIx8 "\t(Enable TCP IPv4 hash)\n", e1000_mrq_tcp4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv4 =\t%" PRIx8 "\t(Enable IPv4 hash)\n", e1000_mrq_ipv4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp6ex =\t%" PRIx8 "\t(Enable TCP IPv6 Ex hash)\n", e1000_mrq_tcp6ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6ex =\t%" PRIx8 "\t(Enable IPv6 Ex hash)\n", e1000_mrq_ipv6ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(Enable IPv6 hash)\n", e1000_mrq_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    return(_r);
}

static inline e1000_mrqen_t e1000_mrq_mrqe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_mrqen_t e1000_mrq_mrqe_rdf(__DN(t) *_dev)
{
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    return(e1000_mrq_mrqe_extract(_regval));
}

static inline uint8_t e1000_mrq_rssie_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_rssie_rdf(__DN(t) *_dev)
{
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    return(e1000_mrq_rssie_extract(_regval));
}

static inline uint8_t e1000_mrq_tcp4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_tcp4_rdf(__DN(t) *_dev)
{
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    return(e1000_mrq_tcp4_extract(_regval));
}

static inline uint8_t e1000_mrq_ipv4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_ipv4_rdf(__DN(t) *_dev)
{
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    return(e1000_mrq_ipv4_extract(_regval));
}

static inline uint8_t e1000_mrq_tcp6ex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_tcp6ex_rdf(__DN(t) *_dev)
{
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    return(e1000_mrq_tcp6ex_extract(_regval));
}

static inline uint8_t e1000_mrq_ipv6ex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_ipv6ex_rdf(__DN(t) *_dev)
{
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    return(e1000_mrq_ipv6ex_extract(_regval));
}

static inline uint8_t e1000_mrq_ipv6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_mrq_ipv6_rdf(__DN(t) *_dev)
{
    e1000_mrq_t _regval = mackerel_read_addr_32(_dev->base, 0x5818);
    return(e1000_mrq_ipv6_extract(_regval));
}

static inline void e1000_mrq_mrqe_wrf(__DN(t) *_dev, e1000_mrqen_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mrq_mrqe_wrf(__DN(t) *_dev, e1000_mrqen_t _fieldval)
{
    e1000_mrq_t _regval = 0x3 & (((e1000_mrq_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0004 & mackerel_read_addr_32(_dev->base, 0x5818)));
    // No read of register shadow required
    _regval = (_regval & 0xffff0007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
    // No shadow register to write to
}

static inline void e1000_mrq_rssie_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mrq_rssie_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mrq_t _regval = 0x4 & (((e1000_mrq_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffff0003 & mackerel_read_addr_32(_dev->base, 0x5818)));
    // No read of register shadow required
    _regval = (_regval & 0xffff0007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
    // No shadow register to write to
}

static inline void e1000_mrq_tcp4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mrq_tcp4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mrq_t _regval = 0x10000 & (((e1000_mrq_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffe0007 & mackerel_read_addr_32(_dev->base, 0x5818)));
    // No read of register shadow required
    _regval = (_regval & 0xffff0007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
    // No shadow register to write to
}

static inline void e1000_mrq_ipv4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mrq_ipv4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mrq_t _regval = 0x20000 & (((e1000_mrq_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffd0007 & mackerel_read_addr_32(_dev->base, 0x5818)));
    // No read of register shadow required
    _regval = (_regval & 0xffff0007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
    // No shadow register to write to
}

static inline void e1000_mrq_tcp6ex_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mrq_tcp6ex_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mrq_t _regval = 0x40000 & (((e1000_mrq_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffb0007 & mackerel_read_addr_32(_dev->base, 0x5818)));
    // No read of register shadow required
    _regval = (_regval & 0xffff0007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
    // No shadow register to write to
}

static inline void e1000_mrq_ipv6ex_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mrq_ipv6ex_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mrq_t _regval = 0x80000 & (((e1000_mrq_t )(_fieldval)) << 19);
    _regval = (_regval | (0xfff70007 & mackerel_read_addr_32(_dev->base, 0x5818)));
    // No read of register shadow required
    _regval = (_regval & 0xffff0007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
    // No shadow register to write to
}

static inline void e1000_mrq_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_mrq_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_mrq_t _regval = 0x100000 & (((e1000_mrq_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffef0007 & mackerel_read_addr_32(_dev->base, 0x5818)));
    // No read of register shadow required
    _regval = (_regval & 0xffff0007);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5818, _regval);
    // No shadow register to write to
}

/*
 * Register rssim: RSS interrupt mask
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_rssim_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rssim_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5864));
}

static inline uint32_t e1000_rssim_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rssim_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5864));
}

static inline void e1000_rssim_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rssim_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5864, _regval);
}

static inline void e1000_rssim_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rssim_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5864, _regval);
}

static inline int e1000_rssim_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rssim_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5864);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rssim (RSS interrupt mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rssir: RSS interrupt request
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_rssir_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rssir_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5868));
}

static inline uint32_t e1000_rssir_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rssir_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5868));
}

static inline void e1000_rssir_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rssir_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5868, _regval);
}

static inline void e1000_rssir_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rssir_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5868, _regval);
}

static inline int e1000_rssir_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rssir_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5868);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rssir (RSS interrupt request): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array reta: Redirection table
 * Type: e1000.uint8 (primitive type)
 */
static const size_t e1000_reta_length = 128;
static inline uint8_t e1000_reta_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_reta_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->base, 0x5c00 + (_i * (8 / 8))));
}

static inline uint8_t e1000_reta_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_reta_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->base, 0x5c00 + (_i * (8 / 8))));
}

static inline void e1000_reta_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void e1000_reta_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x5c00 + (_i * (8 / 8)), _regval);
}

static inline void e1000_reta_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void e1000_reta_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x5c00 + (_i * (8 / 8)), _regval);
}

static inline int e1000_reta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_reta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->base, 0x5c00 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "reta", _i, "Redirection table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_reta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_reta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_reta_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rssrk: RSS Random key
 * Type: e1000.uint8 (primitive type)
 */
static const size_t e1000_rssrk_length = 40;
static inline uint8_t e1000_rssrk_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rssrk_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->base, 0x5c80 + (_i * (8 / 8))));
}

static inline uint8_t e1000_rssrk_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_rssrk_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_8(_dev->base, 0x5c80 + (_i * (8 / 8))));
}

static inline void e1000_rssrk_rawwr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void e1000_rssrk_rawwr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    mackerel_write_addr_8(_dev->base, 0x5c80 + (_i * (8 / 8)), _regval);
}

static inline void e1000_rssrk_wr(__DN(t) *_dev, int _i, uint8_t _regval) __attribute__ ((always_inline));
static inline void e1000_rssrk_wr(__DN(t) *_dev, int _i, uint8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_8(_dev->base, 0x5c80 + (_i * (8 / 8)), _regval);
}

static inline int e1000_rssrk_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_rssrk_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint8_t _regval = mackerel_read_addr_8(_dev->base, 0x5c80 + (_i * (8 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rssrk", _i, "RSS Random key");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx8 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_rssrk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rssrk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 40; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_rssrk_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register wuc: Wakeup control
 * Type: e1000.wuc (Implicit type of Wakeup control register)
 *   apme	(size 1, offset 0, init 0):	RW	Advanced power mgmt enable
 *   pme_en	(size 1, offset 1, init 0):	RW	PME enable
 *   pme_stat	(size 1, offset 2, init 0):	RW	PME status
 *   apmpme	(size 1, offset 3, init 0):	RW	Assert PME on APM wakeup
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static inline e1000_wuc_t e1000_wuc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wuc_t e1000_wuc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5800));
}

static inline e1000_wuc_t e1000_wuc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wuc_t e1000_wuc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5800));
}

static inline void e1000_wuc_rawwr(__DN(t) *_dev, e1000_wuc_t _regval) __attribute__ ((always_inline));
static inline void e1000_wuc_rawwr(__DN(t) *_dev, e1000_wuc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5800, _regval);
}

static inline void e1000_wuc_wr(__DN(t) *_dev, e1000_wuc_t _regval) __attribute__ ((always_inline));
static inline void e1000_wuc_wr(__DN(t) *_dev, e1000_wuc_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x5800)));
    mackerel_write_addr_32(_dev->base, 0x5800, _regval);
}

static inline int e1000_wuc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_wuc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_wuc_t _regval = mackerel_read_addr_32(_dev->base, 0x5800);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wuc (Wakeup control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apme =\t%" PRIx8 "\t(Advanced power mgmt enable)\n", e1000_wuc_apme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pme_en =\t%" PRIx8 "\t(PME enable)\n", e1000_wuc_pme_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pme_stat =\t%" PRIx8 "\t(PME status)\n", e1000_wuc_pme_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apmpme =\t%" PRIx8 "\t(Assert PME on APM wakeup)\n", e1000_wuc_apmpme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t e1000_wuc_apme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_apme_rdf(__DN(t) *_dev)
{
    e1000_wuc_t _regval = mackerel_read_addr_32(_dev->base, 0x5800);
    return(e1000_wuc_apme_extract(_regval));
}

static inline uint8_t e1000_wuc_pme_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_pme_en_rdf(__DN(t) *_dev)
{
    e1000_wuc_t _regval = mackerel_read_addr_32(_dev->base, 0x5800);
    return(e1000_wuc_pme_en_extract(_regval));
}

static inline uint8_t e1000_wuc_pme_stat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_pme_stat_rdf(__DN(t) *_dev)
{
    e1000_wuc_t _regval = mackerel_read_addr_32(_dev->base, 0x5800);
    return(e1000_wuc_pme_stat_extract(_regval));
}

static inline uint8_t e1000_wuc_apmpme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wuc_apmpme_rdf(__DN(t) *_dev)
{
    e1000_wuc_t _regval = mackerel_read_addr_32(_dev->base, 0x5800);
    return(e1000_wuc_apmpme_extract(_regval));
}

static inline void e1000_wuc_apme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wuc_apme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wuc_t _regval = 0x1 & (((e1000_wuc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x5800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5800, _regval);
    // No shadow register to write to
}

static inline void e1000_wuc_pme_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wuc_pme_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wuc_t _regval = 0x2 & (((e1000_wuc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x5800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5800, _regval);
    // No shadow register to write to
}

static inline void e1000_wuc_pme_stat_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wuc_pme_stat_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wuc_t _regval = 0x4 & (((e1000_wuc_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x5800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5800, _regval);
    // No shadow register to write to
}

static inline void e1000_wuc_apmpme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wuc_apmpme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wuc_t _regval = 0x8 & (((e1000_wuc_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x5800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5800, _regval);
    // No shadow register to write to
}

/*
 * Register wufc: Wakeup filter control
 * Type: e1000.wakeup (Wakeup register)
 *   lnkc	(size 1, offset 0, init 0):	RW	Link status change
 *   mag	(size 1, offset 1, init 0):	RW	Magic packet
 *   ex	(size 1, offset 2, init 0):	RW	Directed exact
 *   mc	(size 1, offset 3, init 0):	RW	Directed multicast
 *   bc	(size 1, offset 4, init 0):	RW	Broadcast
 *   arp	(size 1, offset 5, init 0):	RW	ARP request packet
 *   ipv4	(size 1, offset 6, init 0):	RW	Directed IPv4
 *   ipv6	(size 1, offset 7, init 0):	RW	Directed IPv6
 *   _anon8	(size 7, offset 8, init 0):	MBZ	_
 *   notco	(size 1, offset 15, init 0):	RW	Ignore TCO/management packets
 *   flx0	(size 1, offset 16, init 0):	RW	Flexible filter 0 enable
 *   flx1	(size 1, offset 17, init 0):	RW	Flexible filter 1 enable
 *   flx2	(size 1, offset 18, init 0):	RW	Flexible filter 2 enable
 *   flx3	(size 1, offset 19, init 0):	RW	Flexible filter 3 enable
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline e1000_wakeup_t e1000_wufc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wufc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5808));
}

static inline e1000_wakeup_t e1000_wufc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wufc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5808));
}

static inline void e1000_wufc_rawwr(__DN(t) *_dev, e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline void e1000_wufc_rawwr(__DN(t) *_dev, e1000_wakeup_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
}

static inline void e1000_wufc_wr(__DN(t) *_dev, e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline void e1000_wufc_wr(__DN(t) *_dev, e1000_wakeup_t _regval)
{
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
}

static inline int e1000_wufc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_wufc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wufc (Wakeup filter control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnkc =\t%" PRIx8 "\t(Link status change)\n", e1000_wakeup_lnkc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mag =\t%" PRIx8 "\t(Magic packet)\n", e1000_wakeup_mag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ex =\t%" PRIx8 "\t(Directed exact)\n", e1000_wakeup_ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mc =\t%" PRIx8 "\t(Directed multicast)\n", e1000_wakeup_mc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bc =\t%" PRIx8 "\t(Broadcast)\n", e1000_wakeup_bc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arp =\t%" PRIx8 "\t(ARP request packet)\n", e1000_wakeup_arp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv4 =\t%" PRIx8 "\t(Directed IPv4)\n", e1000_wakeup_ipv4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(Directed IPv6)\n", e1000_wakeup_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " notco =\t%" PRIx8 "\t(Ignore TCO/management packets)\n", e1000_wakeup_notco_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx0 =\t%" PRIx8 "\t(Flexible filter 0 enable)\n", e1000_wakeup_flx0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx1 =\t%" PRIx8 "\t(Flexible filter 1 enable)\n", e1000_wakeup_flx1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx2 =\t%" PRIx8 "\t(Flexible filter 2 enable)\n", e1000_wakeup_flx2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx3 =\t%" PRIx8 "\t(Flexible filter 3 enable)\n", e1000_wakeup_flx3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t e1000_wufc_lnkc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_lnkc_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_lnkc_extract(_regval));
}

static inline uint8_t e1000_wufc_mag_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_mag_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_mag_extract(_regval));
}

static inline uint8_t e1000_wufc_ex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_ex_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_ex_extract(_regval));
}

static inline uint8_t e1000_wufc_mc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_mc_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_mc_extract(_regval));
}

static inline uint8_t e1000_wufc_bc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_bc_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_bc_extract(_regval));
}

static inline uint8_t e1000_wufc_arp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_arp_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_arp_extract(_regval));
}

static inline uint8_t e1000_wufc_ipv4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_ipv4_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_ipv4_extract(_regval));
}

static inline uint8_t e1000_wufc_ipv6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_ipv6_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_ipv6_extract(_regval));
}

static inline uint8_t e1000_wufc_notco_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_notco_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_notco_extract(_regval));
}

static inline uint8_t e1000_wufc_flx0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_flx0_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_flx0_extract(_regval));
}

static inline uint8_t e1000_wufc_flx1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_flx1_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_flx1_extract(_regval));
}

static inline uint8_t e1000_wufc_flx2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_flx2_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_flx2_extract(_regval));
}

static inline uint8_t e1000_wufc_flx3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wufc_flx3_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5808);
    return(e1000_wakeup_flx3_extract(_regval));
}

static inline void e1000_wufc_lnkc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_lnkc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x1 & (((e1000_wakeup_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf80fe & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_mag_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_mag_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x2 & (((e1000_wakeup_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf80fd & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_ex_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_ex_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x4 & (((e1000_wakeup_t )(_fieldval)) << 2);
    _regval = (_regval | (0xf80fb & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_mc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_mc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x8 & (((e1000_wakeup_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf80f7 & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_bc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_bc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x10 & (((e1000_wakeup_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf80ef & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_arp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_arp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x20 & (((e1000_wakeup_t )(_fieldval)) << 5);
    _regval = (_regval | (0xf80df & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_ipv4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_ipv4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x40 & (((e1000_wakeup_t )(_fieldval)) << 6);
    _regval = (_regval | (0xf80bf & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x80 & (((e1000_wakeup_t )(_fieldval)) << 7);
    _regval = (_regval | (0xf807f & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_notco_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_notco_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x8000 & (((e1000_wakeup_t )(_fieldval)) << 15);
    _regval = (_regval | (0xf00ff & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_flx0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_flx0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x10000 & (((e1000_wakeup_t )(_fieldval)) << 16);
    _regval = (_regval | (0xe80ff & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_flx1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_flx1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x20000 & (((e1000_wakeup_t )(_fieldval)) << 17);
    _regval = (_regval | (0xd80ff & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_flx2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_flx2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x40000 & (((e1000_wakeup_t )(_fieldval)) << 18);
    _regval = (_regval | (0xb80ff & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

static inline void e1000_wufc_flx3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wufc_flx3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_wakeup_t _regval = 0x80000 & (((e1000_wakeup_t )(_fieldval)) << 19);
    _regval = (_regval | (0x780ff & mackerel_read_addr_32(_dev->base, 0x5808)));
    // No read of register shadow required
    _regval = (_regval & 0xf80ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5808, _regval);
    // No shadow register to write to
}

/*
 * Register wus: Wakeup status
 * Type: e1000.wakeup (Wakeup register)
 *   lnkc	(size 1, offset 0, init 0):	RO	Link status change
 *   mag	(size 1, offset 1, init 0):	RO	Magic packet
 *   ex	(size 1, offset 2, init 0):	RO	Directed exact
 *   mc	(size 1, offset 3, init 0):	RO	Directed multicast
 *   bc	(size 1, offset 4, init 0):	RO	Broadcast
 *   arp	(size 1, offset 5, init 0):	RO	ARP request packet
 *   ipv4	(size 1, offset 6, init 0):	RO	Directed IPv4
 *   ipv6	(size 1, offset 7, init 0):	RO	Directed IPv6
 *   _anon8	(size 7, offset 8, init 0):	MBZ	_
 *   notco	(size 1, offset 15, init 0):	RO	Ignore TCO/management packets
 *   flx0	(size 1, offset 16, init 0):	RO	Flexible filter 0 enable
 *   flx1	(size 1, offset 17, init 0):	RO	Flexible filter 1 enable
 *   flx2	(size 1, offset 18, init 0):	RO	Flexible filter 2 enable
 *   flx3	(size 1, offset 19, init 0):	RO	Flexible filter 3 enable
 *   _anon20	(size 12, offset 20, init 0):	MBZ	_
 */
static inline e1000_wakeup_t e1000_wus_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wus_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5810));
}

static inline e1000_wakeup_t e1000_wus_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wakeup_t e1000_wus_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5810));
}

static inline void e1000_wus_rawwr(__DN(t) *_dev, e1000_wakeup_t _regval) __attribute__ ((always_inline));
static inline void e1000_wus_rawwr(__DN(t) *_dev, e1000_wakeup_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5810, _regval);
}

// Register wus is not writeable
static inline int e1000_wus_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_wus_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wus (Wakeup status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnkc =\t%" PRIx8 "\t(Link status change)\n", e1000_wakeup_lnkc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mag =\t%" PRIx8 "\t(Magic packet)\n", e1000_wakeup_mag_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ex =\t%" PRIx8 "\t(Directed exact)\n", e1000_wakeup_ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mc =\t%" PRIx8 "\t(Directed multicast)\n", e1000_wakeup_mc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bc =\t%" PRIx8 "\t(Broadcast)\n", e1000_wakeup_bc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arp =\t%" PRIx8 "\t(ARP request packet)\n", e1000_wakeup_arp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv4 =\t%" PRIx8 "\t(Directed IPv4)\n", e1000_wakeup_ipv4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(Directed IPv6)\n", e1000_wakeup_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " notco =\t%" PRIx8 "\t(Ignore TCO/management packets)\n", e1000_wakeup_notco_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx0 =\t%" PRIx8 "\t(Flexible filter 0 enable)\n", e1000_wakeup_flx0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx1 =\t%" PRIx8 "\t(Flexible filter 1 enable)\n", e1000_wakeup_flx1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx2 =\t%" PRIx8 "\t(Flexible filter 2 enable)\n", e1000_wakeup_flx2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flx3 =\t%" PRIx8 "\t(Flexible filter 3 enable)\n", e1000_wakeup_flx3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t e1000_wus_lnkc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_lnkc_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_lnkc_extract(_regval));
}

static inline uint8_t e1000_wus_mag_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_mag_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_mag_extract(_regval));
}

static inline uint8_t e1000_wus_ex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_ex_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_ex_extract(_regval));
}

static inline uint8_t e1000_wus_mc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_mc_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_mc_extract(_regval));
}

static inline uint8_t e1000_wus_bc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_bc_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_bc_extract(_regval));
}

static inline uint8_t e1000_wus_arp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_arp_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_arp_extract(_regval));
}

static inline uint8_t e1000_wus_ipv4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_ipv4_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_ipv4_extract(_regval));
}

static inline uint8_t e1000_wus_ipv6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_ipv6_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_ipv6_extract(_regval));
}

static inline uint8_t e1000_wus_notco_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_notco_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_notco_extract(_regval));
}

static inline uint8_t e1000_wus_flx0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_flx0_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_flx0_extract(_regval));
}

static inline uint8_t e1000_wus_flx1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_flx1_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_flx1_extract(_regval));
}

static inline uint8_t e1000_wus_flx2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_flx2_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_flx2_extract(_regval));
}

static inline uint8_t e1000_wus_flx3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_wus_flx3_rdf(__DN(t) *_dev)
{
    e1000_wakeup_t _regval = mackerel_read_addr_32(_dev->base, 0x5810);
    return(e1000_wakeup_flx3_extract(_regval));
}

/*
 * Register ipav: IP address valid
 * Type: e1000.ipav (Implicit type of IP address valid register)
 *   v40	(size 1, offset 0, init 0):	RW	IPv4 address 0 valid
 *   v41	(size 1, offset 1, init 0):	RW	IPv4 address 1 valid
 *   v42	(size 1, offset 2, init 0):	RW	IPv4 address 2 valid
 *   v43	(size 1, offset 3, init 0):	RW	IPv4 address 3 valid
 *   _anon4	(size 12, offset 4, init 0):	MBZ	_
 *   v60	(size 1, offset 16, init 0):	RW	IPv6 address 0 valid
 *   _anon17	(size 15, offset 17, init 0):	MBZ	_
 */
static inline e1000_ipav_t e1000_ipav_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ipav_t e1000_ipav_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5838));
}

static inline e1000_ipav_t e1000_ipav_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_ipav_t e1000_ipav_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5838));
}

static inline void e1000_ipav_rawwr(__DN(t) *_dev, e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline void e1000_ipav_rawwr(__DN(t) *_dev, e1000_ipav_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5838, _regval);
}

static inline void e1000_ipav_wr(__DN(t) *_dev, e1000_ipav_t _regval) __attribute__ ((always_inline));
static inline void e1000_ipav_wr(__DN(t) *_dev, e1000_ipav_t _regval)
{
    _regval = (_regval & 0x1000f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5838, _regval);
}

static inline int e1000_ipav_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ipav_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ipav_t _regval = mackerel_read_addr_32(_dev->base, 0x5838);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ipav (IP address valid): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v40 =\t%" PRIx8 "\t(IPv4 address 0 valid)\n", e1000_ipav_v40_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v41 =\t%" PRIx8 "\t(IPv4 address 1 valid)\n", e1000_ipav_v41_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v42 =\t%" PRIx8 "\t(IPv4 address 2 valid)\n", e1000_ipav_v42_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v43 =\t%" PRIx8 "\t(IPv4 address 3 valid)\n", e1000_ipav_v43_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " v60 =\t%" PRIx8 "\t(IPv6 address 0 valid)\n", e1000_ipav_v60_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint8_t e1000_ipav_v40_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v40_rdf(__DN(t) *_dev)
{
    e1000_ipav_t _regval = mackerel_read_addr_32(_dev->base, 0x5838);
    return(e1000_ipav_v40_extract(_regval));
}

static inline uint8_t e1000_ipav_v41_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v41_rdf(__DN(t) *_dev)
{
    e1000_ipav_t _regval = mackerel_read_addr_32(_dev->base, 0x5838);
    return(e1000_ipav_v41_extract(_regval));
}

static inline uint8_t e1000_ipav_v42_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v42_rdf(__DN(t) *_dev)
{
    e1000_ipav_t _regval = mackerel_read_addr_32(_dev->base, 0x5838);
    return(e1000_ipav_v42_extract(_regval));
}

static inline uint8_t e1000_ipav_v43_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v43_rdf(__DN(t) *_dev)
{
    e1000_ipav_t _regval = mackerel_read_addr_32(_dev->base, 0x5838);
    return(e1000_ipav_v43_extract(_regval));
}

static inline uint8_t e1000_ipav_v60_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ipav_v60_rdf(__DN(t) *_dev)
{
    e1000_ipav_t _regval = mackerel_read_addr_32(_dev->base, 0x5838);
    return(e1000_ipav_v60_extract(_regval));
}

static inline void e1000_ipav_v40_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ipav_v40_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ipav_t _regval = 0x1 & (((e1000_ipav_t )(_fieldval)) << 0);
    _regval = (_regval | (0x1000e & mackerel_read_addr_32(_dev->base, 0x5838)));
    // No read of register shadow required
    _regval = (_regval & 0x1000f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5838, _regval);
    // No shadow register to write to
}

static inline void e1000_ipav_v41_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ipav_v41_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ipav_t _regval = 0x2 & (((e1000_ipav_t )(_fieldval)) << 1);
    _regval = (_regval | (0x1000d & mackerel_read_addr_32(_dev->base, 0x5838)));
    // No read of register shadow required
    _regval = (_regval & 0x1000f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5838, _regval);
    // No shadow register to write to
}

static inline void e1000_ipav_v42_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ipav_v42_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ipav_t _regval = 0x4 & (((e1000_ipav_t )(_fieldval)) << 2);
    _regval = (_regval | (0x1000b & mackerel_read_addr_32(_dev->base, 0x5838)));
    // No read of register shadow required
    _regval = (_regval & 0x1000f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5838, _regval);
    // No shadow register to write to
}

static inline void e1000_ipav_v43_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ipav_v43_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ipav_t _regval = 0x8 & (((e1000_ipav_t )(_fieldval)) << 3);
    _regval = (_regval | (0x10007 & mackerel_read_addr_32(_dev->base, 0x5838)));
    // No read of register shadow required
    _regval = (_regval & 0x1000f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5838, _regval);
    // No shadow register to write to
}

static inline void e1000_ipav_v60_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ipav_v60_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_ipav_t _regval = 0x10000 & (((e1000_ipav_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf & mackerel_read_addr_32(_dev->base, 0x5838)));
    // No read of register shadow required
    _regval = (_regval & 0x1000f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5838, _regval);
    // No shadow register to write to
}

/*
 * Register array ip4at: IPv4 address table
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_ip4at_length = 4;
static inline uint32_t e1000_ip4at_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_ip4at_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5840 + (_i * 8)));
}

static inline uint32_t e1000_ip4at_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_ip4at_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5840 + (_i * 8)));
}

static inline void e1000_ip4at_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ip4at_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5840 + (_i * 8), _regval);
}

static inline void e1000_ip4at_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ip4at_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5840 + (_i * 8), _regval);
}

static inline int e1000_ip4at_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_ip4at_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5840 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ip4at", _i, "IPv4 address table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_ip4at_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ip4at_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_ip4at_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array ip6at: IPv6 address table
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_ip6at_length = 4;
static inline uint32_t e1000_ip6at_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_ip6at_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5880 + (_i * (32 / 8))));
}

static inline uint32_t e1000_ip6at_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_ip6at_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5880 + (_i * (32 / 8))));
}

static inline void e1000_ip6at_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ip6at_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5880 + (_i * (32 / 8)), _regval);
}

static inline void e1000_ip6at_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ip6at_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5880 + (_i * (32 / 8)), _regval);
}

static inline int e1000_ip6at_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_ip6at_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5880 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ip6at", _i, "IPv6 address table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_ip6at_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ip6at_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_ip6at_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register wupl: Wakeup packet length
 * Type: e1000.wupl (Implicit type of Wakeup packet length register)
 *   len	(size 12, offset 0, init 0):	RW	Length
 *   _anon12	(size 20, offset 12, init 0):	MBZ	_
 */
static inline e1000_wupl_t e1000_wupl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wupl_t e1000_wupl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5900));
}

static inline e1000_wupl_t e1000_wupl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_wupl_t e1000_wupl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5900));
}

static inline void e1000_wupl_rawwr(__DN(t) *_dev, e1000_wupl_t _regval) __attribute__ ((always_inline));
static inline void e1000_wupl_rawwr(__DN(t) *_dev, e1000_wupl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5900, _regval);
}

static inline void e1000_wupl_wr(__DN(t) *_dev, e1000_wupl_t _regval) __attribute__ ((always_inline));
static inline void e1000_wupl_wr(__DN(t) *_dev, e1000_wupl_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5900, _regval);
}

static inline int e1000_wupl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_wupl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_wupl_t _regval = mackerel_read_addr_32(_dev->base, 0x5900);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register wupl (Wakeup packet length): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx16 "\t(Length)\n", e1000_wupl_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint16_t e1000_wupl_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_wupl_len_rdf(__DN(t) *_dev)
{
    e1000_wupl_t _regval = mackerel_read_addr_32(_dev->base, 0x5900);
    return(e1000_wupl_len_extract(_regval));
}

static inline void e1000_wupl_len_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_wupl_len_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_wupl_t _regval = 0xfff & (((e1000_wupl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5900, _regval);
    // No shadow register to write to
}

/*
 * Register array wupm: Wakeup packet memory
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_wupm_length = 32;
static inline uint32_t e1000_wupm_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_wupm_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a00 + (_i * (32 / 8))));
}

static inline uint32_t e1000_wupm_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_wupm_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5a00 + (_i * (32 / 8))));
}

static inline void e1000_wupm_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_wupm_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5a00 + (_i * (32 / 8)), _regval);
}

static inline void e1000_wupm_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_wupm_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5a00 + (_i * (32 / 8)), _regval);
}

static inline int e1000_wupm_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_wupm_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5a00 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "wupm", _i, "Wakeup packet memory");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_wupm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_wupm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_wupm_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array fflt: Flexible filter length table
 * Type: e1000.fflt (Implicit type of Flexible filter length table register array)
 *   len	(size 11, offset 0, init 0):	RW	Length
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static const size_t e1000_fflt_length = 4;
static inline e1000_fflt_t e1000_fflt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_fflt_t e1000_fflt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f00 + (_i * 8)));
}

static inline e1000_fflt_t e1000_fflt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_fflt_t e1000_fflt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f00 + (_i * 8)));
}

static inline void e1000_fflt_rawwr(__DN(t) *_dev, int _i, e1000_fflt_t _regval) __attribute__ ((always_inline));
static inline void e1000_fflt_rawwr(__DN(t) *_dev, int _i, e1000_fflt_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5f00 + (_i * 8), _regval);
}

static inline void e1000_fflt_wr(__DN(t) *_dev, int _i, e1000_fflt_t _regval) __attribute__ ((always_inline));
static inline void e1000_fflt_wr(__DN(t) *_dev, int _i, e1000_fflt_t _regval)
{
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5f00 + (_i * 8), _regval);
}

static inline int e1000_fflt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_fflt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_fflt_t _regval = mackerel_read_addr_32(_dev->base, 0x5f00 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fflt", _i, "Flexible filter length table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " len =\t%" PRIx16 "\t(Length)\n", e1000_fflt_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline int e1000_fflt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fflt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_fflt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_fflt_len_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_fflt_len_rdf(__DN(t) *_dev, int _i)
{
    e1000_fflt_t _regval = mackerel_read_addr_32(_dev->base, 0x5f00 + (_i * 8));
    return(e1000_fflt_len_extract(_regval));
}

static inline void e1000_fflt_len_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fflt_len_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_fflt_t _regval = 0x7ff & (((e1000_fflt_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5f00 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register array ffltco: Flexible filter length table
 * Type: e1000.ffltco (Implicit type of Flexible filter length table register array)
 *   tcolen	(size 11, offset 0, init 0):	RW	Length
 *   _anon11	(size 21, offset 11, init 0):	MBZ	_
 */
static const size_t e1000_ffltco_length = 2;
static inline e1000_ffltco_t e1000_ffltco_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_ffltco_t e1000_ffltco_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f20 + (_i * 8)));
}

static inline e1000_ffltco_t e1000_ffltco_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_ffltco_t e1000_ffltco_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5f20 + (_i * 8)));
}

static inline void e1000_ffltco_rawwr(__DN(t) *_dev, int _i, e1000_ffltco_t _regval) __attribute__ ((always_inline));
static inline void e1000_ffltco_rawwr(__DN(t) *_dev, int _i, e1000_ffltco_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5f20 + (_i * 8), _regval);
}

static inline void e1000_ffltco_wr(__DN(t) *_dev, int _i, e1000_ffltco_t _regval) __attribute__ ((always_inline));
static inline void e1000_ffltco_wr(__DN(t) *_dev, int _i, e1000_ffltco_t _regval)
{
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5f20 + (_i * 8), _regval);
}

static inline int e1000_ffltco_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_ffltco_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ffltco_t _regval = mackerel_read_addr_32(_dev->base, 0x5f20 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ffltco", _i, "Flexible filter length table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcolen =\t%" PRIx16 "\t(Length)\n", e1000_ffltco_tcolen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline int e1000_ffltco_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ffltco_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_ffltco_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e1000_ffltco_tcolen_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e1000_ffltco_tcolen_rdf(__DN(t) *_dev, int _i)
{
    e1000_ffltco_t _regval = mackerel_read_addr_32(_dev->base, 0x5f20 + (_i * 8));
    return(e1000_ffltco_tcolen_extract(_regval));
}

static inline void e1000_ffltco_tcolen_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ffltco_tcolen_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e1000_ffltco_t _regval = 0x7ff & (((e1000_ffltco_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0x7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5f20 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register array ffmt: Flexible filter mask table
 * Type: e1000.ffmt (Implicit type of Flexible filter mask table register array)
 *   mask	(size 4, offset 0, init 0):	RW	mask
 *   _anon4	(size 28, offset 4, init 0):	MBZ	_
 */
static const size_t e1000_ffmt_length = 128;
static inline e1000_ffmt_t e1000_ffmt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_ffmt_t e1000_ffmt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9000 + (_i * 8)));
}

static inline e1000_ffmt_t e1000_ffmt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_ffmt_t e1000_ffmt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9000 + (_i * 8)));
}

static inline void e1000_ffmt_rawwr(__DN(t) *_dev, int _i, e1000_ffmt_t _regval) __attribute__ ((always_inline));
static inline void e1000_ffmt_rawwr(__DN(t) *_dev, int _i, e1000_ffmt_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9000 + (_i * 8), _regval);
}

static inline void e1000_ffmt_wr(__DN(t) *_dev, int _i, e1000_ffmt_t _regval) __attribute__ ((always_inline));
static inline void e1000_ffmt_wr(__DN(t) *_dev, int _i, e1000_ffmt_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9000 + (_i * 8), _regval);
}

static inline int e1000_ffmt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_ffmt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ffmt_t _regval = mackerel_read_addr_32(_dev->base, 0x9000 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ffmt", _i, "Flexible filter mask table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t%" PRIx8 "\t(mask)\n", e1000_ffmt_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline int e1000_ffmt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ffmt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_ffmt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_ffmt_mask_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_ffmt_mask_rdf(__DN(t) *_dev, int _i)
{
    e1000_ffmt_t _regval = mackerel_read_addr_32(_dev->base, 0x9000 + (_i * 8));
    return(e1000_ffmt_mask_extract(_regval));
}

static inline void e1000_ffmt_mask_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ffmt_mask_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_ffmt_t _regval = 0xf & (((e1000_ffmt_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xf);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9000 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register array ffvt: Flexible filter value table
 * Type: e1000.ffvt (Implicit type of Flexible filter value table register array)
 *   val0	(size 8, offset 0, init 0):	RW	Value 0
 *   val1	(size 8, offset 8, init 0):	RW	Value 1
 *   val2	(size 8, offset 16, init 0):	RW	Value 2
 *   val3	(size 8, offset 24, init 0):	RW	Value 3
 */
static const size_t e1000_ffvt_length = 128;
static inline e1000_ffvt_t e1000_ffvt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_ffvt_t e1000_ffvt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8)));
}

static inline e1000_ffvt_t e1000_ffvt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_ffvt_t e1000_ffvt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8)));
}

static inline void e1000_ffvt_rawwr(__DN(t) *_dev, int _i, e1000_ffvt_t _regval) __attribute__ ((always_inline));
static inline void e1000_ffvt_rawwr(__DN(t) *_dev, int _i, e1000_ffvt_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * 8), _regval);
}

static inline void e1000_ffvt_wr(__DN(t) *_dev, int _i, e1000_ffvt_t _regval) __attribute__ ((always_inline));
static inline void e1000_ffvt_wr(__DN(t) *_dev, int _i, e1000_ffvt_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * 8), _regval);
}

static inline int e1000_ffvt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_ffvt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_ffvt_t _regval = mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ffvt", _i, "Flexible filter value table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val0 =\t%" PRIx8 "\t(Value 0)\n", e1000_ffvt_val0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val1 =\t%" PRIx8 "\t(Value 1)\n", e1000_ffvt_val1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val2 =\t%" PRIx8 "\t(Value 2)\n", e1000_ffvt_val2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " val3 =\t%" PRIx8 "\t(Value 3)\n", e1000_ffvt_val3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_ffvt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ffvt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_ffvt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_ffvt_val0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val0_rdf(__DN(t) *_dev, int _i)
{
    e1000_ffvt_t _regval = mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8));
    return(e1000_ffvt_val0_extract(_regval));
}

static inline uint8_t e1000_ffvt_val1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val1_rdf(__DN(t) *_dev, int _i)
{
    e1000_ffvt_t _regval = mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8));
    return(e1000_ffvt_val1_extract(_regval));
}

static inline uint8_t e1000_ffvt_val2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val2_rdf(__DN(t) *_dev, int _i)
{
    e1000_ffvt_t _regval = mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8));
    return(e1000_ffvt_val2_extract(_regval));
}

static inline uint8_t e1000_ffvt_val3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_ffvt_val3_rdf(__DN(t) *_dev, int _i)
{
    e1000_ffvt_t _regval = mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8));
    return(e1000_ffvt_val3_extract(_regval));
}

static inline void e1000_ffvt_val0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ffvt_val0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_ffvt_t _regval = 0xff & (((e1000_ffvt_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void e1000_ffvt_val1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ffvt_val1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_ffvt_t _regval = 0xff00 & (((e1000_ffvt_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void e1000_ffvt_val2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ffvt_val2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_ffvt_t _regval = 0xff0000 & (((e1000_ffvt_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void e1000_ffvt_val3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ffvt_val3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_ffvt_t _regval = 0xff000000 & (((e1000_ffvt_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x9800 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register manc: Management control
 * Type: e1000.manc (Implicit type of Management control register)
 *   _anon0	(size 3, offset 0, init 0):	MBZ	_
 *   en_flexport0	(size 1, offset 3, init 0):	RW	Enable flex UDP/TCP port 0 filtering
 *   en_flexport1	(size 1, offset 4, init 0):	RW	Enable flex UDP/TCP port 1 filtering
 *   en_flexport2	(size 1, offset 5, init 0):	RW	Enable flex UDP/TCP port 2 filtering
 *   flex_tco1_filter	(size 1, offset 6, init 0):	RW	Enable TCO filter 1
 *   flex_tco0_filter	(size 1, offset 7, init 0):	RW	Enable TCO filter 0
 *   rmcp_en	(size 1, offset 8, init 0):	RW	Enable RMCP 0x026f filtering
 *   o298_en	(size 1, offset 9, init 0):	RW	Enable RMCP 0x0298 filtering
 *   _anon10	(size 3, offset 10, init 0):	MBZ	_
 *   arp_req_en	(size 1, offset 13, init 0):	RW	Enable ARP request filtering
 *   neighbor_en	(size 1, offset 14, init 0):	RW	Enable neighbor discovery filtering
 *   arp_res_en	(size 1, offset 15, init 0):	RW	Enable ARP response filtering
 *   tco_reset	(size 1, offset 16, init 0):	RW	TCO reset occurred
 *   rcv_tco_en	(size 1, offset 17, init 0):	RW	Receive TCO packets enable
 *   blk_phyrst_on_ide	(size 1, offset 18, init 0):	RW	Block PHY reset and power on state changes
 *   rcv_all	(size 1, offset 19, init 0):	RW	Receive all enable
 *   en_mac16_filter	(size 1, offset 20, init 0):	RW	Enable MAC address 16 filtering
 *   en_mng2host	(size 1, offset 21, init 0):	RW	Enable firmware packets to host memory
 *   en_ip_addrfilter	(size 1, offset 22, init 0):	RW	Enable IP address filtering
 *   en_xsum_filter	(size 1, offset 23, init 0):	RW	Enable Xsum filtering to firmware
 *   br_en	(size 1, offset 24, init 0):	RW	Enable broadcast filtering
 *   _anon25	(size 7, offset 25, init 0):	MBZ	_
 */
static inline e1000_manc_t e1000_manc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5820));
}

static inline e1000_manc_t e1000_manc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_manc_t e1000_manc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5820));
}

static inline void e1000_manc_rawwr(__DN(t) *_dev, e1000_manc_t _regval) __attribute__ ((always_inline));
static inline void e1000_manc_rawwr(__DN(t) *_dev, e1000_manc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
}

static inline void e1000_manc_wr(__DN(t) *_dev, e1000_manc_t _regval) __attribute__ ((always_inline));
static inline void e1000_manc_wr(__DN(t) *_dev, e1000_manc_t _regval)
{
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
}

static inline int e1000_manc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_manc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register manc (Management control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_flexport0 =\t%" PRIx8 "\t(Enable flex UDP/TCP port 0 filtering)\n", e1000_manc_en_flexport0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_flexport1 =\t%" PRIx8 "\t(Enable flex UDP/TCP port 1 filtering)\n", e1000_manc_en_flexport1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_flexport2 =\t%" PRIx8 "\t(Enable flex UDP/TCP port 2 filtering)\n", e1000_manc_en_flexport2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex_tco1_filter =\t%" PRIx8 "\t(Enable TCO filter 1)\n", e1000_manc_flex_tco1_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex_tco0_filter =\t%" PRIx8 "\t(Enable TCO filter 0)\n", e1000_manc_flex_tco0_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rmcp_en =\t%" PRIx8 "\t(Enable RMCP 0x026f filtering)\n", e1000_manc_rmcp_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " o298_en =\t%" PRIx8 "\t(Enable RMCP 0x0298 filtering)\n", e1000_manc_o298_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arp_req_en =\t%" PRIx8 "\t(Enable ARP request filtering)\n", e1000_manc_arp_req_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " neighbor_en =\t%" PRIx8 "\t(Enable neighbor discovery filtering)\n", e1000_manc_neighbor_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arp_res_en =\t%" PRIx8 "\t(Enable ARP response filtering)\n", e1000_manc_arp_res_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tco_reset =\t%" PRIx8 "\t(TCO reset occurred)\n", e1000_manc_tco_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_tco_en =\t%" PRIx8 "\t(Receive TCO packets enable)\n", e1000_manc_rcv_tco_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " blk_phyrst_on_ide =\t%" PRIx8 "\t(Block PHY reset and power on state changes)\n", e1000_manc_blk_phyrst_on_ide_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_all =\t%" PRIx8 "\t(Receive all enable)\n", e1000_manc_rcv_all_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_mac16_filter =\t%" PRIx8 "\t(Enable MAC address 16 filtering)\n", e1000_manc_en_mac16_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_mng2host =\t%" PRIx8 "\t(Enable firmware packets to host memory)\n", e1000_manc_en_mng2host_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ip_addrfilter =\t%" PRIx8 "\t(Enable IP address filtering)\n", e1000_manc_en_ip_addrfilter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_xsum_filter =\t%" PRIx8 "\t(Enable Xsum filtering to firmware)\n", e1000_manc_en_xsum_filter_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " br_en =\t%" PRIx8 "\t(Enable broadcast filtering)\n", e1000_manc_br_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline uint8_t e1000_manc_en_flexport0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_flexport0_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_en_flexport0_extract(_regval));
}

static inline uint8_t e1000_manc_en_flexport1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_flexport1_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_en_flexport1_extract(_regval));
}

static inline uint8_t e1000_manc_en_flexport2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_flexport2_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_en_flexport2_extract(_regval));
}

static inline uint8_t e1000_manc_flex_tco1_filter_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_flex_tco1_filter_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_flex_tco1_filter_extract(_regval));
}

static inline uint8_t e1000_manc_flex_tco0_filter_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_flex_tco0_filter_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_flex_tco0_filter_extract(_regval));
}

static inline uint8_t e1000_manc_rmcp_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_rmcp_en_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_rmcp_en_extract(_regval));
}

static inline uint8_t e1000_manc_o298_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_o298_en_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_o298_en_extract(_regval));
}

static inline uint8_t e1000_manc_arp_req_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_arp_req_en_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_arp_req_en_extract(_regval));
}

static inline uint8_t e1000_manc_neighbor_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_neighbor_en_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_neighbor_en_extract(_regval));
}

static inline uint8_t e1000_manc_arp_res_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_arp_res_en_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_arp_res_en_extract(_regval));
}

static inline uint8_t e1000_manc_tco_reset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_tco_reset_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_tco_reset_extract(_regval));
}

static inline uint8_t e1000_manc_rcv_tco_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_rcv_tco_en_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_rcv_tco_en_extract(_regval));
}

static inline uint8_t e1000_manc_blk_phyrst_on_ide_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_blk_phyrst_on_ide_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_blk_phyrst_on_ide_extract(_regval));
}

static inline uint8_t e1000_manc_rcv_all_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_rcv_all_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_rcv_all_extract(_regval));
}

static inline uint8_t e1000_manc_en_mac16_filter_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_mac16_filter_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_en_mac16_filter_extract(_regval));
}

static inline uint8_t e1000_manc_en_mng2host_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_mng2host_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_en_mng2host_extract(_regval));
}

static inline uint8_t e1000_manc_en_ip_addrfilter_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_ip_addrfilter_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_en_ip_addrfilter_extract(_regval));
}

static inline uint8_t e1000_manc_en_xsum_filter_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_en_xsum_filter_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_en_xsum_filter_extract(_regval));
}

static inline uint8_t e1000_manc_br_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_manc_br_en_rdf(__DN(t) *_dev)
{
    e1000_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e1000_manc_br_en_extract(_regval));
}

static inline void e1000_manc_en_flexport0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_en_flexport0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x8 & (((e1000_manc_t )(_fieldval)) << 3);
    _regval = (_regval | (0x1ffe3f0 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_en_flexport1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_en_flexport1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x10 & (((e1000_manc_t )(_fieldval)) << 4);
    _regval = (_regval | (0x1ffe3e8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_en_flexport2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_en_flexport2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x20 & (((e1000_manc_t )(_fieldval)) << 5);
    _regval = (_regval | (0x1ffe3d8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_flex_tco1_filter_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_flex_tco1_filter_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x40 & (((e1000_manc_t )(_fieldval)) << 6);
    _regval = (_regval | (0x1ffe3b8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_flex_tco0_filter_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_flex_tco0_filter_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x80 & (((e1000_manc_t )(_fieldval)) << 7);
    _regval = (_regval | (0x1ffe378 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_rmcp_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_rmcp_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x100 & (((e1000_manc_t )(_fieldval)) << 8);
    _regval = (_regval | (0x1ffe2f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_o298_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_o298_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x200 & (((e1000_manc_t )(_fieldval)) << 9);
    _regval = (_regval | (0x1ffe1f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_arp_req_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_arp_req_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x2000 & (((e1000_manc_t )(_fieldval)) << 13);
    _regval = (_regval | (0x1ffc3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_neighbor_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_neighbor_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x4000 & (((e1000_manc_t )(_fieldval)) << 14);
    _regval = (_regval | (0x1ffa3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_arp_res_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_arp_res_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x8000 & (((e1000_manc_t )(_fieldval)) << 15);
    _regval = (_regval | (0x1ff63f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_tco_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_tco_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x10000 & (((e1000_manc_t )(_fieldval)) << 16);
    _regval = (_regval | (0x1fee3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_rcv_tco_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_rcv_tco_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x20000 & (((e1000_manc_t )(_fieldval)) << 17);
    _regval = (_regval | (0x1fde3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_blk_phyrst_on_ide_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_blk_phyrst_on_ide_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x40000 & (((e1000_manc_t )(_fieldval)) << 18);
    _regval = (_regval | (0x1fbe3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_rcv_all_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_rcv_all_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x80000 & (((e1000_manc_t )(_fieldval)) << 19);
    _regval = (_regval | (0x1f7e3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_en_mac16_filter_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_en_mac16_filter_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x100000 & (((e1000_manc_t )(_fieldval)) << 20);
    _regval = (_regval | (0x1efe3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_en_mng2host_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_en_mng2host_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x200000 & (((e1000_manc_t )(_fieldval)) << 21);
    _regval = (_regval | (0x1dfe3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_en_ip_addrfilter_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_en_ip_addrfilter_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x400000 & (((e1000_manc_t )(_fieldval)) << 22);
    _regval = (_regval | (0x1bfe3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_en_xsum_filter_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_en_xsum_filter_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x800000 & (((e1000_manc_t )(_fieldval)) << 23);
    _regval = (_regval | (0x17fe3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e1000_manc_br_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_manc_br_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_manc_t _regval = 0x1000000 & (((e1000_manc_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffe3f8 & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    _regval = (_regval & 0x1ffe3f8);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

/*
 * Register gcr: PCIe control
 * Type: e1000.gcr (Implicit type of PCIe control register)
 *   rxd_nosnoop	(size 1, offset 0, init 0):	RW	Receive data write
 *   rxdscw_nosnoop	(size 1, offset 1, init 0):	RW	Receive descriptor write
 *   rxdscr_nosnoop	(size 1, offset 2, init 0):	RW	Receive descriptor read
 *   txd_nosnoop	(size 1, offset 3, init 0):	RW	Transmit data write
 *   txdscw_nosnoop	(size 1, offset 4, init 0):	RW	Transmit descriptor write
 *   txdscr_nosnoop	(size 1, offset 5, init 0):	RW	Transmit descriptor read
 *   elec_idle_in0	(size 1, offset 6, init 0):	RO	SerDes0 internal electrical idle indicator
 *   elec_idle_in1	(size 1, offset 7, init 0):	RO	SerDes1 internal electrical idle indicator
 *   self_test_enable	(size 1, offset 8, init 0):	RW	Perform self test
 *   _anon9	(size 12, offset 9, init 0):	MBZ	_
 *   logheader	(size 1, offset 21, init 0):	RW	Log header into PCI config space
 *   _anon22	(size 1, offset 22, init 0):	MBZ	_
 *   l1el_msb	(size 1, offset 23, init 0):	RO	L1 Entry latency msb
 *   l0s_el	(size 1, offset 24, init 0):	RW	L0s entry latency
 *   l1el_lsb	(size 2, offset 25, init 0):	RO	L1 Entry latency lsbs
 *   l1_aw_l0s	(size 1, offset 27, init 0):	RW	L1 act without L0s_rx correlation
 *   gio_dis_rderr	(size 1, offset 28, init 0):	RW	Disable running disparity err
 *   gio_good_10s	(size 1, offset 29, init 0):	RW	Force good PCIe l0s training
 *   self_test_result	(size 1, offset 30, init 0):	RW	Result of self test
 *   dis_tmout	(size 1, offset 31, init 0):	RW	Disable PCIe timeout mechanism
 */
static inline e1000_gcr_t e1000_gcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b00));
}

static inline e1000_gcr_t e1000_gcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gcr_t e1000_gcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b00));
}

static inline void e1000_gcr_rawwr(__DN(t) *_dev, e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline void e1000_gcr_rawwr(__DN(t) *_dev, e1000_gcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
}

static inline void e1000_gcr_wr(__DN(t) *_dev, e1000_gcr_t _regval) __attribute__ ((always_inline));
static inline void e1000_gcr_wr(__DN(t) *_dev, e1000_gcr_t _regval)
{
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
}

static inline int e1000_gcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gcr (PCIe control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxd_nosnoop =\t%" PRIx8 "\t(Receive data write)\n", e1000_gcr_rxd_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdscw_nosnoop =\t%" PRIx8 "\t(Receive descriptor write)\n", e1000_gcr_rxdscw_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdscr_nosnoop =\t%" PRIx8 "\t(Receive descriptor read)\n", e1000_gcr_rxdscr_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txd_nosnoop =\t%" PRIx8 "\t(Transmit data write)\n", e1000_gcr_txd_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdscw_nosnoop =\t%" PRIx8 "\t(Transmit descriptor write)\n", e1000_gcr_txdscw_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdscr_nosnoop =\t%" PRIx8 "\t(Transmit descriptor read)\n", e1000_gcr_txdscr_nosnoop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " elec_idle_in0 =\t%" PRIx8 "\t(SerDes0 internal electrical idle indicator)\n", e1000_gcr_elec_idle_in0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " elec_idle_in1 =\t%" PRIx8 "\t(SerDes1 internal electrical idle indicator)\n", e1000_gcr_elec_idle_in1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " self_test_enable =\t%" PRIx8 "\t(Perform self test)\n", e1000_gcr_self_test_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " logheader =\t%" PRIx8 "\t(Log header into PCI config space)\n", e1000_gcr_logheader_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1el_msb =\t%" PRIx8 "\t(L1 Entry latency msb)\n", e1000_gcr_l1el_msb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l0s_el =\t%" PRIx8 "\t(L0s entry latency)\n", e1000_gcr_l0s_el_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1el_lsb =\t%" PRIx8 "\t(L1 Entry latency lsbs)\n", e1000_gcr_l1el_lsb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1_aw_l0s =\t%" PRIx8 "\t(L1 act without L0s_rx correlation)\n", e1000_gcr_l1_aw_l0s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_dis_rderr =\t%" PRIx8 "\t(Disable running disparity err)\n", e1000_gcr_gio_dis_rderr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_good_10s =\t%" PRIx8 "\t(Force good PCIe l0s training)\n", e1000_gcr_gio_good_10s_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " self_test_result =\t%" PRIx8 "\t(Result of self test)\n", e1000_gcr_self_test_result_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_tmout =\t%" PRIx8 "\t(Disable PCIe timeout mechanism)\n", e1000_gcr_dis_tmout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_gcr_rxd_nosnoop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_rxd_nosnoop_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_rxd_nosnoop_extract(_regval));
}

static inline uint8_t e1000_gcr_rxdscw_nosnoop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_rxdscw_nosnoop_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_rxdscw_nosnoop_extract(_regval));
}

static inline uint8_t e1000_gcr_rxdscr_nosnoop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_rxdscr_nosnoop_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_rxdscr_nosnoop_extract(_regval));
}

static inline uint8_t e1000_gcr_txd_nosnoop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_txd_nosnoop_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_txd_nosnoop_extract(_regval));
}

static inline uint8_t e1000_gcr_txdscw_nosnoop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_txdscw_nosnoop_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_txdscw_nosnoop_extract(_regval));
}

static inline uint8_t e1000_gcr_txdscr_nosnoop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_txdscr_nosnoop_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_txdscr_nosnoop_extract(_regval));
}

static inline uint8_t e1000_gcr_elec_idle_in0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_elec_idle_in0_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_elec_idle_in0_extract(_regval));
}

static inline uint8_t e1000_gcr_elec_idle_in1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_elec_idle_in1_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_elec_idle_in1_extract(_regval));
}

static inline uint8_t e1000_gcr_self_test_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_self_test_enable_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_self_test_enable_extract(_regval));
}

static inline uint8_t e1000_gcr_logheader_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_logheader_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_logheader_extract(_regval));
}

static inline uint8_t e1000_gcr_l1el_msb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l1el_msb_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_l1el_msb_extract(_regval));
}

static inline uint8_t e1000_gcr_l0s_el_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l0s_el_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_l0s_el_extract(_regval));
}

static inline uint8_t e1000_gcr_l1el_lsb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l1el_lsb_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_l1el_lsb_extract(_regval));
}

static inline uint8_t e1000_gcr_l1_aw_l0s_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_l1_aw_l0s_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_l1_aw_l0s_extract(_regval));
}

static inline uint8_t e1000_gcr_gio_dis_rderr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_gio_dis_rderr_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_gio_dis_rderr_extract(_regval));
}

static inline uint8_t e1000_gcr_gio_good_10s_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_gio_good_10s_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_gio_good_10s_extract(_regval));
}

static inline uint8_t e1000_gcr_self_test_result_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_self_test_result_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_self_test_result_extract(_regval));
}

static inline uint8_t e1000_gcr_dis_tmout_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gcr_dis_tmout_rdf(__DN(t) *_dev)
{
    e1000_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x5b00);
    return(e1000_gcr_dis_tmout_extract(_regval));
}

static inline void e1000_gcr_rxd_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_rxd_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x1 & (((e1000_gcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xf920013e & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_rxdscw_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_rxdscw_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x2 & (((e1000_gcr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf920013d & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_rxdscr_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_rxdscr_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x4 & (((e1000_gcr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xf920013b & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_txd_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_txd_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x8 & (((e1000_gcr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xf9200137 & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_txdscw_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_txdscw_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x10 & (((e1000_gcr_t )(_fieldval)) << 4);
    _regval = (_regval | (0xf920012f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_txdscr_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_txdscr_nosnoop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x20 & (((e1000_gcr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xf920011f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_self_test_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_self_test_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x100 & (((e1000_gcr_t )(_fieldval)) << 8);
    _regval = (_regval | (0xf920003f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_logheader_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_logheader_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x200000 & (((e1000_gcr_t )(_fieldval)) << 21);
    _regval = (_regval | (0xf900013f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_l0s_el_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_l0s_el_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x1000000 & (((e1000_gcr_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf820013f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_l1_aw_l0s_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_l1_aw_l0s_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x8000000 & (((e1000_gcr_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf120013f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_gio_dis_rderr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_gio_dis_rderr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x10000000 & (((e1000_gcr_t )(_fieldval)) << 28);
    _regval = (_regval | (0xe920013f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_gio_good_10s_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_gio_good_10s_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x20000000 & (((e1000_gcr_t )(_fieldval)) << 29);
    _regval = (_regval | (0xd920013f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_self_test_result_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_self_test_result_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x40000000 & (((e1000_gcr_t )(_fieldval)) << 30);
    _regval = (_regval | (0xb920013f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

static inline void e1000_gcr_dis_tmout_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gcr_dis_tmout_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gcr_t _regval = 0x80000000 & (((e1000_gcr_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7920013f & mackerel_read_addr_32(_dev->base, 0x5b00)));
    // No read of register shadow required
    _regval = (_regval & 0xffa001ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b00, _regval);
    // No shadow register to write to
}

/*
 * Register gscl1: PCIe statistics control 1
 * Type: e1000.gscl1 (Implicit type of PCIe statistics control 1 register)
 *   count_en0	(size 1, offset 0, init 0):	RW	Enable PCIe stats counter 0
 *   count_en1	(size 1, offset 1, init 0):	RW	Enable PCIe stats counter 1
 *   count_en2	(size 1, offset 2, init 0):	RW	Enable PCIe stats counter 2
 *   count_en3	(size 1, offset 3, init 0):	RW	Enable PCIe stats counter 3
 *   _anon4	(size 23, offset 4, init 0):	RSVD	_
 *   count_test	(size 1, offset 27, init 0):	RW	Test bit
 *   en_64bit	(size 1, offset 28, init 0):	RW	Enable two 64-bit counters instead of 4 32-bit
 *   count_reset	(size 1, offset 29, init 0):	RW	Reset indication of PCIe stats
 *   count_stop	(size 1, offset 30, init 0):	RW	Stop indication
 *   count_start	(size 1, offset 31, init 0):	RW	Start indication
 */
static inline e1000_gscl1_t e1000_gscl1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b10));
}

static inline e1000_gscl1_t e1000_gscl1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl1_t e1000_gscl1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b10));
}

static inline void e1000_gscl1_rawwr(__DN(t) *_dev, e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl1_rawwr(__DN(t) *_dev, e1000_gscl1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
}

static inline void e1000_gscl1_wr(__DN(t) *_dev, e1000_gscl1_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl1_wr(__DN(t) *_dev, e1000_gscl1_t _regval)
{
    _regval = (_regval & 0xf800000f);
    // No MB1 fields present
    _regval = (_regval | (0x7fffff0 & mackerel_read_addr_32(_dev->base, 0x5b10)));
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
}

static inline int e1000_gscl1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gscl1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gscl1 (PCIe statistics control 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en0 =\t%" PRIx8 "\t(Enable PCIe stats counter 0)\n", e1000_gscl1_count_en0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en1 =\t%" PRIx8 "\t(Enable PCIe stats counter 1)\n", e1000_gscl1_count_en1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en2 =\t%" PRIx8 "\t(Enable PCIe stats counter 2)\n", e1000_gscl1_count_en2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_en3 =\t%" PRIx8 "\t(Enable PCIe stats counter 3)\n", e1000_gscl1_count_en3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_test =\t%" PRIx8 "\t(Test bit)\n", e1000_gscl1_count_test_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_64bit =\t%" PRIx8 "\t(Enable two 64-bit counters instead of 4 32-bit)\n", e1000_gscl1_en_64bit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_reset =\t%" PRIx8 "\t(Reset indication of PCIe stats)\n", e1000_gscl1_count_reset_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_stop =\t%" PRIx8 "\t(Stop indication)\n", e1000_gscl1_count_stop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " count_start =\t%" PRIx8 "\t(Start indication)\n", e1000_gscl1_count_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_gscl1_count_en0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en0_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_en0_extract(_regval));
}

static inline uint8_t e1000_gscl1_count_en1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en1_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_en1_extract(_regval));
}

static inline uint8_t e1000_gscl1_count_en2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en2_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_en2_extract(_regval));
}

static inline uint8_t e1000_gscl1_count_en3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_en3_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_en3_extract(_regval));
}

static inline uint8_t e1000_gscl1_count_test_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_test_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_test_extract(_regval));
}

static inline uint8_t e1000_gscl1_en_64bit_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_en_64bit_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_en_64bit_extract(_regval));
}

static inline uint8_t e1000_gscl1_count_reset_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_reset_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_reset_extract(_regval));
}

static inline uint8_t e1000_gscl1_count_stop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_stop_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_stop_extract(_regval));
}

static inline uint8_t e1000_gscl1_count_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl1_count_start_rdf(__DN(t) *_dev)
{
    e1000_gscl1_t _regval = mackerel_read_addr_32(_dev->base, 0x5b10);
    return(e1000_gscl1_count_start_extract(_regval));
}

static inline void e1000_gscl1_count_en0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_en0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x1 & (((e1000_gscl1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_count_en1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_en1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x2 & (((e1000_gscl1_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_count_en2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_en2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x4 & (((e1000_gscl1_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_count_en3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_en3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x8 & (((e1000_gscl1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_count_test_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_test_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x8000000 & (((e1000_gscl1_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7ffffff & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_en_64bit_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_en_64bit_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x10000000 & (((e1000_gscl1_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_count_reset_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_reset_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x20000000 & (((e1000_gscl1_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_count_stop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_stop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x40000000 & (((e1000_gscl1_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl1_count_start_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl1_count_start_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl1_t _regval = 0x80000000 & (((e1000_gscl1_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x5b10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b10, _regval);
    // No shadow register to write to
}

/*
 * Register gscl2: PCIe statistics control 2
 * Type: e1000.gscl2 (Implicit type of PCIe statistics control 2 register)
 *   event0	(size 8, offset 0, init 0):	RW	Event number that counter 0 counts
 *   event1	(size 8, offset 8, init 0):	RW	Event number that counter 1 counts
 *   event2	(size 8, offset 16, init 0):	RW	Event number that counter 2 counts
 *   event3	(size 8, offset 24, init 0):	RW	Event number that counter 3 counts
 */
static inline e1000_gscl2_t e1000_gscl2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl2_t e1000_gscl2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b14));
}

static inline e1000_gscl2_t e1000_gscl2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl2_t e1000_gscl2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b14));
}

static inline void e1000_gscl2_rawwr(__DN(t) *_dev, e1000_gscl2_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl2_rawwr(__DN(t) *_dev, e1000_gscl2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b14, _regval);
}

static inline void e1000_gscl2_wr(__DN(t) *_dev, e1000_gscl2_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl2_wr(__DN(t) *_dev, e1000_gscl2_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b14, _regval);
}

static inline int e1000_gscl2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gscl2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_gscl2_t _regval = mackerel_read_addr_32(_dev->base, 0x5b14);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gscl2 (PCIe statistics control 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event0 =\t%" PRIx8 "\t(Event number that counter 0 counts)\n", e1000_gscl2_event0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event1 =\t%" PRIx8 "\t(Event number that counter 1 counts)\n", e1000_gscl2_event1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event2 =\t%" PRIx8 "\t(Event number that counter 2 counts)\n", e1000_gscl2_event2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " event3 =\t%" PRIx8 "\t(Event number that counter 3 counts)\n", e1000_gscl2_event3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_gscl2_event0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event0_rdf(__DN(t) *_dev)
{
    e1000_gscl2_t _regval = mackerel_read_addr_32(_dev->base, 0x5b14);
    return(e1000_gscl2_event0_extract(_regval));
}

static inline uint8_t e1000_gscl2_event1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event1_rdf(__DN(t) *_dev)
{
    e1000_gscl2_t _regval = mackerel_read_addr_32(_dev->base, 0x5b14);
    return(e1000_gscl2_event1_extract(_regval));
}

static inline uint8_t e1000_gscl2_event2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event2_rdf(__DN(t) *_dev)
{
    e1000_gscl2_t _regval = mackerel_read_addr_32(_dev->base, 0x5b14);
    return(e1000_gscl2_event2_extract(_regval));
}

static inline uint8_t e1000_gscl2_event3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl2_event3_rdf(__DN(t) *_dev)
{
    e1000_gscl2_t _regval = mackerel_read_addr_32(_dev->base, 0x5b14);
    return(e1000_gscl2_event3_extract(_regval));
}

static inline void e1000_gscl2_event0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl2_event0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl2_t _regval = 0xff & (((e1000_gscl2_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5b14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b14, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl2_event1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl2_event1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl2_t _regval = 0xff00 & (((e1000_gscl2_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x5b14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b14, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl2_event2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl2_event2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl2_t _regval = 0xff0000 & (((e1000_gscl2_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->base, 0x5b14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b14, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl2_event3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl2_event3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl2_t _regval = 0xff000000 & (((e1000_gscl2_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x5b14)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b14, _regval);
    // No shadow register to write to
}

/*
 * Register gscl3: PCIe statistics control 3
 * Type: e1000.gscl3 (Implicit type of PCIe statistics control 3 register)
 *   fc_th0	(size 12, offset 0, init 0):	RW	Threshold of flow control credits 0
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   fc_th1	(size 12, offset 16, init 0):	RW	Threshold of flow control credits 1
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline e1000_gscl3_t e1000_gscl3_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl3_t e1000_gscl3_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b18));
}

static inline e1000_gscl3_t e1000_gscl3_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl3_t e1000_gscl3_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b18));
}

static inline void e1000_gscl3_rawwr(__DN(t) *_dev, e1000_gscl3_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl3_rawwr(__DN(t) *_dev, e1000_gscl3_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b18, _regval);
}

static inline void e1000_gscl3_wr(__DN(t) *_dev, e1000_gscl3_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl3_wr(__DN(t) *_dev, e1000_gscl3_t _regval)
{
    _regval = (_regval & 0xfff0fff);
    // No MB1 fields present
    _regval = (_regval | (0xf000f000 & mackerel_read_addr_32(_dev->base, 0x5b18)));
    mackerel_write_addr_32(_dev->base, 0x5b18, _regval);
}

static inline int e1000_gscl3_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gscl3_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_gscl3_t _regval = mackerel_read_addr_32(_dev->base, 0x5b18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gscl3 (PCIe statistics control 3): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fc_th0 =\t%" PRIx16 "\t(Threshold of flow control credits 0)\n", e1000_gscl3_fc_th0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fc_th1 =\t%" PRIx16 "\t(Threshold of flow control credits 1)\n", e1000_gscl3_fc_th1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint16_t e1000_gscl3_fc_th0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_gscl3_fc_th0_rdf(__DN(t) *_dev)
{
    e1000_gscl3_t _regval = mackerel_read_addr_32(_dev->base, 0x5b18);
    return(e1000_gscl3_fc_th0_extract(_regval));
}

static inline uint16_t e1000_gscl3_fc_th1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_gscl3_fc_th1_rdf(__DN(t) *_dev)
{
    e1000_gscl3_t _regval = mackerel_read_addr_32(_dev->base, 0x5b18);
    return(e1000_gscl3_fc_th1_extract(_regval));
}

static inline void e1000_gscl3_fc_th0_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl3_fc_th0_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_gscl3_t _regval = 0xfff & (((e1000_gscl3_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x5b18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b18, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl3_fc_th1_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl3_fc_th1_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_gscl3_t _regval = 0xfff0000 & (((e1000_gscl3_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf000ffff & mackerel_read_addr_32(_dev->base, 0x5b18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b18, _regval);
    // No shadow register to write to
}

/*
 * Register gscl4: PCIe statistics control 4
 * Type: e1000.gscl4 (Implicit type of PCIe statistics control 4 register)
 *   coml_th	(size 10, offset 0, init 0):	RW	Completions latency threshold
 *   rb_th	(size 6, offset 10, init 0):	RW	Retry buffer threshold
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e1000_gscl4_t e1000_gscl4_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl4_t e1000_gscl4_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b1c));
}

static inline e1000_gscl4_t e1000_gscl4_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_gscl4_t e1000_gscl4_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b1c));
}

static inline void e1000_gscl4_rawwr(__DN(t) *_dev, e1000_gscl4_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl4_rawwr(__DN(t) *_dev, e1000_gscl4_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b1c, _regval);
}

static inline void e1000_gscl4_wr(__DN(t) *_dev, e1000_gscl4_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscl4_wr(__DN(t) *_dev, e1000_gscl4_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x5b1c)));
    mackerel_write_addr_32(_dev->base, 0x5b1c, _regval);
}

static inline int e1000_gscl4_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gscl4_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_gscl4_t _regval = mackerel_read_addr_32(_dev->base, 0x5b1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gscl4 (PCIe statistics control 4): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " coml_th =\t%" PRIx16 "\t(Completions latency threshold)\n", e1000_gscl4_coml_th_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rb_th =\t%" PRIx8 "\t(Retry buffer threshold)\n", e1000_gscl4_rb_th_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e1000_gscl4_coml_th_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e1000_gscl4_coml_th_rdf(__DN(t) *_dev)
{
    e1000_gscl4_t _regval = mackerel_read_addr_32(_dev->base, 0x5b1c);
    return(e1000_gscl4_coml_th_extract(_regval));
}

static inline uint8_t e1000_gscl4_rb_th_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gscl4_rb_th_rdf(__DN(t) *_dev)
{
    e1000_gscl4_t _regval = mackerel_read_addr_32(_dev->base, 0x5b1c);
    return(e1000_gscl4_rb_th_extract(_regval));
}

static inline void e1000_gscl4_coml_th_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl4_coml_th_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e1000_gscl4_t _regval = 0x3ff & (((e1000_gscl4_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffc00 & mackerel_read_addr_32(_dev->base, 0x5b1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b1c, _regval);
    // No shadow register to write to
}

static inline void e1000_gscl4_rb_th_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gscl4_rb_th_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_gscl4_t _regval = 0xfc00 & (((e1000_gscl4_t )(_fieldval)) << 10);
    _regval = (_regval | (0xffff03ff & mackerel_read_addr_32(_dev->base, 0x5b1c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b1c, _regval);
    // No shadow register to write to
}

/*
 * Register array gscn: PCIe counter
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_gscn_length = 4;
static inline uint32_t e1000_gscn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_gscn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b20 + (_i * (32 / 8))));
}

static inline uint32_t e1000_gscn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_gscn_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b20 + (_i * (32 / 8))));
}

static inline void e1000_gscn_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscn_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b20 + (_i * (32 / 8)), _regval);
}

static inline void e1000_gscn_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gscn_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5b20 + (_i * (32 / 8)), _regval);
}

static inline int e1000_gscn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_gscn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5b20 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "gscn", _i, "PCIe counter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_gscn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gscn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_gscn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register factps: Fn. active & power state to MNG
 * Type: e1000.factps (Implicit type of Fn. active & power state to MNG register)
 *   f0ps	(size 2, offset 0, init 0):	RO	Power state of fn. 0
 *   lan0v	(size 1, offset 2, init 0):	RO	LAN 0 valid enable
 *   f0aux	(size 1, offset 3, init 0):	RO	Fn. 0 aux power enable shadow
 *   lan0en	(size 1, offset 4, init 0):	RO	LAN 0 enabled
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   f1ps	(size 2, offset 6, init 0):	RO	Power state of fn. 1
 *   lan1v	(size 1, offset 8, init 0):	RO	LAN 1 valid enable
 *   f1aux	(size 1, offset 9, init 0):	RO	Fn. 1 aux power enable shadow
 *   lan1en	(size 1, offset 10, init 0):	RO	LAN 1 enabled
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   f2ps	(size 2, offset 12, init 0):	RO	Power state of fn. 2
 *   ide_en	(size 1, offset 14, init 0):	RO	IDE (function 2) enable
 *   f2aux	(size 1, offset 15, init 0):	RO	Fn. 2 aux power enable shadow
 *   _anon16	(size 2, offset 16, init 0):	RSVD	_
 *   f3ps	(size 2, offset 18, init 0):	RO	Power state of fn. 3
 *   sp_en	(size 1, offset 20, init 0):	RO	SP (function 3) enable
 *   f3aux	(size 1, offset 21, init 0):	RO	Fn. 3 aux power enable shadow
 *   _anon22	(size 2, offset 22, init 0):	RSVD	_
 *   f4ps	(size 2, offset 24, init 0):	RO	Power state of fn. 4
 *   ipmi_en	(size 1, offset 26, init 0):	RO	IPMI (function 4) enable
 *   f4aux	(size 1, offset 27, init 0):	RO	Fn. 4 aux power enable shadow
 *   _anon28	(size 1, offset 28, init 0):	RSVD	_
 *   mngcg	(size 1, offset 29, init 0):	RO	MNG clock gated
 *   lanfs	(size 1, offset 30, init 0):	RO	LAN function select
 *   pmchg	(size 1, offset 31, init 0):	RO	PM state changed
 */
static inline e1000_factps_t e1000_factps_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b30));
}

static inline e1000_factps_t e1000_factps_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_factps_t e1000_factps_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b30));
}

static inline void e1000_factps_rawwr(__DN(t) *_dev, e1000_factps_t _regval) __attribute__ ((always_inline));
static inline void e1000_factps_rawwr(__DN(t) *_dev, e1000_factps_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b30, _regval);
}

// Register factps is not writeable
static inline int e1000_factps_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_factps_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register factps (Fn. active & power state to MNG): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f0ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 0)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan0v =\t%" PRIx8 "\t(LAN 0 valid enable)\n", e1000_factps_lan0v_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0aux =\t%" PRIx8 "\t(Fn. 0 aux power enable shadow)\n", e1000_factps_f0aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan0en =\t%" PRIx8 "\t(LAN 0 enabled)\n", e1000_factps_lan0en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f1ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 1)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan1v =\t%" PRIx8 "\t(LAN 1 valid enable)\n", e1000_factps_lan1v_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1aux =\t%" PRIx8 "\t(Fn. 1 aux power enable shadow)\n", e1000_factps_f1aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan1en =\t%" PRIx8 "\t(LAN 1 enabled)\n", e1000_factps_lan1en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f2ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f2ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 2)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ide_en =\t%" PRIx8 "\t(IDE (function 2) enable)\n", e1000_factps_ide_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f2aux =\t%" PRIx8 "\t(Fn. 2 aux power enable shadow)\n", e1000_factps_f2aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f3ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f3ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 3)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sp_en =\t%" PRIx8 "\t(SP (function 3) enable)\n", e1000_factps_sp_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f3aux =\t%" PRIx8 "\t(Fn. 3 aux power enable shadow)\n", e1000_factps_f3aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f4ps =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fps_prtval(_s + _r, _avail, e1000_factps_f4ps_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Power state of fn. 4)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipmi_en =\t%" PRIx8 "\t(IPMI (function 4) enable)\n", e1000_factps_ipmi_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f4aux =\t%" PRIx8 "\t(Fn. 4 aux power enable shadow)\n", e1000_factps_f4aux_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mngcg =\t%" PRIx8 "\t(MNG clock gated)\n", e1000_factps_mngcg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lanfs =\t%" PRIx8 "\t(LAN function select)\n", e1000_factps_lanfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmchg =\t%" PRIx8 "\t(PM state changed)\n", e1000_factps_pmchg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline e1000_fps_t e1000_factps_f0ps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f0ps_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f0ps_extract(_regval));
}

static inline uint8_t e1000_factps_lan0v_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan0v_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_lan0v_extract(_regval));
}

static inline uint8_t e1000_factps_f0aux_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f0aux_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f0aux_extract(_regval));
}

static inline uint8_t e1000_factps_lan0en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan0en_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_lan0en_extract(_regval));
}

static inline e1000_fps_t e1000_factps_f1ps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f1ps_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f1ps_extract(_regval));
}

static inline uint8_t e1000_factps_lan1v_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan1v_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_lan1v_extract(_regval));
}

static inline uint8_t e1000_factps_f1aux_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f1aux_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f1aux_extract(_regval));
}

static inline uint8_t e1000_factps_lan1en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lan1en_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_lan1en_extract(_regval));
}

static inline e1000_fps_t e1000_factps_f2ps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f2ps_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f2ps_extract(_regval));
}

static inline uint8_t e1000_factps_ide_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_ide_en_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_ide_en_extract(_regval));
}

static inline uint8_t e1000_factps_f2aux_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f2aux_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f2aux_extract(_regval));
}

static inline e1000_fps_t e1000_factps_f3ps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f3ps_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f3ps_extract(_regval));
}

static inline uint8_t e1000_factps_sp_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_sp_en_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_sp_en_extract(_regval));
}

static inline uint8_t e1000_factps_f3aux_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f3aux_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f3aux_extract(_regval));
}

static inline e1000_fps_t e1000_factps_f4ps_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fps_t e1000_factps_f4ps_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f4ps_extract(_regval));
}

static inline uint8_t e1000_factps_ipmi_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_ipmi_en_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_ipmi_en_extract(_regval));
}

static inline uint8_t e1000_factps_f4aux_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_f4aux_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_f4aux_extract(_regval));
}

static inline uint8_t e1000_factps_mngcg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_mngcg_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_mngcg_extract(_regval));
}

static inline uint8_t e1000_factps_lanfs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_lanfs_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_lanfs_extract(_regval));
}

static inline uint8_t e1000_factps_pmchg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_factps_pmchg_rdf(__DN(t) *_dev)
{
    e1000_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x5b30);
    return(e1000_factps_pmchg_extract(_regval));
}

/*
 * Register array gioanactl: Analog control
 * Type: e1000.anal_ctl (Analog circuit configuration)
 *   data	(size 8, offset 0, init 0):	RW	Data to SerDes
 *   address	(size 8, offset 8, init 0):	RW	Address to SerDes
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Done indicator
 */
static const size_t e1000_gioanactl_length = 4;
static inline e1000_anal_ctl_t e1000_gioanactl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_gioanactl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8))));
}

static inline e1000_anal_ctl_t e1000_gioanactl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_gioanactl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8))));
}

static inline void e1000_gioanactl_rawwr(__DN(t) *_dev, int _i, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_gioanactl_rawwr(__DN(t) *_dev, int _i, e1000_anal_ctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)), _regval);
}

static inline void e1000_gioanactl_wr(__DN(t) *_dev, int _i, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_gioanactl_wr(__DN(t) *_dev, int _i, e1000_anal_ctl_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)), _regval);
}

static inline int e1000_gioanactl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_gioanactl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "gioanactl", _i, "Analog control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to SerDes)\n", e1000_anal_ctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to SerDes)\n", e1000_anal_ctl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done indicator)\n", e1000_anal_ctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_gioanactl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gioanactl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_gioanactl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e1000_gioanactl_data_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_gioanactl_data_rdf(__DN(t) *_dev, int _i)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)));
    return(e1000_anal_ctl_data_extract(_regval));
}

static inline uint8_t e1000_gioanactl_address_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_gioanactl_address_rdf(__DN(t) *_dev, int _i)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)));
    return(e1000_anal_ctl_address_extract(_regval));
}

static inline uint8_t e1000_gioanactl_done_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e1000_gioanactl_done_rdf(__DN(t) *_dev, int _i)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)));
    return(e1000_anal_ctl_done_extract(_regval));
}

static inline void e1000_gioanactl_data_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gioanactl_data_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff & (((e1000_anal_ctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e1000_gioanactl_address_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gioanactl_address_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff00 & (((e1000_anal_ctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e1000_gioanactl_done_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gioanactl_done_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0x80000000 & (((e1000_anal_ctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b34 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register gioanactlall: Analog control
 * Type: e1000.anal_ctl (Analog circuit configuration)
 *   data	(size 8, offset 0, init 0):	RW	Data to SerDes
 *   address	(size 8, offset 8, init 0):	RW	Address to SerDes
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Done indicator
 */
static inline e1000_anal_ctl_t e1000_gioanactlall_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_gioanactlall_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b44));
}

static inline e1000_anal_ctl_t e1000_gioanactlall_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_gioanactlall_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b44));
}

static inline void e1000_gioanactlall_rawwr(__DN(t) *_dev, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_gioanactlall_rawwr(__DN(t) *_dev, e1000_anal_ctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b44, _regval);
}

static inline void e1000_gioanactlall_wr(__DN(t) *_dev, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_gioanactlall_wr(__DN(t) *_dev, e1000_anal_ctl_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x5b44)));
    mackerel_write_addr_32(_dev->base, 0x5b44, _regval);
}

static inline int e1000_gioanactlall_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gioanactlall_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gioanactlall (Analog control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to SerDes)\n", e1000_anal_ctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to SerDes)\n", e1000_anal_ctl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done indicator)\n", e1000_anal_ctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_gioanactlall_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gioanactlall_data_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b44);
    return(e1000_anal_ctl_data_extract(_regval));
}

static inline uint8_t e1000_gioanactlall_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gioanactlall_address_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b44);
    return(e1000_anal_ctl_address_extract(_regval));
}

static inline uint8_t e1000_gioanactlall_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_gioanactlall_done_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b44);
    return(e1000_anal_ctl_done_extract(_regval));
}

static inline void e1000_gioanactlall_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gioanactlall_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff & (((e1000_anal_ctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5b44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b44, _regval);
    // No shadow register to write to
}

static inline void e1000_gioanactlall_address_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gioanactlall_address_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff00 & (((e1000_anal_ctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x5b44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b44, _regval);
    // No shadow register to write to
}

static inline void e1000_gioanactlall_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_gioanactlall_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0x80000000 & (((e1000_anal_ctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x5b44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b44, _regval);
    // No shadow register to write to
}

/*
 * Register ccmctl: CCM analog control
 * Type: e1000.anal_ctl (Analog circuit configuration)
 *   data	(size 8, offset 0, init 0):	RW	Data to SerDes
 *   address	(size 8, offset 8, init 0):	RW	Address to SerDes
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Done indicator
 */
static inline e1000_anal_ctl_t e1000_ccmctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_ccmctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b48));
}

static inline e1000_anal_ctl_t e1000_ccmctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_ccmctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b48));
}

static inline void e1000_ccmctl_rawwr(__DN(t) *_dev, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_ccmctl_rawwr(__DN(t) *_dev, e1000_anal_ctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
}

static inline void e1000_ccmctl_wr(__DN(t) *_dev, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_ccmctl_wr(__DN(t) *_dev, e1000_anal_ctl_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x5b48)));
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
}

static inline int e1000_ccmctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ccmctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ccmctl (CCM analog control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to SerDes)\n", e1000_anal_ctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to SerDes)\n", e1000_anal_ctl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done indicator)\n", e1000_anal_ctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_ccmctl_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ccmctl_data_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    return(e1000_anal_ctl_data_extract(_regval));
}

static inline uint8_t e1000_ccmctl_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ccmctl_address_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    return(e1000_anal_ctl_address_extract(_regval));
}

static inline uint8_t e1000_ccmctl_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_ccmctl_done_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    return(e1000_anal_ctl_done_extract(_regval));
}

static inline void e1000_ccmctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ccmctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff & (((e1000_anal_ctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5b48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
    // No shadow register to write to
}

static inline void e1000_ccmctl_address_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ccmctl_address_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff00 & (((e1000_anal_ctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x5b48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
    // No shadow register to write to
}

static inline void e1000_ccmctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_ccmctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0x80000000 & (((e1000_anal_ctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x5b48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
    // No shadow register to write to
}

/*
 * Register anactl: Analog control
 * Type: e1000.anactl (Implicit type of Analog control register)
 *   data	(size 8, offset 0, init 0):	RW	Data to/from analog register
 *   address	(size 8, offset 8, init 0):	RW	Address of analog register
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   write	(size 1, offset 30, init 0):	RW	Read/write command
 *   done	(size 1, offset 31, init 0):	RW	Done indication
 */
static inline e1000_anactl_t e1000_anactl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anactl_t e1000_anactl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b48));
}

static inline e1000_anactl_t e1000_anactl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anactl_t e1000_anactl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b48));
}

static inline void e1000_anactl_rawwr(__DN(t) *_dev, e1000_anactl_t _regval) __attribute__ ((always_inline));
static inline void e1000_anactl_rawwr(__DN(t) *_dev, e1000_anactl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
}

static inline void e1000_anactl_wr(__DN(t) *_dev, e1000_anactl_t _regval) __attribute__ ((always_inline));
static inline void e1000_anactl_wr(__DN(t) *_dev, e1000_anactl_t _regval)
{
    _regval = (_regval & 0xc000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x3fff0000 & mackerel_read_addr_32(_dev->base, 0x5b48)));
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
}

static inline int e1000_anactl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_anactl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_anactl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register anactl (Analog control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to/from analog register)\n", e1000_anactl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address of analog register)\n", e1000_anactl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " write =\t%" PRIx8 "\t(Read/write command)\n", e1000_anactl_write_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done indication)\n", e1000_anactl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_anactl_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_data_rdf(__DN(t) *_dev)
{
    e1000_anactl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    return(e1000_anactl_data_extract(_regval));
}

static inline uint8_t e1000_anactl_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_address_rdf(__DN(t) *_dev)
{
    e1000_anactl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    return(e1000_anactl_address_extract(_regval));
}

static inline uint8_t e1000_anactl_write_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_write_rdf(__DN(t) *_dev)
{
    e1000_anactl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    return(e1000_anactl_write_extract(_regval));
}

static inline uint8_t e1000_anactl_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_anactl_done_rdf(__DN(t) *_dev)
{
    e1000_anactl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b48);
    return(e1000_anactl_done_extract(_regval));
}

static inline void e1000_anactl_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_anactl_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anactl_t _regval = 0xff & (((e1000_anactl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5b48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
    // No shadow register to write to
}

static inline void e1000_anactl_address_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_anactl_address_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anactl_t _regval = 0xff00 & (((e1000_anactl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x5b48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
    // No shadow register to write to
}

static inline void e1000_anactl_write_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_anactl_write_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anactl_t _regval = 0x40000000 & (((e1000_anactl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x5b48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
    // No shadow register to write to
}

static inline void e1000_anactl_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_anactl_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anactl_t _regval = 0x80000000 & (((e1000_anactl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x5b48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b48, _regval);
    // No shadow register to write to
}

/*
 * Register scctl: SCC analog control
 * Type: e1000.anal_ctl (Analog circuit configuration)
 *   data	(size 8, offset 0, init 0):	RW	Data to SerDes
 *   address	(size 8, offset 8, init 0):	RW	Address to SerDes
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Done indicator
 */
static inline e1000_anal_ctl_t e1000_scctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_scctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b4c));
}

static inline e1000_anal_ctl_t e1000_scctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_anal_ctl_t e1000_scctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b4c));
}

static inline void e1000_scctl_rawwr(__DN(t) *_dev, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_scctl_rawwr(__DN(t) *_dev, e1000_anal_ctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b4c, _regval);
}

static inline void e1000_scctl_wr(__DN(t) *_dev, e1000_anal_ctl_t _regval) __attribute__ ((always_inline));
static inline void e1000_scctl_wr(__DN(t) *_dev, e1000_anal_ctl_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0x5b4c)));
    mackerel_write_addr_32(_dev->base, 0x5b4c, _regval);
}

static inline int e1000_scctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_scctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register scctl (SCC analog control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to SerDes)\n", e1000_anal_ctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to SerDes)\n", e1000_anal_ctl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Done indicator)\n", e1000_anal_ctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e1000_scctl_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_scctl_data_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4c);
    return(e1000_anal_ctl_data_extract(_regval));
}

static inline uint8_t e1000_scctl_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_scctl_address_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4c);
    return(e1000_anal_ctl_address_extract(_regval));
}

static inline uint8_t e1000_scctl_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_scctl_done_rdf(__DN(t) *_dev)
{
    e1000_anal_ctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5b4c);
    return(e1000_anal_ctl_done_extract(_regval));
}

static inline void e1000_scctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_scctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff & (((e1000_anal_ctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5b4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4c, _regval);
    // No shadow register to write to
}

static inline void e1000_scctl_address_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_scctl_address_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0xff00 & (((e1000_anal_ctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x5b4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4c, _regval);
    // No shadow register to write to
}

static inline void e1000_scctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_scctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_anal_ctl_t _regval = 0x80000000 & (((e1000_anal_ctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x5b4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b4c, _regval);
    // No shadow register to write to
}

/*
 * Register swsm: Software semaphore
 * Type: e1000.swsm (Implicit type of Software semaphore register)
 *   smbi	(size 1, offset 0, init 0):	RW	Semaphore bit
 *   swesmbi	(size 1, offset 1, init 0):	RW	Software EEPROM semaphore bit
 *   wmng	(size 1, offset 2, init 0):	RW	Wake MNG clock
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e1000_swsm_t e1000_swsm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_swsm_t e1000_swsm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b50));
}

static inline e1000_swsm_t e1000_swsm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_swsm_t e1000_swsm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b50));
}

static inline void e1000_swsm_rawwr(__DN(t) *_dev, e1000_swsm_t _regval) __attribute__ ((always_inline));
static inline void e1000_swsm_rawwr(__DN(t) *_dev, e1000_swsm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b50, _regval);
}

static inline void e1000_swsm_wr(__DN(t) *_dev, e1000_swsm_t _regval) __attribute__ ((always_inline));
static inline void e1000_swsm_wr(__DN(t) *_dev, e1000_swsm_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x5b50)));
    mackerel_write_addr_32(_dev->base, 0x5b50, _regval);
}

static inline int e1000_swsm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_swsm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_swsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register swsm (Software semaphore): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smbi =\t%" PRIx8 "\t(Semaphore bit)\n", e1000_swsm_smbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swesmbi =\t%" PRIx8 "\t(Software EEPROM semaphore bit)\n", e1000_swsm_swesmbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wmng =\t%" PRIx8 "\t(Wake MNG clock)\n", e1000_swsm_wmng_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e1000_swsm_smbi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_swsm_smbi_rdf(__DN(t) *_dev)
{
    e1000_swsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b50);
    return(e1000_swsm_smbi_extract(_regval));
}

static inline uint8_t e1000_swsm_swesmbi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_swsm_swesmbi_rdf(__DN(t) *_dev)
{
    e1000_swsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b50);
    return(e1000_swsm_swesmbi_extract(_regval));
}

static inline uint8_t e1000_swsm_wmng_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_swsm_wmng_rdf(__DN(t) *_dev)
{
    e1000_swsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b50);
    return(e1000_swsm_wmng_extract(_regval));
}

static inline void e1000_swsm_smbi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_swsm_smbi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_swsm_t _regval = 0x1 & (((e1000_swsm_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x5b50)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b50, _regval);
    // No shadow register to write to
}

static inline void e1000_swsm_swesmbi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_swsm_swesmbi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_swsm_t _regval = 0x2 & (((e1000_swsm_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x5b50)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b50, _regval);
    // No shadow register to write to
}

static inline void e1000_swsm_wmng_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_swsm_wmng_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_swsm_t _regval = 0x4 & (((e1000_swsm_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x5b50)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b50, _regval);
    // No shadow register to write to
}

/*
 * Register fwsm: Firmware semaphore
 * Type: e1000.fwsm (Implicit type of Firmware semaphore register)
 *   eep_fw	(size 1, offset 0, init 0):	RW	EEPROM firmware semaphore
 *   fw_mode	(size 3, offset 1, init 0):	RW	Firmware mode
 *   ide_on	(size 1, offset 4, init 0):	RW	IDE redirection on
 *   sol_on	(size 1, offset 5, init 0):	RW	SOL on
 *   eep_rl	(size 1, offset 6, init 0):	RW	EEPROM reloaded indication
 *   _anon7	(size 8, offset 7, init 0):	RSVD	_
 *   fwval	(size 1, offset 15, init 0):	RW	Firmware valid bit
 *   rstcnt	(size 3, offset 16, init 0):	RW	Reset counter
 *   error	(size 6, offset 19, init 0):	RW	External error indication
 *   _anon25	(size 7, offset 25, init 0):	RSVD	_
 */
static inline e1000_fwsm_t e1000_fwsm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b54));
}

static inline e1000_fwsm_t e1000_fwsm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fwsm_t e1000_fwsm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5b54));
}

static inline void e1000_fwsm_rawwr(__DN(t) *_dev, e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline void e1000_fwsm_rawwr(__DN(t) *_dev, e1000_fwsm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
}

static inline void e1000_fwsm_wr(__DN(t) *_dev, e1000_fwsm_t _regval) __attribute__ ((always_inline));
static inline void e1000_fwsm_wr(__DN(t) *_dev, e1000_fwsm_t _regval)
{
    _regval = (_regval & 0x1ff807f);
    // No MB1 fields present
    _regval = (_regval | (0xfe007f80 & mackerel_read_addr_32(_dev->base, 0x5b54)));
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
}

static inline int e1000_fwsm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fwsm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fwsm (Firmware semaphore): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eep_fw =\t%" PRIx8 "\t(EEPROM firmware semaphore)\n", e1000_fwsm_eep_fw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fwmode_prtval(_s + _r, _avail, e1000_fwsm_fw_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Firmware mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ide_on =\t%" PRIx8 "\t(IDE redirection on)\n", e1000_fwsm_ide_on_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sol_on =\t%" PRIx8 "\t(SOL on)\n", e1000_fwsm_sol_on_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eep_rl =\t%" PRIx8 "\t(EEPROM reloaded indication)\n", e1000_fwsm_eep_rl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwval =\t%" PRIx8 "\t(Firmware valid bit)\n", e1000_fwsm_fwval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rstcnt =\t%" PRIx8 "\t(Reset counter)\n", e1000_fwsm_rstcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " error =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_pcierr_prtval(_s + _r, _avail, e1000_fwsm_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(External error indication)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    return(_r);
}

static inline uint8_t e1000_fwsm_eep_fw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_eep_fw_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_eep_fw_extract(_regval));
}

static inline e1000_fwmode_t e1000_fwsm_fw_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_fwmode_t e1000_fwsm_fw_mode_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_fw_mode_extract(_regval));
}

static inline uint8_t e1000_fwsm_ide_on_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_ide_on_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_ide_on_extract(_regval));
}

static inline uint8_t e1000_fwsm_sol_on_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_sol_on_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_sol_on_extract(_regval));
}

static inline uint8_t e1000_fwsm_eep_rl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_eep_rl_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_eep_rl_extract(_regval));
}

static inline uint8_t e1000_fwsm_fwval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_fwval_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_fwval_extract(_regval));
}

static inline uint8_t e1000_fwsm_rstcnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e1000_fwsm_rstcnt_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_rstcnt_extract(_regval));
}

static inline e1000_pcierr_t e1000_fwsm_error_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e1000_pcierr_t e1000_fwsm_error_rdf(__DN(t) *_dev)
{
    e1000_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x5b54);
    return(e1000_fwsm_error_extract(_regval));
}

static inline void e1000_fwsm_eep_fw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_eep_fw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fwsm_t _regval = 0x1 & (((e1000_fwsm_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

static inline void e1000_fwsm_fw_mode_wrf(__DN(t) *_dev, e1000_fwmode_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_fw_mode_wrf(__DN(t) *_dev, e1000_fwmode_t _fieldval)
{
    e1000_fwsm_t _regval = 0xe & (((e1000_fwsm_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffff1 & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

static inline void e1000_fwsm_ide_on_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_ide_on_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fwsm_t _regval = 0x10 & (((e1000_fwsm_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

static inline void e1000_fwsm_sol_on_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_sol_on_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fwsm_t _regval = 0x20 & (((e1000_fwsm_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

static inline void e1000_fwsm_eep_rl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_eep_rl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fwsm_t _regval = 0x40 & (((e1000_fwsm_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

static inline void e1000_fwsm_fwval_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_fwval_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fwsm_t _regval = 0x8000 & (((e1000_fwsm_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

static inline void e1000_fwsm_rstcnt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_rstcnt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e1000_fwsm_t _regval = 0x70000 & (((e1000_fwsm_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff8ffff & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

static inline void e1000_fwsm_error_wrf(__DN(t) *_dev, e1000_pcierr_t _fieldval) __attribute__ ((always_inline));
static inline void e1000_fwsm_error_wrf(__DN(t) *_dev, e1000_pcierr_t _fieldval)
{
    e1000_fwsm_t _regval = 0x1f80000 & (((e1000_fwsm_t )(_fieldval)) << 19);
    _regval = (_regval | (0xfe07ffff & mackerel_read_addr_32(_dev->base, 0x5b54)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5b54, _regval);
    // No shadow register to write to
}

/*
 * Register crcerrs: CRC error count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_crcerrs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_crcerrs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4000));
}

static inline uint32_t e1000_crcerrs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_crcerrs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4000));
}

static inline void e1000_crcerrs_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_crcerrs_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4000, _regval);
}

// Register crcerrs is not writeable
static inline int e1000_crcerrs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_crcerrs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register crcerrs (CRC error count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register algnerrc: Alignment error count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_algnerrc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_algnerrc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4004));
}

static inline uint32_t e1000_algnerrc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_algnerrc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4004));
}

static inline void e1000_algnerrc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_algnerrc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4004, _regval);
}

// Register algnerrc is not writeable
static inline int e1000_algnerrc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_algnerrc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4004);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register algnerrc (Alignment error count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register symerrs: Symbol error count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_symerrs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_symerrs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4008));
}

static inline uint32_t e1000_symerrs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_symerrs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4008));
}

static inline void e1000_symerrs_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_symerrs_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4008, _regval);
}

// Register symerrs is not writeable
static inline int e1000_symerrs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_symerrs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4008);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register symerrs (Symbol error count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rxerrc: Receive error count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_rxerrc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rxerrc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400c));
}

static inline uint32_t e1000_rxerrc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rxerrc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400c));
}

static inline void e1000_rxerrc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rxerrc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x400c, _regval);
}

// Register rxerrc is not writeable
static inline int e1000_rxerrc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rxerrc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x400c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxerrc (Receive error count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mpc: Missed packets count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_mpc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mpc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4010));
}

static inline uint32_t e1000_mpc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mpc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4010));
}

static inline void e1000_mpc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mpc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4010, _regval);
}

// Register mpc is not writeable
static inline int e1000_mpc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mpc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4010);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mpc (Missed packets count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register scc: Single collision count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_scc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_scc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4014));
}

static inline uint32_t e1000_scc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_scc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4014));
}

static inline void e1000_scc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_scc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4014, _regval);
}

// Register scc is not writeable
static inline int e1000_scc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_scc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4014);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register scc (Single collision count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ecol: Excessive collisions count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ecol_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ecol_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4018));
}

static inline uint32_t e1000_ecol_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ecol_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4018));
}

static inline void e1000_ecol_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ecol_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4018, _regval);
}

// Register ecol is not writeable
static inline int e1000_ecol_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ecol_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4018);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ecol (Excessive collisions count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mcc: Multiple collision count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_mcc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mcc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x401c));
}

static inline uint32_t e1000_mcc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mcc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x401c));
}

static inline void e1000_mcc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mcc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x401c, _regval);
}

// Register mcc is not writeable
static inline int e1000_mcc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mcc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x401c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mcc (Multiple collision count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register latecol: Late collisions count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_latecol_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_latecol_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4020));
}

static inline uint32_t e1000_latecol_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_latecol_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4020));
}

static inline void e1000_latecol_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_latecol_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4020, _regval);
}

// Register latecol is not writeable
static inline int e1000_latecol_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_latecol_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4020);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register latecol (Late collisions count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register colc: Collision count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_colc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_colc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4028));
}

static inline uint32_t e1000_colc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_colc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4028));
}

static inline void e1000_colc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_colc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4028, _regval);
}

// Register colc is not writeable
static inline int e1000_colc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_colc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4028);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register colc (Collision count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register dc: Defer count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_dc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_dc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4030));
}

static inline uint32_t e1000_dc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_dc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4030));
}

static inline void e1000_dc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_dc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4030, _regval);
}

// Register dc is not writeable
static inline int e1000_dc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_dc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4030);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dc (Defer count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tncrs: Transmit with no CRS
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_tncrs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tncrs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4034));
}

static inline uint32_t e1000_tncrs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tncrs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4034));
}

static inline void e1000_tncrs_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tncrs_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4034, _regval);
}

// Register tncrs is not writeable
static inline int e1000_tncrs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tncrs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4034);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tncrs (Transmit with no CRS): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register sec: Sequence error count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_sec_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_sec_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4038));
}

static inline uint32_t e1000_sec_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_sec_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4038));
}

static inline void e1000_sec_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_sec_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4038, _regval);
}

// Register sec is not writeable
static inline int e1000_sec_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_sec_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4038);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sec (Sequence error count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cexterr: Carrier extension error count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_cexterr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_cexterr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x403c));
}

static inline uint32_t e1000_cexterr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_cexterr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x403c));
}

static inline void e1000_cexterr_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_cexterr_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x403c, _regval);
}

// Register cexterr is not writeable
static inline int e1000_cexterr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_cexterr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x403c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cexterr (Carrier extension error count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rlec: Receive length error count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_rlec_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rlec_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4040));
}

static inline uint32_t e1000_rlec_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rlec_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4040));
}

static inline void e1000_rlec_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rlec_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4040, _regval);
}

// Register rlec is not writeable
static inline int e1000_rlec_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rlec_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4040);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rlec (Receive length error count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register xonrxc: XON received count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_xonrxc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xonrxc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4048));
}

static inline uint32_t e1000_xonrxc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xonrxc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4048));
}

static inline void e1000_xonrxc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_xonrxc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4048, _regval);
}

// Register xonrxc is not writeable
static inline int e1000_xonrxc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_xonrxc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4048);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xonrxc (XON received count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register xontxc: XON transmitted count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_xontxc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xontxc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404c));
}

static inline uint32_t e1000_xontxc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xontxc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x404c));
}

static inline void e1000_xontxc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_xontxc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x404c, _regval);
}

// Register xontxc is not writeable
static inline int e1000_xontxc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_xontxc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x404c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xontxc (XON transmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register xoffrxc: XOFF received count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_xoffrxc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xoffrxc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4050));
}

static inline uint32_t e1000_xoffrxc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xoffrxc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4050));
}

static inline void e1000_xoffrxc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_xoffrxc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4050, _regval);
}

// Register xoffrxc is not writeable
static inline int e1000_xoffrxc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_xoffrxc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4050);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xoffrxc (XOFF received count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register xofftxc: XOFF transmitted count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_xofftxc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xofftxc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4054));
}

static inline uint32_t e1000_xofftxc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_xofftxc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4054));
}

static inline void e1000_xofftxc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_xofftxc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4054, _regval);
}

// Register xofftxc is not writeable
static inline int e1000_xofftxc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_xofftxc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4054);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xofftxc (XOFF transmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register fcurc: FC received unsupported count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_fcurc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fcurc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4058));
}

static inline uint32_t e1000_fcurc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_fcurc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4058));
}

static inline void e1000_fcurc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_fcurc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4058, _regval);
}

// Register fcurc is not writeable
static inline int e1000_fcurc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_fcurc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4058);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcurc (FC received unsupported count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register prc64: Packets received (64 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_prc64_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc64_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x405c));
}

static inline uint32_t e1000_prc64_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc64_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x405c));
}

static inline void e1000_prc64_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_prc64_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x405c, _regval);
}

// Register prc64 is not writeable
static inline int e1000_prc64_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_prc64_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x405c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prc64 (Packets received (64 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register prc127: Packets received (65-127 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_prc127_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc127_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4060));
}

static inline uint32_t e1000_prc127_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc127_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4060));
}

static inline void e1000_prc127_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_prc127_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4060, _regval);
}

// Register prc127 is not writeable
static inline int e1000_prc127_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_prc127_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4060);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prc127 (Packets received (65-127 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register prc255: Packets received (128-255 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_prc255_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc255_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4064));
}

static inline uint32_t e1000_prc255_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc255_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4064));
}

static inline void e1000_prc255_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_prc255_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4064, _regval);
}

// Register prc255 is not writeable
static inline int e1000_prc255_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_prc255_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4064);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prc255 (Packets received (128-255 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register prc511: Packets received (256-511 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_prc511_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc511_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4068));
}

static inline uint32_t e1000_prc511_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc511_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4068));
}

static inline void e1000_prc511_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_prc511_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4068, _regval);
}

// Register prc511 is not writeable
static inline int e1000_prc511_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_prc511_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4068);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prc511 (Packets received (256-511 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register prc1023: Packets received (512-1023 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_prc1023_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc1023_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x406c));
}

static inline uint32_t e1000_prc1023_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc1023_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x406c));
}

static inline void e1000_prc1023_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_prc1023_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x406c, _regval);
}

// Register prc1023 is not writeable
static inline int e1000_prc1023_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_prc1023_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x406c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prc1023 (Packets received (512-1023 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register prc1522: Packets received (1024-max bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_prc1522_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc1522_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4070));
}

static inline uint32_t e1000_prc1522_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_prc1522_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4070));
}

static inline void e1000_prc1522_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_prc1522_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4070, _regval);
}

// Register prc1522 is not writeable
static inline int e1000_prc1522_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_prc1522_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4070);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register prc1522 (Packets received (1024-max bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gprc: Good packets received count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_gprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4074));
}

static inline uint32_t e1000_gprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4074));
}

static inline void e1000_gprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4074, _regval);
}

// Register gprc is not writeable
static inline int e1000_gprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4074);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gprc (Good packets received count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register bprc: Broadcast packets received count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_bprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_bprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4078));
}

static inline uint32_t e1000_bprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_bprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4078));
}

static inline void e1000_bprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_bprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4078, _regval);
}

// Register bprc is not writeable
static inline int e1000_bprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_bprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4078);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bprc (Broadcast packets received count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mcprc: Multicast packets received count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_mcprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mcprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x407c));
}

static inline uint32_t e1000_mcprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mcprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x407c));
}

static inline void e1000_mcprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mcprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x407c, _regval);
}

// Register mcprc is not writeable
static inline int e1000_mcprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mcprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x407c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mcprc (Multicast packets received count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gptc: Good packets transmitted count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_gptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4080));
}

static inline uint32_t e1000_gptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4080));
}

static inline void e1000_gptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4080, _regval);
}

// Register gptc is not writeable
static inline int e1000_gptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4080);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gptc (Good packets transmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gorcl: Good octets received count low
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_gorcl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gorcl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4088));
}

static inline uint32_t e1000_gorcl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gorcl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4088));
}

static inline void e1000_gorcl_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gorcl_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4088, _regval);
}

// Register gorcl is not writeable
static inline int e1000_gorcl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gorcl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4088);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gorcl (Good octets received count low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gorch: Good octets received count high
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_gorch_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gorch_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x408c));
}

static inline uint32_t e1000_gorch_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gorch_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x408c));
}

static inline void e1000_gorch_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gorch_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x408c, _regval);
}

// Register gorch is not writeable
static inline int e1000_gorch_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gorch_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x408c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gorch (Good octets received count high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gotcl: Good octets transmitted count low
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_gotcl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gotcl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4090));
}

static inline uint32_t e1000_gotcl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gotcl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4090));
}

static inline void e1000_gotcl_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gotcl_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4090, _regval);
}

// Register gotcl is not writeable
static inline int e1000_gotcl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gotcl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4090);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gotcl (Good octets transmitted count low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gotch: Good octets transmitted count high
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_gotch_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gotch_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4094));
}

static inline uint32_t e1000_gotch_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_gotch_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4094));
}

static inline void e1000_gotch_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_gotch_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4094, _regval);
}

// Register gotch is not writeable
static inline int e1000_gotch_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_gotch_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4094);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gotch (Good octets transmitted count high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rnbc: Receive no buffers count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_rnbc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rnbc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a0));
}

static inline uint32_t e1000_rnbc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rnbc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a0));
}

static inline void e1000_rnbc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rnbc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40a0, _regval);
}

// Register rnbc is not writeable
static inline int e1000_rnbc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rnbc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rnbc (Receive no buffers count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ruc: Receive undersize count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ruc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ruc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a4));
}

static inline uint32_t e1000_ruc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ruc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a4));
}

static inline void e1000_ruc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ruc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40a4, _regval);
}

// Register ruc is not writeable
static inline int e1000_ruc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ruc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ruc (Receive undersize count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rfc: Receive fragment count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_rfc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rfc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a8));
}

static inline uint32_t e1000_rfc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rfc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a8));
}

static inline void e1000_rfc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rfc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40a8, _regval);
}

// Register rfc is not writeable
static inline int e1000_rfc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rfc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rfc (Receive fragment count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register roc: Receive oversize count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_roc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_roc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40ac));
}

static inline uint32_t e1000_roc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_roc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40ac));
}

static inline void e1000_roc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_roc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40ac, _regval);
}

// Register roc is not writeable
static inline int e1000_roc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_roc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register roc (Receive oversize count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rjc: Receive jabber count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_rjc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rjc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b0));
}

static inline uint32_t e1000_rjc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_rjc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b0));
}

static inline void e1000_rjc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_rjc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40b0, _regval);
}

// Register rjc is not writeable
static inline int e1000_rjc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_rjc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rjc (Receive jabber count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mprc: Management packets receive count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_mprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b4));
}

static inline uint32_t e1000_mprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b4));
}

static inline void e1000_mprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40b4, _regval);
}

// Register mprc is not writeable
static inline int e1000_mprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mprc (Management packets receive count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mpdc: Management packets dropped count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_mpdc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mpdc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b8));
}

static inline uint32_t e1000_mpdc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mpdc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b8));
}

static inline void e1000_mpdc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mpdc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40b8, _regval);
}

// Register mpdc is not writeable
static inline int e1000_mpdc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mpdc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mpdc (Management packets dropped count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mptc: Management packets transmitted count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_mptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40bc));
}

static inline uint32_t e1000_mptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40bc));
}

static inline void e1000_mptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40bc, _regval);
}

// Register mptc is not writeable
static inline int e1000_mptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40bc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mptc (Management packets transmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register torl: Total octets received low
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_torl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_torl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c0));
}

static inline uint32_t e1000_torl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_torl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c0));
}

static inline void e1000_torl_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_torl_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40c0, _regval);
}

// Register torl is not writeable
static inline int e1000_torl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_torl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40c0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register torl (Total octets received low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register torh: Total octets received high
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_torh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_torh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c4));
}

static inline uint32_t e1000_torh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_torh_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c4));
}

static inline void e1000_torh_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_torh_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40c4, _regval);
}

// Register torh is not writeable
static inline int e1000_torh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_torh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40c4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register torh (Total octets received high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register totl: Total octets transmitted low
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_totl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_totl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c8));
}

static inline uint32_t e1000_totl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_totl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40c8));
}

static inline void e1000_totl_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_totl_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40c8, _regval);
}

// Register totl is not writeable
static inline int e1000_totl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_totl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40c8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register totl (Total octets transmitted low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register toth: Total octets transmitted high
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_toth_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_toth_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40cc));
}

static inline uint32_t e1000_toth_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_toth_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40cc));
}

static inline void e1000_toth_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_toth_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40cc, _regval);
}

// Register toth is not writeable
static inline int e1000_toth_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_toth_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40cc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register toth (Total octets transmitted high): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tpr: Total packets received
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_tpr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tpr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d0));
}

static inline uint32_t e1000_tpr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tpr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d0));
}

static inline void e1000_tpr_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tpr_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40d0, _regval);
}

// Register tpr is not writeable
static inline int e1000_tpr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tpr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tpr (Total packets received): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tpt: Total packets transmitted
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_tpt_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tpt_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d4));
}

static inline uint32_t e1000_tpt_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tpt_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d4));
}

static inline void e1000_tpt_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tpt_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40d4, _regval);
}

// Register tpt is not writeable
static inline int e1000_tpt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tpt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tpt (Total packets transmitted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ptc64: Packets transmitted (64 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ptc64_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc64_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d8));
}

static inline uint32_t e1000_ptc64_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc64_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d8));
}

static inline void e1000_ptc64_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ptc64_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40d8, _regval);
}

// Register ptc64 is not writeable
static inline int e1000_ptc64_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ptc64_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ptc64 (Packets transmitted (64 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ptc127: Packets transmitted (65-127 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ptc127_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc127_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40dc));
}

static inline uint32_t e1000_ptc127_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc127_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40dc));
}

static inline void e1000_ptc127_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ptc127_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40dc, _regval);
}

// Register ptc127 is not writeable
static inline int e1000_ptc127_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ptc127_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40dc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ptc127 (Packets transmitted (65-127 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ptc255: Packets transmitted (128-255 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ptc255_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc255_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40e0));
}

static inline uint32_t e1000_ptc255_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc255_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40e0));
}

static inline void e1000_ptc255_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ptc255_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40e0, _regval);
}

// Register ptc255 is not writeable
static inline int e1000_ptc255_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ptc255_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ptc255 (Packets transmitted (128-255 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ptc511: Packets transmitted (256-511 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ptc511_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc511_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40e4));
}

static inline uint32_t e1000_ptc511_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc511_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40e4));
}

static inline void e1000_ptc511_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ptc511_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40e4, _regval);
}

// Register ptc511 is not writeable
static inline int e1000_ptc511_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ptc511_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ptc511 (Packets transmitted (256-511 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ptc1023: Packets transmitted (512-1023 bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ptc1023_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc1023_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40e8));
}

static inline uint32_t e1000_ptc1023_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc1023_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40e8));
}

static inline void e1000_ptc1023_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ptc1023_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40e8, _regval);
}

// Register ptc1023 is not writeable
static inline int e1000_ptc1023_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ptc1023_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ptc1023 (Packets transmitted (512-1023 bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ptc1522: Packets transmitted (1024-max bytes) count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ptc1522_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc1522_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40ec));
}

static inline uint32_t e1000_ptc1522_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ptc1522_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40ec));
}

static inline void e1000_ptc1522_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ptc1522_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40ec, _regval);
}

// Register ptc1522 is not writeable
static inline int e1000_ptc1522_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ptc1522_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ptc1522 (Packets transmitted (1024-max bytes) count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mcptc: Multicast packets transmitted count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_mcptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mcptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40f0));
}

static inline uint32_t e1000_mcptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_mcptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40f0));
}

static inline void e1000_mcptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_mcptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40f0, _regval);
}

// Register mcptc is not writeable
static inline int e1000_mcptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_mcptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40f0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mcptc (Multicast packets transmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register bptc: Broadcast packets transmitted count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_bptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_bptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40f4));
}

static inline uint32_t e1000_bptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_bptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40f4));
}

static inline void e1000_bptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_bptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40f4, _regval);
}

// Register bptc is not writeable
static inline int e1000_bptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_bptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40f4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register bptc (Broadcast packets transmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tsctc: TCP segmentation context transmitted count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_tsctc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tsctc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40f8));
}

static inline uint32_t e1000_tsctc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tsctc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40f8));
}

static inline void e1000_tsctc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tsctc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40f8, _regval);
}

// Register tsctc is not writeable
static inline int e1000_tsctc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tsctc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40f8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tsctc (TCP segmentation context transmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tsctfc: TCP segmentation context tx fail count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_tsctfc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tsctfc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40fc));
}

static inline uint32_t e1000_tsctfc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_tsctfc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40fc));
}

static inline void e1000_tsctfc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_tsctfc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40fc, _regval);
}

// Register tsctfc is not writeable
static inline int e1000_tsctfc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_tsctfc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40fc);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tsctfc (TCP segmentation context tx fail count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register iac: Interrupt assertion count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_iac_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_iac_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4100));
}

static inline uint32_t e1000_iac_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_iac_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4100));
}

static inline void e1000_iac_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_iac_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4100, _regval);
}

// Register iac is not writeable
static inline int e1000_iac_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_iac_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4100);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register iac (Interrupt assertion count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register icrxptc: Interrupt cause rx packet timer expire count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_icrxptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4104));
}

static inline uint32_t e1000_icrxptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4104));
}

static inline void e1000_icrxptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_icrxptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4104, _regval);
}

// Register icrxptc is not writeable
static inline int e1000_icrxptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_icrxptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4104);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register icrxptc (Interrupt cause rx packet timer expire count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register icrxatc: Interrupt cause rx absolute timer expire count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_icrxatc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxatc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4108));
}

static inline uint32_t e1000_icrxatc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxatc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4108));
}

static inline void e1000_icrxatc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_icrxatc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4108, _regval);
}

// Register icrxatc is not writeable
static inline int e1000_icrxatc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_icrxatc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4108);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register icrxatc (Interrupt cause rx absolute timer expire count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ictxptc: Interrupt cause tx packet timer expire count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ictxptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410c));
}

static inline uint32_t e1000_ictxptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410c));
}

static inline void e1000_ictxptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ictxptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x410c, _regval);
}

// Register ictxptc is not writeable
static inline int e1000_ictxptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ictxptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x410c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ictxptc (Interrupt cause tx packet timer expire count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ictxatc: Interrupt cause tx absolute timer expire count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ictxatc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxatc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4110));
}

static inline uint32_t e1000_ictxatc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxatc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4110));
}

static inline void e1000_ictxatc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ictxatc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4110, _regval);
}

// Register ictxatc is not writeable
static inline int e1000_ictxatc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ictxatc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4110);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ictxatc (Interrupt cause tx absolute timer expire count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ictxqec: Interrupt cause transmit queue empty count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ictxqec_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxqec_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4118));
}

static inline uint32_t e1000_ictxqec_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxqec_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4118));
}

static inline void e1000_ictxqec_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ictxqec_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4118, _regval);
}

// Register ictxqec is not writeable
static inline int e1000_ictxqec_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ictxqec_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4118);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ictxqec (Interrupt cause transmit queue empty count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ictxdltc: Interrupt cause transmit descriptor low threshold count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_ictxdltc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxdltc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x411c));
}

static inline uint32_t e1000_ictxdltc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_ictxdltc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x411c));
}

static inline void e1000_ictxdltc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_ictxdltc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x411c, _regval);
}

// Register ictxdltc is not writeable
static inline int e1000_ictxdltc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_ictxdltc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x411c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ictxdltc (Interrupt cause transmit descriptor low threshold count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register icrxdmtc: Interrupt cause receive descriptor minimum threshold count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_icrxdmtc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxdmtc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4120));
}

static inline uint32_t e1000_icrxdmtc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxdmtc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4120));
}

static inline void e1000_icrxdmtc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_icrxdmtc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4120, _regval);
}

// Register icrxdmtc is not writeable
static inline int e1000_icrxdmtc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_icrxdmtc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4120);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register icrxdmtc (Interrupt cause receive descriptor minimum threshold count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register icrxoc: Interrupt cause receive overrun count
 * Type: e1000.uint32 (primitive type)
 */
static inline uint32_t e1000_icrxoc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxoc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4124));
}

static inline uint32_t e1000_icrxoc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e1000_icrxoc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4124));
}

static inline void e1000_icrxoc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_icrxoc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4124, _regval);
}

// Register icrxoc is not writeable
static inline int e1000_icrxoc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_icrxoc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4124);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register icrxoc (Interrupt cause receive overrun count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array statsregs: All stats registers
 * Type: e1000.uint32 (primitive type)
 */
static const size_t e1000_statsregs_length = 74;
static inline uint32_t e1000_statsregs_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_statsregs_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x4000 + (_i * (32 / 8))));
}

static inline uint32_t e1000_statsregs_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e1000_statsregs_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x4000 + (_i * (32 / 8))));
}

static inline void e1000_statsregs_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e1000_statsregs_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4000 + (_i * (32 / 8)), _regval);
}

// Register statsregs is not writeable
static inline int e1000_statsregs_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e1000_statsregs_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4000 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "statsregs", _i, "All stats registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e1000_statsregs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_statsregs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 74; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e1000_statsregs_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline int e1000_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e1000_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device e1000 (Intel e1000 Gigabit Ethernet):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ctrldup_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_eecd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_eerd_nm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_eerd_ms_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ctrlext_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fla_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mdic_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_serdesctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fcal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fcah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fct_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_kumctrlsta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_vet_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mdphya_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ufuse3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fcttv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_txcw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxcw_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ledctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_extcnf_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_extcnf_size_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_pba_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_eemngctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_sw_fw_sync_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_icr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_itr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ics_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ims_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_imc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_iam_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_eitr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ert_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fcrtl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fcrth_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_psrctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rdbal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rdbah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rdlen_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rdh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rdt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rdtr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxdctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxdctl_82575_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_radv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rsrpd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_raid_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_cpuvec_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxcsum_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rfctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tctl_ext_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tipg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tdbal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tdbah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tdlen_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tdh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tdt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tidv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_txdctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_txdctl_82575_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tadv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tarc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ral_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_vfta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mrq_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rssim_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rssir_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_reta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rssrk_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_wuc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_wufc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_wus_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ipav_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ip4at_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ip6at_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_wupl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_wupm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fflt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ffltco_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ffmt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ffvt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_manc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gscl1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gscl2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gscl3_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gscl4_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gscn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_factps_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gioanactl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gioanactlall_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ccmctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_anactl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_scctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_swsm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fwsm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_crcerrs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_algnerrc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_symerrs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rxerrc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mpc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_scc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ecol_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mcc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_latecol_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_colc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_dc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tncrs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_sec_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_cexterr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rlec_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_xonrxc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_xontxc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_xoffrxc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_xofftxc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_fcurc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_prc64_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_prc127_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_prc255_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_prc511_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_prc1023_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_prc1522_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_bprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mcprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gorcl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gorch_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gotcl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_gotch_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rnbc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ruc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rfc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_roc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_rjc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mpdc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_torl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_torh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_totl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_toth_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tpr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tpt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ptc64_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ptc127_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ptc255_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ptc511_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ptc1023_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ptc1522_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_mcptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_bptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tsctc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_tsctfc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_iac_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_icrxptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_icrxatc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ictxptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ictxatc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ictxqec_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_ictxdltc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_icrxdmtc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_icrxoc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e1000_statsregs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device e1000\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __e1000_DEV_H
