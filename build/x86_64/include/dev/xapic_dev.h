#ifndef __xapic_DEV_H
#define __xapic_DEV_H 1
/*
 * DEVICE DEFINITION: Local APIC
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) xapic ## _ ## x
/*
 * Constants defn: xapic.timer_mode (Timer mode)
 *  - no width specified
 */
typedef uint8_t xapic_timer_mode_t;
#define xapic_one_shot ((xapic_timer_mode_t)0x0)
#define xapic_periodic ((xapic_timer_mode_t)0x1)

static inline char *xapic_timer_mode_describe(xapic_timer_mode_t _e) __attribute__ ((always_inline));
static inline char *xapic_timer_mode_describe(xapic_timer_mode_t _e)
{
    switch (_e) {
    case xapic_one_shot:
        return("one_shot: one_shot");
    case xapic_periodic:
        return("periodic: periodic");
    default:
        return(NULL);
    }
}

static inline int xapic_timer_mode_prtval(char *_s, size_t _size, xapic_timer_mode_t _e) __attribute__ ((always_inline));
static inline int xapic_timer_mode_prtval(char *_s, size_t _size, xapic_timer_mode_t _e)
{
    char *d = xapic_timer_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_timer_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.int_mask (Interrupt mask)
 *  - no width specified
 */
typedef uint8_t xapic_int_mask_t;
#define xapic_not_masked ((xapic_int_mask_t)0x0)
#define xapic_masked ((xapic_int_mask_t)0x1)

static inline char *xapic_int_mask_describe(xapic_int_mask_t _e) __attribute__ ((always_inline));
static inline char *xapic_int_mask_describe(xapic_int_mask_t _e)
{
    switch (_e) {
    case xapic_not_masked:
        return("not_masked: Not masked");
    case xapic_masked:
        return("masked: Masked");
    default:
        return(NULL);
    }
}

static inline int xapic_int_mask_prtval(char *_s, size_t _size, xapic_int_mask_t _e) __attribute__ ((always_inline));
static inline int xapic_int_mask_prtval(char *_s, size_t _size, xapic_int_mask_t _e)
{
    char *d = xapic_int_mask_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_int_mask_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.vdm (Vector delivery mode)
 *  - no width specified
 */
typedef uint8_t xapic_vdm_t;
#define xapic_fixed ((xapic_vdm_t)0x0)
#define xapic_lowest ((xapic_vdm_t)0x1)
#define xapic_smi ((xapic_vdm_t)0x2)
#define xapic_nmi ((xapic_vdm_t)0x4)
#define xapic_init ((xapic_vdm_t)0x5)
#define xapic_startup ((xapic_vdm_t)0x6)
#define xapic_extint ((xapic_vdm_t)0x7)

static inline char *xapic_vdm_describe(xapic_vdm_t _e) __attribute__ ((always_inline));
static inline char *xapic_vdm_describe(xapic_vdm_t _e)
{
    switch (_e) {
    case xapic_fixed:
        return("fixed: Fixed");
    case xapic_lowest:
        return("lowest: Lowest priority");
    case xapic_smi:
        return("smi: SMI");
    case xapic_nmi:
        return("nmi: NMI");
    case xapic_init:
        return("init: INIT");
    case xapic_startup:
        return("startup: Start Up");
    case xapic_extint:
        return("extint: ExtINT");
    default:
        return(NULL);
    }
}

static inline int xapic_vdm_prtval(char *_s, size_t _size, xapic_vdm_t _e) __attribute__ ((always_inline));
static inline int xapic_vdm_prtval(char *_s, size_t _size, xapic_vdm_t _e)
{
    char *d = xapic_vdm_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_vdm_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.trigm (Trigger mode)
 *  - no width specified
 */
typedef uint8_t xapic_trigm_t;
#define xapic_edge ((xapic_trigm_t)0x0)
#define xapic_level ((xapic_trigm_t)0x1)

static inline char *xapic_trigm_describe(xapic_trigm_t _e) __attribute__ ((always_inline));
static inline char *xapic_trigm_describe(xapic_trigm_t _e)
{
    switch (_e) {
    case xapic_edge:
        return("edge: Edge");
    case xapic_level:
        return("level: Level");
    default:
        return(NULL);
    }
}

static inline int xapic_trigm_prtval(char *_s, size_t _size, xapic_trigm_t _e) __attribute__ ((always_inline));
static inline int xapic_trigm_prtval(char *_s, size_t _size, xapic_trigm_t _e)
{
    char *d = xapic_trigm_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_trigm_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.divide (Timer Divide values)
 *  - no width specified
 */
typedef uint8_t xapic_divide_t;
#define xapic_by1 ((xapic_divide_t)0xb)
#define xapic_by2 ((xapic_divide_t)0x0)
#define xapic_by4 ((xapic_divide_t)0x1)
#define xapic_by8 ((xapic_divide_t)0x2)
#define xapic_by16 ((xapic_divide_t)0x3)
#define xapic_by32 ((xapic_divide_t)0x8)
#define xapic_by64 ((xapic_divide_t)0x9)
#define xapic_by128 ((xapic_divide_t)0xa)

static inline char *xapic_divide_describe(xapic_divide_t _e) __attribute__ ((always_inline));
static inline char *xapic_divide_describe(xapic_divide_t _e)
{
    switch (_e) {
    case xapic_by1:
        return("by1: by1");
    case xapic_by2:
        return("by2: by2");
    case xapic_by4:
        return("by4: by4");
    case xapic_by8:
        return("by8: by8");
    case xapic_by16:
        return("by16: by16");
    case xapic_by32:
        return("by32: by32");
    case xapic_by64:
        return("by64: by64");
    case xapic_by128:
        return("by128: by128");
    default:
        return(NULL);
    }
}

static inline int xapic_divide_prtval(char *_s, size_t _size, xapic_divide_t _e) __attribute__ ((always_inline));
static inline int xapic_divide_prtval(char *_s, size_t _size, xapic_divide_t _e)
{
    char *d = xapic_divide_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_divide_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.dst_shorthand (Destination shorthand)
 *  - no width specified
 */
typedef uint8_t xapic_dst_shorthand_t;
#define xapic_none ((xapic_dst_shorthand_t)0x0)
#define xapic_self ((xapic_dst_shorthand_t)0x1)
#define xapic_all_inc ((xapic_dst_shorthand_t)0x2)
#define xapic_all_exc ((xapic_dst_shorthand_t)0x3)

static inline char *xapic_dst_shorthand_describe(xapic_dst_shorthand_t _e) __attribute__ ((always_inline));
static inline char *xapic_dst_shorthand_describe(xapic_dst_shorthand_t _e)
{
    switch (_e) {
    case xapic_none:
        return("none: No shorthand");
    case xapic_self:
        return("self: Self");
    case xapic_all_inc:
        return("all_inc: All including self");
    case xapic_all_exc:
        return("all_exc: All excluding self");
    default:
        return(NULL);
    }
}

static inline int xapic_dst_shorthand_prtval(char *_s, size_t _size, xapic_dst_shorthand_t _e) __attribute__ ((always_inline));
static inline int xapic_dst_shorthand_prtval(char *_s, size_t _size, xapic_dst_shorthand_t _e)
{
    char *d = xapic_dst_shorthand_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_dst_shorthand_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.dst_mode (Destination mode)
 *  - no width specified
 */
typedef uint8_t xapic_dst_mode_t;
#define xapic_dst_phys ((xapic_dst_mode_t)0x0)
#define xapic_dst_log ((xapic_dst_mode_t)0x1)

static inline char *xapic_dst_mode_describe(xapic_dst_mode_t _e) __attribute__ ((always_inline));
static inline char *xapic_dst_mode_describe(xapic_dst_mode_t _e)
{
    switch (_e) {
    case xapic_dst_phys:
        return("dst_phys: Physical");
    case xapic_dst_log:
        return("dst_log: Logical");
    default:
        return(NULL);
    }
}

static inline int xapic_dst_mode_prtval(char *_s, size_t _size, xapic_dst_mode_t _e) __attribute__ ((always_inline));
static inline int xapic_dst_mode_prtval(char *_s, size_t _size, xapic_dst_mode_t _e)
{
    char *d = xapic_dst_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_dst_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.int_level (Interrupt level)
 *  - no width specified
 */
typedef uint8_t xapic_int_level_t;
#define xapic_lvl_clr ((xapic_int_level_t)0x0)
#define xapic_lvl_set ((xapic_int_level_t)0x1)

static inline char *xapic_int_level_describe(xapic_int_level_t _e) __attribute__ ((always_inline));
static inline char *xapic_int_level_describe(xapic_int_level_t _e)
{
    switch (_e) {
    case xapic_lvl_clr:
        return("lvl_clr: Clear");
    case xapic_lvl_set:
        return("lvl_set: Set");
    default:
        return(NULL);
    }
}

static inline int xapic_int_level_prtval(char *_s, size_t _size, xapic_int_level_t _e) __attribute__ ((always_inline));
static inline int xapic_int_level_prtval(char *_s, size_t _size, xapic_int_level_t _e)
{
    char *d = xapic_int_level_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_int_level_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: xapic.model_type (Destination model type)
 *  - no width specified
 */
typedef uint8_t xapic_model_type_t;
#define xapic_flat ((xapic_model_type_t)0xf)
#define xapic_cluster ((xapic_model_type_t)0x0)

static inline char *xapic_model_type_describe(xapic_model_type_t _e) __attribute__ ((always_inline));
static inline char *xapic_model_type_describe(xapic_model_type_t _e)
{
    switch (_e) {
    case xapic_flat:
        return("flat: flat");
    case xapic_cluster:
        return("cluster: cluster");
    default:
        return(NULL);
    }
}

static inline int xapic_model_type_prtval(char *_s, size_t _size, xapic_model_type_t _e) __attribute__ ((always_inline));
static inline int xapic_model_type_prtval(char *_s, size_t _size, xapic_model_type_t _e)
{
    char *d = xapic_model_type_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "xapic_model_type_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: xapic_id_t
 * Description: Implicit type of Local APIC ID register
 * Fields:
 *   _anon0	(size 24, offset 0, init 0):	RSVD	_
 *   id	(size 8, offset 24, init 0):	RW	apic id
 */
typedef uint32_t xapic_id_t;
#define xapic_id_default 0x0
static inline uint8_t xapic_id_id_extract(xapic_id_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_id_id_extract(xapic_id_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline xapic_id_t xapic_id_id_insert(xapic_id_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_id_t xapic_id_id_insert(xapic_id_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((xapic_id_t )(_fieldval)) << 24)));
}

static inline int xapic_id_prtval(char *_s, size_t _size, xapic_id_t _regval) __attribute__ ((always_inline));
static inline int xapic_id_prtval(char *_s, size_t _size, xapic_id_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx8 "\t(apic id)\n", xapic_id_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_version_t
 * Description: Implicit type of Local APIC Version register
 * Fields:
 *   ver	(size 8, offset 0, init 0):	RO	version
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 *   max_lvt	(size 8, offset 16, init 0):	RO	max LVT entry
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t xapic_version_t;
#define xapic_version_default 0x0
static inline uint8_t xapic_version_ver_extract(xapic_version_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_version_ver_extract(xapic_version_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_version_t xapic_version_ver_insert(xapic_version_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_version_t xapic_version_ver_insert(xapic_version_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_version_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_version_max_lvt_extract(xapic_version_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_version_max_lvt_extract(xapic_version_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline xapic_version_t xapic_version_max_lvt_insert(xapic_version_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_version_t xapic_version_max_lvt_insert(xapic_version_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((xapic_version_t )(_fieldval)) << 16)));
}

static inline int xapic_version_prtval(char *_s, size_t _size, xapic_version_t _regval) __attribute__ ((always_inline));
static inline int xapic_version_prtval(char *_s, size_t _size, xapic_version_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ver =\t%" PRIx8 "\t(version)\n", xapic_version_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_lvt =\t%" PRIx8 "\t(max LVT entry)\n", xapic_version_max_lvt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_lvt_timer_t
 * Description: Implicit type of LVT Timer register
 * Fields:
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   _anon8	(size 4, offset 8, init 0):	RSVD	_
 *   status	(size 1, offset 12, init 0):	RW	Delivery status
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   mask	(size 1, offset 16, init 0):	RW	Masked
 *   mode	(size 1, offset 17, init 0):	RW	Mode
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
typedef uint32_t xapic_lvt_timer_t;
#define xapic_lvt_timer_default 0x0
static inline uint8_t xapic_lvt_timer_vector_extract(xapic_lvt_timer_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_timer_vector_extract(xapic_lvt_timer_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_lvt_timer_t xapic_lvt_timer_vector_insert(xapic_lvt_timer_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_timer_t xapic_lvt_timer_vector_insert(xapic_lvt_timer_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_lvt_timer_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_lvt_timer_status_extract(xapic_lvt_timer_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_timer_status_extract(xapic_lvt_timer_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline xapic_lvt_timer_t xapic_lvt_timer_status_insert(xapic_lvt_timer_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_timer_t xapic_lvt_timer_status_insert(xapic_lvt_timer_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((xapic_lvt_timer_t )(_fieldval)) << 12)));
}

static inline xapic_int_mask_t xapic_lvt_timer_mask_extract(xapic_lvt_timer_t _regval) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_timer_mask_extract(xapic_lvt_timer_t _regval)
{
    return((xapic_int_mask_t )((_regval & 0x10000) >> 16));
}

static inline xapic_lvt_timer_t xapic_lvt_timer_mask_insert(xapic_lvt_timer_t _regval, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_timer_t xapic_lvt_timer_mask_insert(xapic_lvt_timer_t _regval, xapic_int_mask_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((xapic_lvt_timer_t )(_fieldval)) << 16)));
}

static inline xapic_timer_mode_t xapic_lvt_timer_mode_extract(xapic_lvt_timer_t _regval) __attribute__ ((always_inline));
static inline xapic_timer_mode_t xapic_lvt_timer_mode_extract(xapic_lvt_timer_t _regval)
{
    return((xapic_timer_mode_t )((_regval & 0x20000) >> 17));
}

static inline xapic_lvt_timer_t xapic_lvt_timer_mode_insert(xapic_lvt_timer_t _regval, xapic_timer_mode_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_timer_t xapic_lvt_timer_mode_insert(xapic_lvt_timer_t _regval, xapic_timer_mode_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((xapic_lvt_timer_t )(_fieldval)) << 17)));
}

static inline int xapic_lvt_timer_prtval(char *_s, size_t _size, xapic_lvt_timer_t _regval) __attribute__ ((always_inline));
static inline int xapic_lvt_timer_prtval(char *_s, size_t _size, xapic_lvt_timer_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_timer_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_timer_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_timer_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Masked)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_timer_mode_prtval(_s + _r, _avail, xapic_lvt_timer_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_lvt_lint_t
 * Description: LVT Int
 * Fields:
 *   vector	(size 8, offset 0, init 0):	NOATTR	Vector
 *   dlv_mode	(size 4, offset 8, init 0):	NOATTR	Delivery mode
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   status	(size 1, offset 13, init 0):	NOATTR	Delivery status
 *   pinpol	(size 1, offset 14, init 0):	NOATTR	Pin polarity
 *   rirr	(size 1, offset 15, init 0):	NOATTR	Remote IRR
 *   trig_mode	(size 1, offset 16, init 0):	NOATTR	Trigger mode
 *   mask	(size 1, offset 17, init 0):	NOATTR	Mask
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
typedef uint32_t xapic_lvt_lint_t;
#define xapic_lvt_lint_default 0x0
static inline uint8_t xapic_lvt_lint_vector_extract(xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint_vector_extract(xapic_lvt_lint_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_lvt_lint_t xapic_lvt_lint_vector_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint_vector_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_lvt_lint_t )(_fieldval)) << 0)));
}

static inline xapic_vdm_t xapic_lvt_lint_dlv_mode_extract(xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline xapic_vdm_t xapic_lvt_lint_dlv_mode_extract(xapic_lvt_lint_t _regval)
{
    return((xapic_vdm_t )((_regval & 0xf00) >> 8));
}

static inline xapic_lvt_lint_t xapic_lvt_lint_dlv_mode_insert(xapic_lvt_lint_t _regval, xapic_vdm_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint_dlv_mode_insert(xapic_lvt_lint_t _regval, xapic_vdm_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((xapic_lvt_lint_t )(_fieldval)) << 8)));
}

static inline uint8_t xapic_lvt_lint_status_extract(xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint_status_extract(xapic_lvt_lint_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline xapic_lvt_lint_t xapic_lvt_lint_status_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint_status_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((xapic_lvt_lint_t )(_fieldval)) << 13)));
}

static inline uint8_t xapic_lvt_lint_pinpol_extract(xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint_pinpol_extract(xapic_lvt_lint_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline xapic_lvt_lint_t xapic_lvt_lint_pinpol_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint_pinpol_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((xapic_lvt_lint_t )(_fieldval)) << 14)));
}

static inline uint8_t xapic_lvt_lint_rirr_extract(xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint_rirr_extract(xapic_lvt_lint_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline xapic_lvt_lint_t xapic_lvt_lint_rirr_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint_rirr_insert(xapic_lvt_lint_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((xapic_lvt_lint_t )(_fieldval)) << 15)));
}

static inline xapic_trigm_t xapic_lvt_lint_trig_mode_extract(xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline xapic_trigm_t xapic_lvt_lint_trig_mode_extract(xapic_lvt_lint_t _regval)
{
    return((xapic_trigm_t )((_regval & 0x10000) >> 16));
}

static inline xapic_lvt_lint_t xapic_lvt_lint_trig_mode_insert(xapic_lvt_lint_t _regval, xapic_trigm_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint_trig_mode_insert(xapic_lvt_lint_t _regval, xapic_trigm_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((xapic_lvt_lint_t )(_fieldval)) << 16)));
}

static inline xapic_int_mask_t xapic_lvt_lint_mask_extract(xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_lint_mask_extract(xapic_lvt_lint_t _regval)
{
    return((xapic_int_mask_t )((_regval & 0x20000) >> 17));
}

static inline xapic_lvt_lint_t xapic_lvt_lint_mask_insert(xapic_lvt_lint_t _regval, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint_mask_insert(xapic_lvt_lint_t _regval, xapic_int_mask_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((xapic_lvt_lint_t )(_fieldval)) << 17)));
}

static inline int xapic_lvt_lint_prtval(char *_s, size_t _size, xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline int xapic_lvt_lint_prtval(char *_s, size_t _size, xapic_lvt_lint_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_lint_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_vdm_prtval(_s + _r, _avail, xapic_lvt_lint_dlv_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Delivery mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_lint_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pinpol =\t%" PRIx8 "\t(Pin polarity)\n", xapic_lvt_lint_pinpol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rirr =\t%" PRIx8 "\t(Remote IRR)\n", xapic_lvt_lint_rirr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " trig_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_trigm_prtval(_s + _r, _avail, xapic_lvt_lint_trig_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Trigger mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_lint_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mask)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_lvt_err_t
 * Description: Implicit type of lvt_err register
 * Fields:
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   _anon8	(size 4, offset 8, init 0):	RSVD	_
 *   status	(size 1, offset 12, init 0):	RW	Delivery status
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   mask	(size 1, offset 16, init 0):	RW	Mask
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
typedef uint32_t xapic_lvt_err_t;
#define xapic_lvt_err_default 0x0
static inline uint8_t xapic_lvt_err_vector_extract(xapic_lvt_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_err_vector_extract(xapic_lvt_err_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_lvt_err_t xapic_lvt_err_vector_insert(xapic_lvt_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_err_t xapic_lvt_err_vector_insert(xapic_lvt_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_lvt_err_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_lvt_err_status_extract(xapic_lvt_err_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_err_status_extract(xapic_lvt_err_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline xapic_lvt_err_t xapic_lvt_err_status_insert(xapic_lvt_err_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_err_t xapic_lvt_err_status_insert(xapic_lvt_err_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((xapic_lvt_err_t )(_fieldval)) << 12)));
}

static inline xapic_int_mask_t xapic_lvt_err_mask_extract(xapic_lvt_err_t _regval) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_err_mask_extract(xapic_lvt_err_t _regval)
{
    return((xapic_int_mask_t )((_regval & 0x10000) >> 16));
}

static inline xapic_lvt_err_t xapic_lvt_err_mask_insert(xapic_lvt_err_t _regval, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_err_t xapic_lvt_err_mask_insert(xapic_lvt_err_t _regval, xapic_int_mask_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((xapic_lvt_err_t )(_fieldval)) << 16)));
}

static inline int xapic_lvt_err_prtval(char *_s, size_t _size, xapic_lvt_err_t _regval) __attribute__ ((always_inline));
static inline int xapic_lvt_err_prtval(char *_s, size_t _size, xapic_lvt_err_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_err_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_err_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_err_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mask)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_lvt_mon_t
 * Description: LVT monitor
 * Fields:
 *   vector	(size 8, offset 0, init 0):	NOATTR	Vector
 *   msgType	(size 3, offset 8, init 0):	NOATTR	msgType
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   status	(size 1, offset 12, init 0):	NOATTR	Delivery status
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   mask	(size 1, offset 16, init 0):	NOATTR	Masked
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
typedef uint32_t xapic_lvt_mon_t;
#define xapic_lvt_mon_default 0x0
static inline uint8_t xapic_lvt_mon_vector_extract(xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_mon_vector_extract(xapic_lvt_mon_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_lvt_mon_t xapic_lvt_mon_vector_insert(xapic_lvt_mon_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_mon_vector_insert(xapic_lvt_mon_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_lvt_mon_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_lvt_mon_msgType_extract(xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_mon_msgType_extract(xapic_lvt_mon_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline xapic_lvt_mon_t xapic_lvt_mon_msgType_insert(xapic_lvt_mon_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_mon_msgType_insert(xapic_lvt_mon_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((xapic_lvt_mon_t )(_fieldval)) << 8)));
}

static inline uint8_t xapic_lvt_mon_status_extract(xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_mon_status_extract(xapic_lvt_mon_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline xapic_lvt_mon_t xapic_lvt_mon_status_insert(xapic_lvt_mon_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_mon_status_insert(xapic_lvt_mon_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((xapic_lvt_mon_t )(_fieldval)) << 12)));
}

static inline xapic_int_mask_t xapic_lvt_mon_mask_extract(xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_mon_mask_extract(xapic_lvt_mon_t _regval)
{
    return((xapic_int_mask_t )((_regval & 0x10000) >> 16));
}

static inline xapic_lvt_mon_t xapic_lvt_mon_mask_insert(xapic_lvt_mon_t _regval, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_mon_mask_insert(xapic_lvt_mon_t _regval, xapic_int_mask_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((xapic_lvt_mon_t )(_fieldval)) << 16)));
}

static inline int xapic_lvt_mon_prtval(char *_s, size_t _size, xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline int xapic_lvt_mon_prtval(char *_s, size_t _size, xapic_lvt_mon_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_mon_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msgType =\t%" PRIx8 "\t(msgType)\n", xapic_lvt_mon_msgType_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_mon_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_mon_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Masked)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_esr_t
 * Description: Implicit type of Error Status register
 * Fields:
 *   sce	(size 1, offset 0, init 0):	RW	Send checksum error
 *   rce	(size 1, offset 1, init 0):	RW	Receive checksum error
 *   sae	(size 1, offset 2, init 0):	RW	Send accept error
 *   rae	(size 1, offset 3, init 0):	RW	Receive accept error
 *   _anon4	(size 1, offset 4, init 0):	RSVD	_
 *   siv	(size 1, offset 5, init 0):	RW	Send illegal vector
 *   riv	(size 1, offset 6, init 0):	RW	Receive illegal vector
 *   ira	(size 1, offset 7, init 0):	RW	Illegal register address
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t xapic_esr_t;
#define xapic_esr_default 0x0
static inline uint8_t xapic_esr_sce_extract(xapic_esr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_sce_extract(xapic_esr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline xapic_esr_t xapic_esr_sce_insert(xapic_esr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_sce_insert(xapic_esr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xapic_esr_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_esr_rce_extract(xapic_esr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_rce_extract(xapic_esr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline xapic_esr_t xapic_esr_rce_insert(xapic_esr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_rce_insert(xapic_esr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((xapic_esr_t )(_fieldval)) << 1)));
}

static inline uint8_t xapic_esr_sae_extract(xapic_esr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_sae_extract(xapic_esr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline xapic_esr_t xapic_esr_sae_insert(xapic_esr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_sae_insert(xapic_esr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((xapic_esr_t )(_fieldval)) << 2)));
}

static inline uint8_t xapic_esr_rae_extract(xapic_esr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_rae_extract(xapic_esr_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline xapic_esr_t xapic_esr_rae_insert(xapic_esr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_rae_insert(xapic_esr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((xapic_esr_t )(_fieldval)) << 3)));
}

static inline uint8_t xapic_esr_siv_extract(xapic_esr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_siv_extract(xapic_esr_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline xapic_esr_t xapic_esr_siv_insert(xapic_esr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_siv_insert(xapic_esr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((xapic_esr_t )(_fieldval)) << 5)));
}

static inline uint8_t xapic_esr_riv_extract(xapic_esr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_riv_extract(xapic_esr_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline xapic_esr_t xapic_esr_riv_insert(xapic_esr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_riv_insert(xapic_esr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((xapic_esr_t )(_fieldval)) << 6)));
}

static inline uint8_t xapic_esr_ira_extract(xapic_esr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_ira_extract(xapic_esr_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline xapic_esr_t xapic_esr_ira_insert(xapic_esr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_ira_insert(xapic_esr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((xapic_esr_t )(_fieldval)) << 7)));
}

static inline int xapic_esr_prtval(char *_s, size_t _size, xapic_esr_t _regval) __attribute__ ((always_inline));
static inline int xapic_esr_prtval(char *_s, size_t _size, xapic_esr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sce =\t%" PRIx8 "\t(Send checksum error)\n", xapic_esr_sce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rce =\t%" PRIx8 "\t(Receive checksum error)\n", xapic_esr_rce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sae =\t%" PRIx8 "\t(Send accept error)\n", xapic_esr_sae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rae =\t%" PRIx8 "\t(Receive accept error)\n", xapic_esr_rae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " siv =\t%" PRIx8 "\t(Send illegal vector)\n", xapic_esr_siv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " riv =\t%" PRIx8 "\t(Receive illegal vector)\n", xapic_esr_riv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ira =\t%" PRIx8 "\t(Illegal register address)\n", xapic_esr_ira_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_dcr_t
 * Description: Implicit type of Divide Configuration register
 * Fields:
 *   div_val	(size 4, offset 0, init 0):	RW	Timer divide value
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t xapic_dcr_t;
#define xapic_dcr_default 0x0
static inline uint8_t xapic_dcr_div_val_extract(xapic_dcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_dcr_div_val_extract(xapic_dcr_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline xapic_dcr_t xapic_dcr_div_val_insert(xapic_dcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_dcr_t xapic_dcr_div_val_insert(xapic_dcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((xapic_dcr_t )(_fieldval)) << 0)));
}

static inline int xapic_dcr_prtval(char *_s, size_t _size, xapic_dcr_t _regval) __attribute__ ((always_inline));
static inline int xapic_dcr_prtval(char *_s, size_t _size, xapic_dcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " div_val =\t%" PRIx8 "\t(Timer divide value)\n", xapic_dcr_div_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_icr_lo_t
 * Description: Implicit type of Interrupt Command (lo) register
 * Fields:
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   dlv_mode	(size 3, offset 8, init 0):	RW	Delivery mode
 *   dst_mode	(size 1, offset 11, init 0):	RW	Destination mode
 *   dlv_stat	(size 1, offset 12, init 0):	RO	Delivery status
 *   _anon13	(size 1, offset 13, init 0):	RSVD	_
 *   level	(size 1, offset 14, init 0):	RW	Level
 *   trig_mode	(size 1, offset 15, init 0):	RW	Trigger mode
 *   _anon16	(size 2, offset 16, init 0):	RSVD	_
 *   dst_short	(size 2, offset 18, init 0):	RW	Destination shorthand
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t xapic_icr_lo_t;
#define xapic_icr_lo_default 0x0
static inline uint8_t xapic_icr_lo_vector_extract(xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_icr_lo_vector_extract(xapic_icr_lo_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_icr_lo_t xapic_icr_lo_vector_insert(xapic_icr_lo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_vector_insert(xapic_icr_lo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_icr_lo_t )(_fieldval)) << 0)));
}

static inline xapic_vdm_t xapic_icr_lo_dlv_mode_extract(xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xapic_vdm_t xapic_icr_lo_dlv_mode_extract(xapic_icr_lo_t _regval)
{
    return((xapic_vdm_t )((_regval & 0x700) >> 8));
}

static inline xapic_icr_lo_t xapic_icr_lo_dlv_mode_insert(xapic_icr_lo_t _regval, xapic_vdm_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_dlv_mode_insert(xapic_icr_lo_t _regval, xapic_vdm_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((xapic_icr_lo_t )(_fieldval)) << 8)));
}

static inline xapic_dst_mode_t xapic_icr_lo_dst_mode_extract(xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xapic_dst_mode_t xapic_icr_lo_dst_mode_extract(xapic_icr_lo_t _regval)
{
    return((xapic_dst_mode_t )((_regval & 0x800) >> 11));
}

static inline xapic_icr_lo_t xapic_icr_lo_dst_mode_insert(xapic_icr_lo_t _regval, xapic_dst_mode_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_dst_mode_insert(xapic_icr_lo_t _regval, xapic_dst_mode_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((xapic_icr_lo_t )(_fieldval)) << 11)));
}

static inline uint8_t xapic_icr_lo_dlv_stat_extract(xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_icr_lo_dlv_stat_extract(xapic_icr_lo_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline xapic_icr_lo_t xapic_icr_lo_dlv_stat_insert(xapic_icr_lo_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_dlv_stat_insert(xapic_icr_lo_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((xapic_icr_lo_t )(_fieldval)) << 12)));
}

static inline xapic_int_level_t xapic_icr_lo_level_extract(xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xapic_int_level_t xapic_icr_lo_level_extract(xapic_icr_lo_t _regval)
{
    return((xapic_int_level_t )((_regval & 0x4000) >> 14));
}

static inline xapic_icr_lo_t xapic_icr_lo_level_insert(xapic_icr_lo_t _regval, xapic_int_level_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_level_insert(xapic_icr_lo_t _regval, xapic_int_level_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((xapic_icr_lo_t )(_fieldval)) << 14)));
}

static inline xapic_trigm_t xapic_icr_lo_trig_mode_extract(xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xapic_trigm_t xapic_icr_lo_trig_mode_extract(xapic_icr_lo_t _regval)
{
    return((xapic_trigm_t )((_regval & 0x8000) >> 15));
}

static inline xapic_icr_lo_t xapic_icr_lo_trig_mode_insert(xapic_icr_lo_t _regval, xapic_trigm_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_trig_mode_insert(xapic_icr_lo_t _regval, xapic_trigm_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((xapic_icr_lo_t )(_fieldval)) << 15)));
}

static inline xapic_dst_shorthand_t xapic_icr_lo_dst_short_extract(xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline xapic_dst_shorthand_t xapic_icr_lo_dst_short_extract(xapic_icr_lo_t _regval)
{
    return((xapic_dst_shorthand_t )((_regval & 0xc0000) >> 18));
}

static inline xapic_icr_lo_t xapic_icr_lo_dst_short_insert(xapic_icr_lo_t _regval, xapic_dst_shorthand_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_dst_short_insert(xapic_icr_lo_t _regval, xapic_dst_shorthand_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((xapic_icr_lo_t )(_fieldval)) << 18)));
}

static inline int xapic_icr_lo_prtval(char *_s, size_t _size, xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline int xapic_icr_lo_prtval(char *_s, size_t _size, xapic_icr_lo_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_icr_lo_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_vdm_prtval(_s + _r, _avail, xapic_icr_lo_dlv_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Delivery mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_dst_mode_prtval(_s + _r, _avail, xapic_icr_lo_dst_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_stat =\t%" PRIx8 "\t(Delivery status)\n", xapic_icr_lo_dlv_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " level =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_level_prtval(_s + _r, _avail, xapic_icr_lo_level_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " trig_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_trigm_prtval(_s + _r, _avail, xapic_icr_lo_trig_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Trigger mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_short =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_dst_shorthand_prtval(_s + _r, _avail, xapic_icr_lo_dst_short_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination shorthand)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_icr_hi_t
 * Description: Implicit type of Interrupt Commmand (hi) register
 * Fields:
 *   _anon0	(size 24, offset 0, init 0):	RSVD	_
 *   dest	(size 8, offset 24, init 0):	RW	Destination field
 */
typedef uint32_t xapic_icr_hi_t;
#define xapic_icr_hi_default 0x0
static inline uint8_t xapic_icr_hi_dest_extract(xapic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_icr_hi_dest_extract(xapic_icr_hi_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline xapic_icr_hi_t xapic_icr_hi_dest_insert(xapic_icr_hi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_icr_hi_t xapic_icr_hi_dest_insert(xapic_icr_hi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((xapic_icr_hi_t )(_fieldval)) << 24)));
}

static inline int xapic_icr_hi_prtval(char *_s, size_t _size, xapic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline int xapic_icr_hi_prtval(char *_s, size_t _size, xapic_icr_hi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dest =\t%" PRIx8 "\t(Destination field)\n", xapic_icr_hi_dest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_ldr_t
 * Description: Implicit type of Logical Destination register
 * Fields:
 *   _anon0	(size 24, offset 0, init 0):	RSVD	_
 *   log_id	(size 8, offset 24, init 0):	RW	Logical APIC ID
 */
typedef uint32_t xapic_ldr_t;
#define xapic_ldr_default 0x0
static inline uint8_t xapic_ldr_log_id_extract(xapic_ldr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_ldr_log_id_extract(xapic_ldr_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline xapic_ldr_t xapic_ldr_log_id_insert(xapic_ldr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_ldr_t xapic_ldr_log_id_insert(xapic_ldr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((xapic_ldr_t )(_fieldval)) << 24)));
}

static inline int xapic_ldr_prtval(char *_s, size_t _size, xapic_ldr_t _regval) __attribute__ ((always_inline));
static inline int xapic_ldr_prtval(char *_s, size_t _size, xapic_ldr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " log_id =\t%" PRIx8 "\t(Logical APIC ID)\n", xapic_ldr_log_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_dfr_t
 * Description: Implicit type of Destination Format register
 * Fields:
 *   _anon0	(size 28, offset 0, init fffffff):	MB1	_
 *   model	(size 4, offset 28, init 0):	RW	Model
 */
typedef uint32_t xapic_dfr_t;
#define xapic_dfr_default 0xfffffff
static inline xapic_model_type_t xapic_dfr_model_extract(xapic_dfr_t _regval) __attribute__ ((always_inline));
static inline xapic_model_type_t xapic_dfr_model_extract(xapic_dfr_t _regval)
{
    return((xapic_model_type_t )((_regval & 0xf0000000) >> 28));
}

static inline xapic_dfr_t xapic_dfr_model_insert(xapic_dfr_t _regval, xapic_model_type_t _fieldval) __attribute__ ((always_inline));
static inline xapic_dfr_t xapic_dfr_model_insert(xapic_dfr_t _regval, xapic_model_type_t _fieldval)
{
    return((_regval & 0xfffffff) | (0xf0000000 & (((xapic_dfr_t )(_fieldval)) << 28)));
}

static inline int xapic_dfr_prtval(char *_s, size_t _size, xapic_dfr_t _regval) __attribute__ ((always_inline));
static inline int xapic_dfr_prtval(char *_s, size_t _size, xapic_dfr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " model =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_model_type_prtval(_s + _r, _avail, xapic_dfr_model_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Model)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_priority_t
 * Description: Various priorities
 * Fields:
 *   sub_class	(size 4, offset 0, init 0):	NOATTR	Priority subclass
 *   priority	(size 4, offset 4, init 0):	NOATTR	Priority
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t xapic_priority_t;
#define xapic_priority_default 0x0
static inline uint8_t xapic_priority_sub_class_extract(xapic_priority_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_priority_sub_class_extract(xapic_priority_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline xapic_priority_t xapic_priority_sub_class_insert(xapic_priority_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_priority_sub_class_insert(xapic_priority_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((xapic_priority_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_priority_priority_extract(xapic_priority_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_priority_priority_extract(xapic_priority_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline xapic_priority_t xapic_priority_priority_insert(xapic_priority_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_priority_priority_insert(xapic_priority_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((xapic_priority_t )(_fieldval)) << 4)));
}

static inline int xapic_priority_prtval(char *_s, size_t _size, xapic_priority_t _regval) __attribute__ ((always_inline));
static inline int xapic_priority_prtval(char *_s, size_t _size, xapic_priority_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sub_class =\t%" PRIx8 "\t(Priority subclass)\n", xapic_priority_sub_class_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority)\n", xapic_priority_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_svr_t
 * Description: Implicit type of Spurious Interrupt Vector Register register
 * Fields:
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   enable	(size 1, offset 8, init 0):	RW	APIC Software Enable/Disable
 *   focus	(size 1, offset 9, init 0):	RW	Focus Processor Checking
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
typedef uint32_t xapic_svr_t;
#define xapic_svr_default 0x0
static inline uint8_t xapic_svr_vector_extract(xapic_svr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_svr_vector_extract(xapic_svr_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_svr_t xapic_svr_vector_insert(xapic_svr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_svr_t xapic_svr_vector_insert(xapic_svr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_svr_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_svr_enable_extract(xapic_svr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_svr_enable_extract(xapic_svr_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline xapic_svr_t xapic_svr_enable_insert(xapic_svr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_svr_t xapic_svr_enable_insert(xapic_svr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((xapic_svr_t )(_fieldval)) << 8)));
}

static inline uint8_t xapic_svr_focus_extract(xapic_svr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_svr_focus_extract(xapic_svr_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline xapic_svr_t xapic_svr_focus_insert(xapic_svr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_svr_t xapic_svr_focus_insert(xapic_svr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((xapic_svr_t )(_fieldval)) << 9)));
}

static inline int xapic_svr_prtval(char *_s, size_t _size, xapic_svr_t _regval) __attribute__ ((always_inline));
static inline int xapic_svr_prtval(char *_s, size_t _size, xapic_svr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_svr_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(APIC Software Enable/Disable)\n", xapic_svr_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " focus =\t%" PRIx8 "\t(Focus Processor Checking)\n", xapic_svr_focus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_eafr_t
 * Description: Implicit type of Extended APIC feature register
 * Fields:
 *   inc	(size 1, offset 0, init 0):	RO	Interrupt enable register capable
 *   snic	(size 1, offset 1, init 0):	RO	Specific EOI capable
 *   xaidc	(size 1, offset 2, init 0):	RO	Extended APIC ID capability
 *   _anon3	(size 13, offset 3, init 0):	MBZ	_
 *   xlc	(size 8, offset 16, init 0):	RO	Extended LVT count
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
typedef uint32_t xapic_eafr_t;
#define xapic_eafr_default 0x0
static inline uint8_t xapic_eafr_inc_extract(xapic_eafr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_inc_extract(xapic_eafr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline xapic_eafr_t xapic_eafr_inc_insert(xapic_eafr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_eafr_t xapic_eafr_inc_insert(xapic_eafr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xapic_eafr_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_eafr_snic_extract(xapic_eafr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_snic_extract(xapic_eafr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline xapic_eafr_t xapic_eafr_snic_insert(xapic_eafr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_eafr_t xapic_eafr_snic_insert(xapic_eafr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((xapic_eafr_t )(_fieldval)) << 1)));
}

static inline uint8_t xapic_eafr_xaidc_extract(xapic_eafr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_xaidc_extract(xapic_eafr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline xapic_eafr_t xapic_eafr_xaidc_insert(xapic_eafr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_eafr_t xapic_eafr_xaidc_insert(xapic_eafr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((xapic_eafr_t )(_fieldval)) << 2)));
}

static inline uint8_t xapic_eafr_xlc_extract(xapic_eafr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_xlc_extract(xapic_eafr_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline xapic_eafr_t xapic_eafr_xlc_insert(xapic_eafr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_eafr_t xapic_eafr_xlc_insert(xapic_eafr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((xapic_eafr_t )(_fieldval)) << 16)));
}

static inline int xapic_eafr_prtval(char *_s, size_t _size, xapic_eafr_t _regval) __attribute__ ((always_inline));
static inline int xapic_eafr_prtval(char *_s, size_t _size, xapic_eafr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " inc =\t%" PRIx8 "\t(Interrupt enable register capable)\n", xapic_eafr_inc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " snic =\t%" PRIx8 "\t(Specific EOI capable)\n", xapic_eafr_snic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xaidc =\t%" PRIx8 "\t(Extended APIC ID capability)\n", xapic_eafr_xaidc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xlc =\t%" PRIx8 "\t(Extended LVT count)\n", xapic_eafr_xlc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_eacr_t
 * Description: Implicit type of Extended APIC control register
 * Fields:
 *   iern	(size 1, offset 0, init 0):	RW	Enable interrupt enable registers
 *   sn	(size 1, offset 1, init 0):	RW	Enable SEOI generation
 *   xaidn	(size 1, offset 2, init 0):	RW	Extended APIC ID enable
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t xapic_eacr_t;
#define xapic_eacr_default 0x0
static inline uint8_t xapic_eacr_iern_extract(xapic_eacr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_eacr_iern_extract(xapic_eacr_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline xapic_eacr_t xapic_eacr_iern_insert(xapic_eacr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_eacr_t xapic_eacr_iern_insert(xapic_eacr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((xapic_eacr_t )(_fieldval)) << 0)));
}

static inline uint8_t xapic_eacr_sn_extract(xapic_eacr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_eacr_sn_extract(xapic_eacr_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline xapic_eacr_t xapic_eacr_sn_insert(xapic_eacr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_eacr_t xapic_eacr_sn_insert(xapic_eacr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((xapic_eacr_t )(_fieldval)) << 1)));
}

static inline uint8_t xapic_eacr_xaidn_extract(xapic_eacr_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_eacr_xaidn_extract(xapic_eacr_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline xapic_eacr_t xapic_eacr_xaidn_insert(xapic_eacr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_eacr_t xapic_eacr_xaidn_insert(xapic_eacr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((xapic_eacr_t )(_fieldval)) << 2)));
}

static inline int xapic_eacr_prtval(char *_s, size_t _size, xapic_eacr_t _regval) __attribute__ ((always_inline));
static inline int xapic_eacr_prtval(char *_s, size_t _size, xapic_eacr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iern =\t%" PRIx8 "\t(Enable interrupt enable registers)\n", xapic_eacr_iern_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sn =\t%" PRIx8 "\t(Enable SEOI generation)\n", xapic_eacr_sn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xaidn =\t%" PRIx8 "\t(Extended APIC ID enable)\n", xapic_eacr_xaidn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: xapic_seoi_t
 * Description: Implicit type of Specific end-of-interrupt register
 * Fields:
 *   vector	(size 8, offset 0, init 0):	WO	Vector
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
typedef uint32_t xapic_seoi_t;
#define xapic_seoi_default 0x0
static inline uint8_t xapic_seoi_vector_extract(xapic_seoi_t _regval) __attribute__ ((always_inline));
static inline uint8_t xapic_seoi_vector_extract(xapic_seoi_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline xapic_seoi_t xapic_seoi_vector_insert(xapic_seoi_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline xapic_seoi_t xapic_seoi_vector_insert(xapic_seoi_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((xapic_seoi_t )(_fieldval)) << 0)));
}

static inline int xapic_seoi_prtval(char *_s, size_t _size, xapic_seoi_t _regval) __attribute__ ((always_inline));
static inline int xapic_seoi_prtval(char *_s, size_t _size, xapic_seoi_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_seoi_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    uint32_t eoi_shadow;
    xapic_seoi_t seoi_shadow;
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum xapic_initials {
    xapic_id_initial = 0x0,
    xapic_version_initial = 0x0,
    xapic_lvt_timer_initial = 0x0,
    xapic_lvt_lint0_initial = 0x0,
    xapic_lvt_lint1_initial = 0x0,
    xapic_lvt_err_initial = 0x0,
    xapic_lvt_perf_cnt_initial = 0x0,
    xapic_lvt_thermal_initial = 0x0,
    xapic_esr_initial = 0x0,
    xapic_dcr_initial = 0x0,
    xapic_init_count_initial = 0x0,
    xapic_cur_count_initial = 0x0,
    xapic_icr_lo_initial = 0x0,
    xapic_icr_hi_initial = 0x0,
    xapic_ldr_initial = 0x0,
    xapic_dfr_initial = 0x0,
    xapic_apr_initial = 0x0,
    xapic_tpr_initial = 0x0,
    xapic_ppr_initial = 0x0,
    xapic_isr_initial = 0x0,
    xapic_tmr_initial = 0x0,
    xapic_irr_initial = 0x0,
    xapic_eoi_initial = 0x0,
    xapic_svr_initial = 0x0,
    xapic_eafr_initial = 0x0,
    xapic_eacr_initial = 0x0,
    xapic_seoi_initial = 0x0,
    xapic_ier_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void xapic_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void xapic_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register id: Local APIC ID
 * Type: xapic.id (Implicit type of Local APIC ID register)
 *   _anon0	(size 24, offset 0, init 0):	RSVD	_
 *   id	(size 8, offset 24, init 0):	RW	apic id
 */
static inline xapic_id_t xapic_id_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_id_t xapic_id_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline xapic_id_t xapic_id_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_id_t xapic_id_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void xapic_id_rawwr(__DN(t) *_dev, xapic_id_t _regval) __attribute__ ((always_inline));
static inline void xapic_id_rawwr(__DN(t) *_dev, xapic_id_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void xapic_id_wr(__DN(t) *_dev, xapic_id_t _regval) __attribute__ ((always_inline));
static inline void xapic_id_wr(__DN(t) *_dev, xapic_id_t _regval)
{
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int xapic_id_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_id_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_id_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register id (Local APIC ID): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " id =\t%" PRIx8 "\t(apic id)\n", xapic_id_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t xapic_id_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_id_id_rdf(__DN(t) *_dev)
{
    xapic_id_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(xapic_id_id_extract(_regval));
}

static inline void xapic_id_id_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_id_id_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_id_t _regval = 0xff000000 & (((xapic_id_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register version: Local APIC Version
 * Type: xapic.version (Implicit type of Local APIC Version register)
 *   ver	(size 8, offset 0, init 0):	RO	version
 *   _anon8	(size 8, offset 8, init 0):	RSVD	_
 *   max_lvt	(size 8, offset 16, init 0):	RO	max LVT entry
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline xapic_version_t xapic_version_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_version_t xapic_version_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline xapic_version_t xapic_version_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_version_t xapic_version_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x30));
}

static inline void xapic_version_rawwr(__DN(t) *_dev, xapic_version_t _regval) __attribute__ ((always_inline));
static inline void xapic_version_rawwr(__DN(t) *_dev, xapic_version_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x30, _regval);
}

// Register version is not writeable
static inline int xapic_version_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_version_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_version_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register version (Local APIC Version): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ver =\t%" PRIx8 "\t(version)\n", xapic_version_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_lvt =\t%" PRIx8 "\t(max LVT entry)\n", xapic_version_max_lvt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t xapic_version_ver_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_version_ver_rdf(__DN(t) *_dev)
{
    xapic_version_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(xapic_version_ver_extract(_regval));
}

static inline uint8_t xapic_version_max_lvt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_version_max_lvt_rdf(__DN(t) *_dev)
{
    xapic_version_t _regval = mackerel_read_addr_32(_dev->base, 0x30);
    return(xapic_version_max_lvt_extract(_regval));
}

/*
 * Register lvt_timer: LVT Timer
 * Type: xapic.lvt_timer (Implicit type of LVT Timer register)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   _anon8	(size 4, offset 8, init 0):	RSVD	_
 *   status	(size 1, offset 12, init 0):	RW	Delivery status
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   mask	(size 1, offset 16, init 0):	RW	Masked
 *   mode	(size 1, offset 17, init 0):	RW	Mode
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
static inline xapic_lvt_timer_t xapic_lvt_timer_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_timer_t xapic_lvt_timer_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x320));
}

static inline xapic_lvt_timer_t xapic_lvt_timer_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_timer_t xapic_lvt_timer_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x320));
}

static inline void xapic_lvt_timer_rawwr(__DN(t) *_dev, xapic_lvt_timer_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_timer_rawwr(__DN(t) *_dev, xapic_lvt_timer_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
}

static inline void xapic_lvt_timer_wr(__DN(t) *_dev, xapic_lvt_timer_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_timer_wr(__DN(t) *_dev, xapic_lvt_timer_t _regval)
{
    _regval = (_regval & 0x310ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffcef00 & mackerel_read_addr_32(_dev->base, 0x320)));
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
}

static inline int xapic_lvt_timer_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_lvt_timer_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_lvt_timer_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lvt_timer (LVT Timer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_timer_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_timer_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_timer_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Masked)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_timer_mode_prtval(_s + _r, _avail, xapic_lvt_timer_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline uint8_t xapic_lvt_timer_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_timer_vector_rdf(__DN(t) *_dev)
{
    xapic_lvt_timer_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(xapic_lvt_timer_vector_extract(_regval));
}

static inline uint8_t xapic_lvt_timer_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_timer_status_rdf(__DN(t) *_dev)
{
    xapic_lvt_timer_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(xapic_lvt_timer_status_extract(_regval));
}

static inline xapic_int_mask_t xapic_lvt_timer_mask_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_timer_mask_rdf(__DN(t) *_dev)
{
    xapic_lvt_timer_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(xapic_lvt_timer_mask_extract(_regval));
}

static inline xapic_timer_mode_t xapic_lvt_timer_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_timer_mode_t xapic_lvt_timer_mode_rdf(__DN(t) *_dev)
{
    xapic_lvt_timer_t _regval = mackerel_read_addr_32(_dev->base, 0x320);
    return(xapic_lvt_timer_mode_extract(_regval));
}

static inline void xapic_lvt_timer_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_timer_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_timer_t _regval = 0xff & (((xapic_lvt_timer_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_timer_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_timer_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_timer_t _regval = 0x1000 & (((xapic_lvt_timer_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_timer_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_timer_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval)
{
    xapic_lvt_timer_t _regval = 0x10000 & (((xapic_lvt_timer_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_timer_mode_wrf(__DN(t) *_dev, xapic_timer_mode_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_timer_mode_wrf(__DN(t) *_dev, xapic_timer_mode_t _fieldval)
{
    xapic_lvt_timer_t _regval = 0x20000 & (((xapic_lvt_timer_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x320)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x320, _regval);
    // No shadow register to write to
}

/*
 * Register lvt_lint0: lvt_lint0
 * Type: xapic.lvt_lint (LVT Int)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   dlv_mode	(size 4, offset 8, init 0):	RW	Delivery mode
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   status	(size 1, offset 13, init 0):	RW	Delivery status
 *   pinpol	(size 1, offset 14, init 0):	RW	Pin polarity
 *   rirr	(size 1, offset 15, init 0):	RW	Remote IRR
 *   trig_mode	(size 1, offset 16, init 0):	RW	Trigger mode
 *   mask	(size 1, offset 17, init 0):	RW	Mask
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
static inline xapic_lvt_lint_t xapic_lvt_lint0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x350));
}

static inline xapic_lvt_lint_t xapic_lvt_lint0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x350));
}

static inline void xapic_lvt_lint0_rawwr(__DN(t) *_dev, xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_rawwr(__DN(t) *_dev, xapic_lvt_lint_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
}

static inline void xapic_lvt_lint0_wr(__DN(t) *_dev, xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_wr(__DN(t) *_dev, xapic_lvt_lint_t _regval)
{
    _regval = (_regval & 0x3efff);
    // No MB1 fields present
    _regval = (_regval | (0xfffc1000 & mackerel_read_addr_32(_dev->base, 0x350)));
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
}

static inline int xapic_lvt_lint0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_lvt_lint0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lvt_lint0 (lvt_lint0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_lint_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_vdm_prtval(_s + _r, _avail, xapic_lvt_lint_dlv_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Delivery mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_lint_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pinpol =\t%" PRIx8 "\t(Pin polarity)\n", xapic_lvt_lint_pinpol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rirr =\t%" PRIx8 "\t(Remote IRR)\n", xapic_lvt_lint_rirr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " trig_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_trigm_prtval(_s + _r, _avail, xapic_lvt_lint_trig_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Trigger mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_lint_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mask)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline uint8_t xapic_lvt_lint0_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint0_vector_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    return(xapic_lvt_lint_vector_extract(_regval));
}

static inline xapic_vdm_t xapic_lvt_lint0_dlv_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_vdm_t xapic_lvt_lint0_dlv_mode_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    return(xapic_lvt_lint_dlv_mode_extract(_regval));
}

static inline uint8_t xapic_lvt_lint0_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint0_status_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    return(xapic_lvt_lint_status_extract(_regval));
}

static inline uint8_t xapic_lvt_lint0_pinpol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint0_pinpol_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    return(xapic_lvt_lint_pinpol_extract(_regval));
}

static inline uint8_t xapic_lvt_lint0_rirr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint0_rirr_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    return(xapic_lvt_lint_rirr_extract(_regval));
}

static inline xapic_trigm_t xapic_lvt_lint0_trig_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_trigm_t xapic_lvt_lint0_trig_mode_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    return(xapic_lvt_lint_trig_mode_extract(_regval));
}

static inline xapic_int_mask_t xapic_lvt_lint0_mask_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_lint0_mask_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x350);
    return(xapic_lvt_lint_mask_extract(_regval));
}

static inline void xapic_lvt_lint0_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0xff & (((xapic_lvt_lint_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x350)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint0_dlv_mode_wrf(__DN(t) *_dev, xapic_vdm_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_dlv_mode_wrf(__DN(t) *_dev, xapic_vdm_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0xf00 & (((xapic_lvt_lint_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff0ff & mackerel_read_addr_32(_dev->base, 0x350)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint0_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x2000 & (((xapic_lvt_lint_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x350)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint0_pinpol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_pinpol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x4000 & (((xapic_lvt_lint_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x350)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint0_rirr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_rirr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x8000 & (((xapic_lvt_lint_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x350)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint0_trig_mode_wrf(__DN(t) *_dev, xapic_trigm_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_trig_mode_wrf(__DN(t) *_dev, xapic_trigm_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x10000 & (((xapic_lvt_lint_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x350)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint0_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint0_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x20000 & (((xapic_lvt_lint_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x350)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x350, _regval);
    // No shadow register to write to
}

/*
 * Register lvt_lint1: lvt_lint1
 * Type: xapic.lvt_lint (LVT Int)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   dlv_mode	(size 4, offset 8, init 0):	RW	Delivery mode
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   status	(size 1, offset 13, init 0):	RW	Delivery status
 *   pinpol	(size 1, offset 14, init 0):	RW	Pin polarity
 *   rirr	(size 1, offset 15, init 0):	RW	Remote IRR
 *   trig_mode	(size 1, offset 16, init 0):	RW	Trigger mode
 *   mask	(size 1, offset 17, init 0):	RW	Mask
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
static inline xapic_lvt_lint_t xapic_lvt_lint1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x360));
}

static inline xapic_lvt_lint_t xapic_lvt_lint1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_lint_t xapic_lvt_lint1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x360));
}

static inline void xapic_lvt_lint1_rawwr(__DN(t) *_dev, xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_rawwr(__DN(t) *_dev, xapic_lvt_lint_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
}

static inline void xapic_lvt_lint1_wr(__DN(t) *_dev, xapic_lvt_lint_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_wr(__DN(t) *_dev, xapic_lvt_lint_t _regval)
{
    _regval = (_regval & 0x3efff);
    // No MB1 fields present
    _regval = (_regval | (0xfffc1000 & mackerel_read_addr_32(_dev->base, 0x360)));
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
}

static inline int xapic_lvt_lint1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_lvt_lint1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lvt_lint1 (lvt_lint1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_lint_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_vdm_prtval(_s + _r, _avail, xapic_lvt_lint_dlv_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Delivery mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_lint_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pinpol =\t%" PRIx8 "\t(Pin polarity)\n", xapic_lvt_lint_pinpol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rirr =\t%" PRIx8 "\t(Remote IRR)\n", xapic_lvt_lint_rirr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " trig_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_trigm_prtval(_s + _r, _avail, xapic_lvt_lint_trig_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Trigger mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_lint_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mask)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline uint8_t xapic_lvt_lint1_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint1_vector_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    return(xapic_lvt_lint_vector_extract(_regval));
}

static inline xapic_vdm_t xapic_lvt_lint1_dlv_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_vdm_t xapic_lvt_lint1_dlv_mode_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    return(xapic_lvt_lint_dlv_mode_extract(_regval));
}

static inline uint8_t xapic_lvt_lint1_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint1_status_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    return(xapic_lvt_lint_status_extract(_regval));
}

static inline uint8_t xapic_lvt_lint1_pinpol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint1_pinpol_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    return(xapic_lvt_lint_pinpol_extract(_regval));
}

static inline uint8_t xapic_lvt_lint1_rirr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_lint1_rirr_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    return(xapic_lvt_lint_rirr_extract(_regval));
}

static inline xapic_trigm_t xapic_lvt_lint1_trig_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_trigm_t xapic_lvt_lint1_trig_mode_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    return(xapic_lvt_lint_trig_mode_extract(_regval));
}

static inline xapic_int_mask_t xapic_lvt_lint1_mask_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_lint1_mask_rdf(__DN(t) *_dev)
{
    xapic_lvt_lint_t _regval = mackerel_read_addr_32(_dev->base, 0x360);
    return(xapic_lvt_lint_mask_extract(_regval));
}

static inline void xapic_lvt_lint1_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0xff & (((xapic_lvt_lint_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x360)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint1_dlv_mode_wrf(__DN(t) *_dev, xapic_vdm_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_dlv_mode_wrf(__DN(t) *_dev, xapic_vdm_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0xf00 & (((xapic_lvt_lint_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff0ff & mackerel_read_addr_32(_dev->base, 0x360)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint1_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x2000 & (((xapic_lvt_lint_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x360)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint1_pinpol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_pinpol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x4000 & (((xapic_lvt_lint_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x360)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint1_rirr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_rirr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x8000 & (((xapic_lvt_lint_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x360)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint1_trig_mode_wrf(__DN(t) *_dev, xapic_trigm_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_trig_mode_wrf(__DN(t) *_dev, xapic_trigm_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x10000 & (((xapic_lvt_lint_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x360)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_lint1_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_lint1_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval)
{
    xapic_lvt_lint_t _regval = 0x20000 & (((xapic_lvt_lint_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x360)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x360, _regval);
    // No shadow register to write to
}

/*
 * Register lvt_err: lvt_err
 * Type: xapic.lvt_err (Implicit type of lvt_err register)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   _anon8	(size 4, offset 8, init 0):	RSVD	_
 *   status	(size 1, offset 12, init 0):	RW	Delivery status
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   mask	(size 1, offset 16, init 0):	RW	Mask
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
static inline xapic_lvt_err_t xapic_lvt_err_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_err_t xapic_lvt_err_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x370));
}

static inline xapic_lvt_err_t xapic_lvt_err_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_err_t xapic_lvt_err_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x370));
}

static inline void xapic_lvt_err_rawwr(__DN(t) *_dev, xapic_lvt_err_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_err_rawwr(__DN(t) *_dev, xapic_lvt_err_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x370, _regval);
}

static inline void xapic_lvt_err_wr(__DN(t) *_dev, xapic_lvt_err_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_err_wr(__DN(t) *_dev, xapic_lvt_err_t _regval)
{
    _regval = (_regval & 0x110ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffeef00 & mackerel_read_addr_32(_dev->base, 0x370)));
    mackerel_write_addr_32(_dev->base, 0x370, _regval);
}

static inline int xapic_lvt_err_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_lvt_err_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_lvt_err_t _regval = mackerel_read_addr_32(_dev->base, 0x370);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lvt_err (lvt_err): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_err_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_err_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_err_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Mask)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint8_t xapic_lvt_err_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_err_vector_rdf(__DN(t) *_dev)
{
    xapic_lvt_err_t _regval = mackerel_read_addr_32(_dev->base, 0x370);
    return(xapic_lvt_err_vector_extract(_regval));
}

static inline uint8_t xapic_lvt_err_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_err_status_rdf(__DN(t) *_dev)
{
    xapic_lvt_err_t _regval = mackerel_read_addr_32(_dev->base, 0x370);
    return(xapic_lvt_err_status_extract(_regval));
}

static inline xapic_int_mask_t xapic_lvt_err_mask_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_err_mask_rdf(__DN(t) *_dev)
{
    xapic_lvt_err_t _regval = mackerel_read_addr_32(_dev->base, 0x370);
    return(xapic_lvt_err_mask_extract(_regval));
}

static inline void xapic_lvt_err_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_err_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_err_t _regval = 0xff & (((xapic_lvt_err_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x370)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x370, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_err_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_err_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_err_t _regval = 0x1000 & (((xapic_lvt_err_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x370)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x370, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_err_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_err_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval)
{
    xapic_lvt_err_t _regval = 0x10000 & (((xapic_lvt_err_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x370)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x370, _regval);
    // No shadow register to write to
}

/*
 * Register lvt_perf_cnt: lvt_perf_cnt
 * Type: xapic.lvt_mon (LVT monitor)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   msgType	(size 3, offset 8, init 0):	RW	msgType
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   status	(size 1, offset 12, init 0):	RW	Delivery status
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   mask	(size 1, offset 16, init 0):	RW	Masked
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
static inline xapic_lvt_mon_t xapic_lvt_perf_cnt_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_perf_cnt_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x340));
}

static inline xapic_lvt_mon_t xapic_lvt_perf_cnt_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_perf_cnt_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x340));
}

static inline void xapic_lvt_perf_cnt_rawwr(__DN(t) *_dev, xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_perf_cnt_rawwr(__DN(t) *_dev, xapic_lvt_mon_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
}

static inline void xapic_lvt_perf_cnt_wr(__DN(t) *_dev, xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_perf_cnt_wr(__DN(t) *_dev, xapic_lvt_mon_t _regval)
{
    _regval = (_regval & 0x117ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffee800 & mackerel_read_addr_32(_dev->base, 0x340)));
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
}

static inline int xapic_lvt_perf_cnt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_lvt_perf_cnt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x340);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lvt_perf_cnt (lvt_perf_cnt): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_mon_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msgType =\t%" PRIx8 "\t(msgType)\n", xapic_lvt_mon_msgType_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_mon_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_mon_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Masked)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint8_t xapic_lvt_perf_cnt_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_perf_cnt_vector_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x340);
    return(xapic_lvt_mon_vector_extract(_regval));
}

static inline uint8_t xapic_lvt_perf_cnt_msgType_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_perf_cnt_msgType_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x340);
    return(xapic_lvt_mon_msgType_extract(_regval));
}

static inline uint8_t xapic_lvt_perf_cnt_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_perf_cnt_status_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x340);
    return(xapic_lvt_mon_status_extract(_regval));
}

static inline xapic_int_mask_t xapic_lvt_perf_cnt_mask_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_perf_cnt_mask_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x340);
    return(xapic_lvt_mon_mask_extract(_regval));
}

static inline void xapic_lvt_perf_cnt_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_perf_cnt_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0xff & (((xapic_lvt_mon_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x340)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_perf_cnt_msgType_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_perf_cnt_msgType_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0x700 & (((xapic_lvt_mon_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff8ff & mackerel_read_addr_32(_dev->base, 0x340)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_perf_cnt_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_perf_cnt_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0x1000 & (((xapic_lvt_mon_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x340)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_perf_cnt_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_perf_cnt_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0x10000 & (((xapic_lvt_mon_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x340)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x340, _regval);
    // No shadow register to write to
}

/*
 * Register lvt_thermal: lvt_thermal
 * Type: xapic.lvt_mon (LVT monitor)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   msgType	(size 3, offset 8, init 0):	RW	msgType
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   status	(size 1, offset 12, init 0):	RW	Delivery status
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   mask	(size 1, offset 16, init 0):	RW	Masked
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
static inline xapic_lvt_mon_t xapic_lvt_thermal_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_thermal_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x330));
}

static inline xapic_lvt_mon_t xapic_lvt_thermal_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_lvt_mon_t xapic_lvt_thermal_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x330));
}

static inline void xapic_lvt_thermal_rawwr(__DN(t) *_dev, xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_thermal_rawwr(__DN(t) *_dev, xapic_lvt_mon_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
}

static inline void xapic_lvt_thermal_wr(__DN(t) *_dev, xapic_lvt_mon_t _regval) __attribute__ ((always_inline));
static inline void xapic_lvt_thermal_wr(__DN(t) *_dev, xapic_lvt_mon_t _regval)
{
    _regval = (_regval & 0x117ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffee800 & mackerel_read_addr_32(_dev->base, 0x330)));
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
}

static inline int xapic_lvt_thermal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_lvt_thermal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x330);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register lvt_thermal (lvt_thermal): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_lvt_mon_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msgType =\t%" PRIx8 "\t(msgType)\n", xapic_lvt_mon_msgType_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " status =\t%" PRIx8 "\t(Delivery status)\n", xapic_lvt_mon_status_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mask =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_mask_prtval(_s + _r, _avail, xapic_lvt_mon_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Masked)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint8_t xapic_lvt_thermal_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_thermal_vector_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x330);
    return(xapic_lvt_mon_vector_extract(_regval));
}

static inline uint8_t xapic_lvt_thermal_msgType_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_thermal_msgType_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x330);
    return(xapic_lvt_mon_msgType_extract(_regval));
}

static inline uint8_t xapic_lvt_thermal_status_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_lvt_thermal_status_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x330);
    return(xapic_lvt_mon_status_extract(_regval));
}

static inline xapic_int_mask_t xapic_lvt_thermal_mask_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_int_mask_t xapic_lvt_thermal_mask_rdf(__DN(t) *_dev)
{
    xapic_lvt_mon_t _regval = mackerel_read_addr_32(_dev->base, 0x330);
    return(xapic_lvt_mon_mask_extract(_regval));
}

static inline void xapic_lvt_thermal_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_thermal_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0xff & (((xapic_lvt_mon_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x330)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_thermal_msgType_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_thermal_msgType_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0x700 & (((xapic_lvt_mon_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff8ff & mackerel_read_addr_32(_dev->base, 0x330)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_thermal_status_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_thermal_status_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0x1000 & (((xapic_lvt_mon_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x330)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
    // No shadow register to write to
}

static inline void xapic_lvt_thermal_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_lvt_thermal_mask_wrf(__DN(t) *_dev, xapic_int_mask_t _fieldval)
{
    xapic_lvt_mon_t _regval = 0x10000 & (((xapic_lvt_mon_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x330)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x330, _regval);
    // No shadow register to write to
}

/*
 * Register esr: Error Status
 * Type: xapic.esr (Implicit type of Error Status register)
 *   sce	(size 1, offset 0, init 0):	RW	Send checksum error
 *   rce	(size 1, offset 1, init 0):	RW	Receive checksum error
 *   sae	(size 1, offset 2, init 0):	RW	Send accept error
 *   rae	(size 1, offset 3, init 0):	RW	Receive accept error
 *   _anon4	(size 1, offset 4, init 0):	RSVD	_
 *   siv	(size 1, offset 5, init 0):	RW	Send illegal vector
 *   riv	(size 1, offset 6, init 0):	RW	Receive illegal vector
 *   ira	(size 1, offset 7, init 0):	RW	Illegal register address
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline xapic_esr_t xapic_esr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x280));
}

static inline xapic_esr_t xapic_esr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_esr_t xapic_esr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x280));
}

static inline void xapic_esr_rawwr(__DN(t) *_dev, xapic_esr_t _regval) __attribute__ ((always_inline));
static inline void xapic_esr_rawwr(__DN(t) *_dev, xapic_esr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
}

static inline void xapic_esr_wr(__DN(t) *_dev, xapic_esr_t _regval) __attribute__ ((always_inline));
static inline void xapic_esr_wr(__DN(t) *_dev, xapic_esr_t _regval)
{
    _regval = (_regval & 0xef);
    // No MB1 fields present
    _regval = (_regval | (0xffffff10 & mackerel_read_addr_32(_dev->base, 0x280)));
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
}

static inline int xapic_esr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_esr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register esr (Error Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sce =\t%" PRIx8 "\t(Send checksum error)\n", xapic_esr_sce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rce =\t%" PRIx8 "\t(Receive checksum error)\n", xapic_esr_rce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sae =\t%" PRIx8 "\t(Send accept error)\n", xapic_esr_sae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rae =\t%" PRIx8 "\t(Receive accept error)\n", xapic_esr_rae_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " siv =\t%" PRIx8 "\t(Send illegal vector)\n", xapic_esr_siv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " riv =\t%" PRIx8 "\t(Receive illegal vector)\n", xapic_esr_riv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ira =\t%" PRIx8 "\t(Illegal register address)\n", xapic_esr_ira_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t xapic_esr_sce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_sce_rdf(__DN(t) *_dev)
{
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    return(xapic_esr_sce_extract(_regval));
}

static inline uint8_t xapic_esr_rce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_rce_rdf(__DN(t) *_dev)
{
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    return(xapic_esr_rce_extract(_regval));
}

static inline uint8_t xapic_esr_sae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_sae_rdf(__DN(t) *_dev)
{
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    return(xapic_esr_sae_extract(_regval));
}

static inline uint8_t xapic_esr_rae_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_rae_rdf(__DN(t) *_dev)
{
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    return(xapic_esr_rae_extract(_regval));
}

static inline uint8_t xapic_esr_siv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_siv_rdf(__DN(t) *_dev)
{
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    return(xapic_esr_siv_extract(_regval));
}

static inline uint8_t xapic_esr_riv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_riv_rdf(__DN(t) *_dev)
{
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    return(xapic_esr_riv_extract(_regval));
}

static inline uint8_t xapic_esr_ira_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_esr_ira_rdf(__DN(t) *_dev)
{
    xapic_esr_t _regval = mackerel_read_addr_32(_dev->base, 0x280);
    return(xapic_esr_ira_extract(_regval));
}

static inline void xapic_esr_sce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_esr_sce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_esr_t _regval = 0x1 & (((xapic_esr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
    // No shadow register to write to
}

static inline void xapic_esr_rce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_esr_rce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_esr_t _regval = 0x2 & (((xapic_esr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
    // No shadow register to write to
}

static inline void xapic_esr_sae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_esr_sae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_esr_t _regval = 0x4 & (((xapic_esr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
    // No shadow register to write to
}

static inline void xapic_esr_rae_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_esr_rae_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_esr_t _regval = 0x8 & (((xapic_esr_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
    // No shadow register to write to
}

static inline void xapic_esr_siv_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_esr_siv_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_esr_t _regval = 0x20 & (((xapic_esr_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
    // No shadow register to write to
}

static inline void xapic_esr_riv_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_esr_riv_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_esr_t _regval = 0x40 & (((xapic_esr_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
    // No shadow register to write to
}

static inline void xapic_esr_ira_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_esr_ira_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_esr_t _regval = 0x80 & (((xapic_esr_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x280)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x280, _regval);
    // No shadow register to write to
}

/*
 * Register dcr: Divide Configuration
 * Type: xapic.dcr (Implicit type of Divide Configuration register)
 *   div_val	(size 4, offset 0, init 0):	RW	Timer divide value
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static inline xapic_dcr_t xapic_dcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_dcr_t xapic_dcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e0));
}

static inline xapic_dcr_t xapic_dcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_dcr_t xapic_dcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3e0));
}

static inline void xapic_dcr_rawwr(__DN(t) *_dev, xapic_dcr_t _regval) __attribute__ ((always_inline));
static inline void xapic_dcr_rawwr(__DN(t) *_dev, xapic_dcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3e0, _regval);
}

static inline void xapic_dcr_wr(__DN(t) *_dev, xapic_dcr_t _regval) __attribute__ ((always_inline));
static inline void xapic_dcr_wr(__DN(t) *_dev, xapic_dcr_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x3e0)));
    mackerel_write_addr_32(_dev->base, 0x3e0, _regval);
}

static inline int xapic_dcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_dcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0x3e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dcr (Divide Configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " div_val =\t%" PRIx8 "\t(Timer divide value)\n", xapic_dcr_div_val_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t xapic_dcr_div_val_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_dcr_div_val_rdf(__DN(t) *_dev)
{
    xapic_dcr_t _regval = mackerel_read_addr_32(_dev->base, 0x3e0);
    return(xapic_dcr_div_val_extract(_regval));
}

static inline void xapic_dcr_div_val_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_dcr_div_val_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_dcr_t _regval = 0xf & (((xapic_dcr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x3e0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3e0, _regval);
    // No shadow register to write to
}

/*
 * Register init_count: Initial Count
 * Type: xapic.uint32 (primitive type)
 */
static inline uint32_t xapic_init_count_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xapic_init_count_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x380));
}

static inline uint32_t xapic_init_count_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xapic_init_count_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x380));
}

static inline void xapic_init_count_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_init_count_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x380, _regval);
}

static inline void xapic_init_count_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_init_count_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x380, _regval);
}

static inline int xapic_init_count_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_init_count_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x380);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register init_count (Initial Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register cur_count: Current Count
 * Type: xapic.uint32 (primitive type)
 */
static inline uint32_t xapic_cur_count_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xapic_cur_count_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x390));
}

static inline uint32_t xapic_cur_count_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xapic_cur_count_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x390));
}

static inline void xapic_cur_count_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_cur_count_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x390, _regval);
}

static inline void xapic_cur_count_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_cur_count_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x390, _regval);
}

static inline int xapic_cur_count_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_cur_count_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x390);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register cur_count (Current Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register icr_lo: Interrupt Command (lo)
 * Type: xapic.icr_lo (Implicit type of Interrupt Command (lo) register)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   dlv_mode	(size 3, offset 8, init 0):	RW	Delivery mode
 *   dst_mode	(size 1, offset 11, init 0):	RW	Destination mode
 *   dlv_stat	(size 1, offset 12, init 0):	RO	Delivery status
 *   _anon13	(size 1, offset 13, init 0):	RSVD	_
 *   level	(size 1, offset 14, init 0):	RW	Level
 *   trig_mode	(size 1, offset 15, init 0):	RW	Trigger mode
 *   _anon16	(size 2, offset 16, init 0):	RSVD	_
 *   dst_short	(size 2, offset 18, init 0):	RW	Destination shorthand
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline xapic_icr_lo_t xapic_icr_lo_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x300));
}

static inline xapic_icr_lo_t xapic_icr_lo_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_icr_lo_t xapic_icr_lo_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x300));
}

static inline void xapic_icr_lo_rawwr(__DN(t) *_dev, xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_rawwr(__DN(t) *_dev, xapic_icr_lo_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
}

static inline void xapic_icr_lo_wr(__DN(t) *_dev, xapic_icr_lo_t _regval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_wr(__DN(t) *_dev, xapic_icr_lo_t _regval)
{
    _regval = (_regval & 0xcdfff);
    // No MB1 fields present
    _regval = (_regval | (0xfff32000 & mackerel_read_addr_32(_dev->base, 0x300)));
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
}

static inline int xapic_icr_lo_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_icr_lo_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register icr_lo (Interrupt Command (lo)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_icr_lo_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_vdm_prtval(_s + _r, _avail, xapic_icr_lo_dlv_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Delivery mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_dst_mode_prtval(_s + _r, _avail, xapic_icr_lo_dst_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dlv_stat =\t%" PRIx8 "\t(Delivery status)\n", xapic_icr_lo_dlv_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " level =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_int_level_prtval(_s + _r, _avail, xapic_icr_lo_level_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Level)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " trig_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_trigm_prtval(_s + _r, _avail, xapic_icr_lo_trig_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Trigger mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_short =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_dst_shorthand_prtval(_s + _r, _avail, xapic_icr_lo_dst_short_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Destination shorthand)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t xapic_icr_lo_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_icr_lo_vector_rdf(__DN(t) *_dev)
{
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(xapic_icr_lo_vector_extract(_regval));
}

static inline xapic_vdm_t xapic_icr_lo_dlv_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_vdm_t xapic_icr_lo_dlv_mode_rdf(__DN(t) *_dev)
{
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(xapic_icr_lo_dlv_mode_extract(_regval));
}

static inline xapic_dst_mode_t xapic_icr_lo_dst_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_dst_mode_t xapic_icr_lo_dst_mode_rdf(__DN(t) *_dev)
{
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(xapic_icr_lo_dst_mode_extract(_regval));
}

static inline uint8_t xapic_icr_lo_dlv_stat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_icr_lo_dlv_stat_rdf(__DN(t) *_dev)
{
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(xapic_icr_lo_dlv_stat_extract(_regval));
}

static inline xapic_int_level_t xapic_icr_lo_level_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_int_level_t xapic_icr_lo_level_rdf(__DN(t) *_dev)
{
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(xapic_icr_lo_level_extract(_regval));
}

static inline xapic_trigm_t xapic_icr_lo_trig_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_trigm_t xapic_icr_lo_trig_mode_rdf(__DN(t) *_dev)
{
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(xapic_icr_lo_trig_mode_extract(_regval));
}

static inline xapic_dst_shorthand_t xapic_icr_lo_dst_short_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_dst_shorthand_t xapic_icr_lo_dst_short_rdf(__DN(t) *_dev)
{
    xapic_icr_lo_t _regval = mackerel_read_addr_32(_dev->base, 0x300);
    return(xapic_icr_lo_dst_short_extract(_regval));
}

static inline void xapic_icr_lo_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_icr_lo_t _regval = 0xff & (((xapic_icr_lo_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffef00 & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void xapic_icr_lo_dlv_mode_wrf(__DN(t) *_dev, xapic_vdm_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_dlv_mode_wrf(__DN(t) *_dev, xapic_vdm_t _fieldval)
{
    xapic_icr_lo_t _regval = 0x700 & (((xapic_icr_lo_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffffe8ff & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void xapic_icr_lo_dst_mode_wrf(__DN(t) *_dev, xapic_dst_mode_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_dst_mode_wrf(__DN(t) *_dev, xapic_dst_mode_t _fieldval)
{
    xapic_icr_lo_t _regval = 0x800 & (((xapic_icr_lo_t )(_fieldval)) << 11);
    _regval = (_regval | (0xffffe7ff & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void xapic_icr_lo_level_wrf(__DN(t) *_dev, xapic_int_level_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_level_wrf(__DN(t) *_dev, xapic_int_level_t _fieldval)
{
    xapic_icr_lo_t _regval = 0x4000 & (((xapic_icr_lo_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffafff & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void xapic_icr_lo_trig_mode_wrf(__DN(t) *_dev, xapic_trigm_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_trig_mode_wrf(__DN(t) *_dev, xapic_trigm_t _fieldval)
{
    xapic_icr_lo_t _regval = 0x8000 & (((xapic_icr_lo_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff6fff & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

static inline void xapic_icr_lo_dst_short_wrf(__DN(t) *_dev, xapic_dst_shorthand_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_icr_lo_dst_short_wrf(__DN(t) *_dev, xapic_dst_shorthand_t _fieldval)
{
    xapic_icr_lo_t _regval = 0xc0000 & (((xapic_icr_lo_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff3efff & mackerel_read_addr_32(_dev->base, 0x300)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x300, _regval);
    // No shadow register to write to
}

/*
 * Register icr_hi: Interrupt Commmand (hi)
 * Type: xapic.icr_hi (Implicit type of Interrupt Commmand (hi) register)
 *   _anon0	(size 24, offset 0, init 0):	RSVD	_
 *   dest	(size 8, offset 24, init 0):	RW	Destination field
 */
static inline xapic_icr_hi_t xapic_icr_hi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_icr_hi_t xapic_icr_hi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x310));
}

static inline xapic_icr_hi_t xapic_icr_hi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_icr_hi_t xapic_icr_hi_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x310));
}

static inline void xapic_icr_hi_rawwr(__DN(t) *_dev, xapic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline void xapic_icr_hi_rawwr(__DN(t) *_dev, xapic_icr_hi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
}

static inline void xapic_icr_hi_wr(__DN(t) *_dev, xapic_icr_hi_t _regval) __attribute__ ((always_inline));
static inline void xapic_icr_hi_wr(__DN(t) *_dev, xapic_icr_hi_t _regval)
{
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x310)));
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
}

static inline int xapic_icr_hi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_icr_hi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_icr_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register icr_hi (Interrupt Commmand (hi)): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dest =\t%" PRIx8 "\t(Destination field)\n", xapic_icr_hi_dest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t xapic_icr_hi_dest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_icr_hi_dest_rdf(__DN(t) *_dev)
{
    xapic_icr_hi_t _regval = mackerel_read_addr_32(_dev->base, 0x310);
    return(xapic_icr_hi_dest_extract(_regval));
}

static inline void xapic_icr_hi_dest_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_icr_hi_dest_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_icr_hi_t _regval = 0xff000000 & (((xapic_icr_hi_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x310)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x310, _regval);
    // No shadow register to write to
}

/*
 * Register ldr: Logical Destination
 * Type: xapic.ldr (Implicit type of Logical Destination register)
 *   _anon0	(size 24, offset 0, init 0):	RSVD	_
 *   log_id	(size 8, offset 24, init 0):	RW	Logical APIC ID
 */
static inline xapic_ldr_t xapic_ldr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_ldr_t xapic_ldr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline xapic_ldr_t xapic_ldr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_ldr_t xapic_ldr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xd0));
}

static inline void xapic_ldr_rawwr(__DN(t) *_dev, xapic_ldr_t _regval) __attribute__ ((always_inline));
static inline void xapic_ldr_rawwr(__DN(t) *_dev, xapic_ldr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
}

static inline void xapic_ldr_wr(__DN(t) *_dev, xapic_ldr_t _regval) __attribute__ ((always_inline));
static inline void xapic_ldr_wr(__DN(t) *_dev, xapic_ldr_t _regval)
{
    _regval = (_regval & 0xff000000);
    // No MB1 fields present
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
}

static inline int xapic_ldr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_ldr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_ldr_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ldr (Logical Destination): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " log_id =\t%" PRIx8 "\t(Logical APIC ID)\n", xapic_ldr_log_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t xapic_ldr_log_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_ldr_log_id_rdf(__DN(t) *_dev)
{
    xapic_ldr_t _regval = mackerel_read_addr_32(_dev->base, 0xd0);
    return(xapic_ldr_log_id_extract(_regval));
}

static inline void xapic_ldr_log_id_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_ldr_log_id_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_ldr_t _regval = 0xff000000 & (((xapic_ldr_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0xd0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd0, _regval);
    // No shadow register to write to
}

/*
 * Register dfr: Destination Format
 * Type: xapic.dfr (Implicit type of Destination Format register)
 *   _anon0	(size 28, offset 0, init fffffff):	MB1	_
 *   model	(size 4, offset 28, init 0):	RW	Model
 */
static inline xapic_dfr_t xapic_dfr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_dfr_t xapic_dfr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline xapic_dfr_t xapic_dfr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_dfr_t xapic_dfr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xe0));
}

static inline void xapic_dfr_rawwr(__DN(t) *_dev, xapic_dfr_t _regval) __attribute__ ((always_inline));
static inline void xapic_dfr_rawwr(__DN(t) *_dev, xapic_dfr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline void xapic_dfr_wr(__DN(t) *_dev, xapic_dfr_t _regval) __attribute__ ((always_inline));
static inline void xapic_dfr_wr(__DN(t) *_dev, xapic_dfr_t _regval)
{
    // No MB0 or RSVD fields present
    _regval = (_regval | 0xfffffff);
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
}

static inline int xapic_dfr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_dfr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_dfr_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dfr (Destination Format): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " model =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_model_type_prtval(_s + _r, _avail, xapic_dfr_model_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Model)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline xapic_model_type_t xapic_dfr_model_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_model_type_t xapic_dfr_model_rdf(__DN(t) *_dev)
{
    xapic_dfr_t _regval = mackerel_read_addr_32(_dev->base, 0xe0);
    return(xapic_dfr_model_extract(_regval));
}

static inline void xapic_dfr_model_wrf(__DN(t) *_dev, xapic_model_type_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_dfr_model_wrf(__DN(t) *_dev, xapic_model_type_t _fieldval)
{
    xapic_dfr_t _regval = 0xf0000000 & (((xapic_dfr_t )(_fieldval)) << 28);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    _regval = (_regval | 0xfffffff);
    mackerel_write_addr_32(_dev->base, 0xe0, _regval);
    // No shadow register to write to
}

/*
 * Register apr: Arbitration priority
 * Type: xapic.priority (Various priorities)
 *   sub_class	(size 4, offset 0, init 0):	RO	Priority subclass
 *   priority	(size 4, offset 4, init 0):	RO	Priority
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline xapic_priority_t xapic_apr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_apr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline xapic_priority_t xapic_apr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_apr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x90));
}

static inline void xapic_apr_rawwr(__DN(t) *_dev, xapic_priority_t _regval) __attribute__ ((always_inline));
static inline void xapic_apr_rawwr(__DN(t) *_dev, xapic_priority_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x90, _regval);
}

// Register apr is not writeable
static inline int xapic_apr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_apr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register apr (Arbitration priority): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sub_class =\t%" PRIx8 "\t(Priority subclass)\n", xapic_priority_sub_class_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority)\n", xapic_priority_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t xapic_apr_sub_class_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_apr_sub_class_rdf(__DN(t) *_dev)
{
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    return(xapic_priority_sub_class_extract(_regval));
}

static inline uint8_t xapic_apr_priority_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_apr_priority_rdf(__DN(t) *_dev)
{
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0x90);
    return(xapic_priority_priority_extract(_regval));
}

/*
 * Register tpr: Task priority
 * Type: xapic.priority (Various priorities)
 *   sub_class	(size 4, offset 0, init 0):	RW	Priority subclass
 *   priority	(size 4, offset 4, init 0):	RW	Priority
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline xapic_priority_t xapic_tpr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_tpr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline xapic_priority_t xapic_tpr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_tpr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x80));
}

static inline void xapic_tpr_rawwr(__DN(t) *_dev, xapic_priority_t _regval) __attribute__ ((always_inline));
static inline void xapic_tpr_rawwr(__DN(t) *_dev, xapic_priority_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline void xapic_tpr_wr(__DN(t) *_dev, xapic_priority_t _regval) __attribute__ ((always_inline));
static inline void xapic_tpr_wr(__DN(t) *_dev, xapic_priority_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x80)));
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
}

static inline int xapic_tpr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_tpr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tpr (Task priority): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sub_class =\t%" PRIx8 "\t(Priority subclass)\n", xapic_priority_sub_class_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority)\n", xapic_priority_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t xapic_tpr_sub_class_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_tpr_sub_class_rdf(__DN(t) *_dev)
{
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(xapic_priority_sub_class_extract(_regval));
}

static inline uint8_t xapic_tpr_priority_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_tpr_priority_rdf(__DN(t) *_dev)
{
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0x80);
    return(xapic_priority_priority_extract(_regval));
}

static inline void xapic_tpr_sub_class_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_tpr_sub_class_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_priority_t _regval = 0xf & (((xapic_priority_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

static inline void xapic_tpr_priority_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_tpr_priority_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_priority_t _regval = 0xf0 & (((xapic_priority_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffff0f & mackerel_read_addr_32(_dev->base, 0x80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x80, _regval);
    // No shadow register to write to
}

/*
 * Register ppr: Processor priority
 * Type: xapic.priority (Various priorities)
 *   sub_class	(size 4, offset 0, init 0):	RO	Priority subclass
 *   priority	(size 4, offset 4, init 0):	RO	Priority
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline xapic_priority_t xapic_ppr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_ppr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline xapic_priority_t xapic_ppr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_priority_t xapic_ppr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa0));
}

static inline void xapic_ppr_rawwr(__DN(t) *_dev, xapic_priority_t _regval) __attribute__ ((always_inline));
static inline void xapic_ppr_rawwr(__DN(t) *_dev, xapic_priority_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa0, _regval);
}

// Register ppr is not writeable
static inline int xapic_ppr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_ppr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ppr (Processor priority): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sub_class =\t%" PRIx8 "\t(Priority subclass)\n", xapic_priority_sub_class_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority)\n", xapic_priority_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t xapic_ppr_sub_class_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_ppr_sub_class_rdf(__DN(t) *_dev)
{
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(xapic_priority_sub_class_extract(_regval));
}

static inline uint8_t xapic_ppr_priority_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_ppr_priority_rdf(__DN(t) *_dev)
{
    xapic_priority_t _regval = mackerel_read_addr_32(_dev->base, 0xa0);
    return(xapic_priority_priority_extract(_regval));
}

/*
 * Register array isr: ISR
 * Type: xapic.uint32 (primitive type)
 */
static const size_t xapic_isr_length = 8;
static inline uint32_t xapic_isr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_isr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x100 + (_i * 16)));
}

static inline uint32_t xapic_isr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_isr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x100 + (_i * 16)));
}

static inline void xapic_isr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_isr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100 + (_i * 16), _regval);
}

// Register isr is not writeable
static inline int xapic_isr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xapic_isr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x100 + (_i * 16));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "isr", _i, "ISR");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xapic_isr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_isr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xapic_isr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array tmr: TMR
 * Type: xapic.uint32 (primitive type)
 */
static const size_t xapic_tmr_length = 8;
static inline uint32_t xapic_tmr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_tmr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x180 + (_i * 16)));
}

static inline uint32_t xapic_tmr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_tmr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x180 + (_i * 16)));
}

static inline void xapic_tmr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_tmr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x180 + (_i * 16), _regval);
}

// Register tmr is not writeable
static inline int xapic_tmr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xapic_tmr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x180 + (_i * 16));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tmr", _i, "TMR");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xapic_tmr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_tmr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xapic_tmr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array irr: IRR
 * Type: xapic.uint32 (primitive type)
 */
static const size_t xapic_irr_length = 8;
static inline uint32_t xapic_irr_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_irr_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x200 + (_i * 16)));
}

static inline uint32_t xapic_irr_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_irr_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x200 + (_i * 16)));
}

static inline void xapic_irr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_irr_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x200 + (_i * 16), _regval);
}

// Register irr is not writeable
static inline int xapic_irr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xapic_irr_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x200 + (_i * 16));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "irr", _i, "IRR");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xapic_irr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_irr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xapic_irr_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register eoi: End Of Interrupt
 * Type: xapic.uint32 (primitive type)
 */
static inline uint32_t xapic_eoi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xapic_eoi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xb0));
}

static inline uint32_t xapic_eoi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t xapic_eoi_rd(__DN(t) *_dev)
{
    return(_dev->eoi_shadow);
}

static inline void xapic_eoi_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_eoi_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
}

static inline void xapic_eoi_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_eoi_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xb0, _regval);
}

static inline int xapic_eoi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_eoi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = _dev->eoi_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eoi (End Of Interrupt): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 " (SHADOW copy)\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register svr: Spurious Interrupt Vector Register
 * Type: xapic.svr (Implicit type of Spurious Interrupt Vector Register register)
 *   vector	(size 8, offset 0, init 0):	RW	Vector
 *   enable	(size 1, offset 8, init 0):	RW	APIC Software Enable/Disable
 *   focus	(size 1, offset 9, init 0):	RW	Focus Processor Checking
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
static inline xapic_svr_t xapic_svr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_svr_t xapic_svr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline xapic_svr_t xapic_svr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_svr_t xapic_svr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xf0));
}

static inline void xapic_svr_rawwr(__DN(t) *_dev, xapic_svr_t _regval) __attribute__ ((always_inline));
static inline void xapic_svr_rawwr(__DN(t) *_dev, xapic_svr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
}

static inline void xapic_svr_wr(__DN(t) *_dev, xapic_svr_t _regval) __attribute__ ((always_inline));
static inline void xapic_svr_wr(__DN(t) *_dev, xapic_svr_t _regval)
{
    _regval = (_regval & 0x3ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffffc00 & mackerel_read_addr_32(_dev->base, 0xf0)));
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
}

static inline int xapic_svr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_svr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_svr_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register svr (Spurious Interrupt Vector Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_svr_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(APIC Software Enable/Disable)\n", xapic_svr_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " focus =\t%" PRIx8 "\t(Focus Processor Checking)\n", xapic_svr_focus_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline uint8_t xapic_svr_vector_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_svr_vector_rdf(__DN(t) *_dev)
{
    xapic_svr_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(xapic_svr_vector_extract(_regval));
}

static inline uint8_t xapic_svr_enable_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_svr_enable_rdf(__DN(t) *_dev)
{
    xapic_svr_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(xapic_svr_enable_extract(_regval));
}

static inline uint8_t xapic_svr_focus_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_svr_focus_rdf(__DN(t) *_dev)
{
    xapic_svr_t _regval = mackerel_read_addr_32(_dev->base, 0xf0);
    return(xapic_svr_focus_extract(_regval));
}

static inline void xapic_svr_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_svr_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_svr_t _regval = 0xff & (((xapic_svr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0xf0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
    // No shadow register to write to
}

static inline void xapic_svr_enable_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_svr_enable_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_svr_t _regval = 0x100 & (((xapic_svr_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0xf0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
    // No shadow register to write to
}

static inline void xapic_svr_focus_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_svr_focus_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_svr_t _regval = 0x200 & (((xapic_svr_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0xf0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf0, _regval);
    // No shadow register to write to
}

/*
 * Register eafr: Extended APIC feature
 * Type: xapic.eafr (Implicit type of Extended APIC feature register)
 *   inc	(size 1, offset 0, init 0):	RO	Interrupt enable register capable
 *   snic	(size 1, offset 1, init 0):	RO	Specific EOI capable
 *   xaidc	(size 1, offset 2, init 0):	RO	Extended APIC ID capability
 *   _anon3	(size 13, offset 3, init 0):	MBZ	_
 *   xlc	(size 8, offset 16, init 0):	RO	Extended LVT count
 *   _anon24	(size 8, offset 24, init 0):	MBZ	_
 */
static inline xapic_eafr_t xapic_eafr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_eafr_t xapic_eafr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline xapic_eafr_t xapic_eafr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_eafr_t xapic_eafr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x400));
}

static inline void xapic_eafr_rawwr(__DN(t) *_dev, xapic_eafr_t _regval) __attribute__ ((always_inline));
static inline void xapic_eafr_rawwr(__DN(t) *_dev, xapic_eafr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x400, _regval);
}

// Register eafr is not writeable
static inline int xapic_eafr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_eafr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_eafr_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eafr (Extended APIC feature): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " inc =\t%" PRIx8 "\t(Interrupt enable register capable)\n", xapic_eafr_inc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " snic =\t%" PRIx8 "\t(Specific EOI capable)\n", xapic_eafr_snic_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xaidc =\t%" PRIx8 "\t(Extended APIC ID capability)\n", xapic_eafr_xaidc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xlc =\t%" PRIx8 "\t(Extended LVT count)\n", xapic_eafr_xlc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t xapic_eafr_inc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_inc_rdf(__DN(t) *_dev)
{
    xapic_eafr_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(xapic_eafr_inc_extract(_regval));
}

static inline uint8_t xapic_eafr_snic_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_snic_rdf(__DN(t) *_dev)
{
    xapic_eafr_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(xapic_eafr_snic_extract(_regval));
}

static inline uint8_t xapic_eafr_xaidc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_xaidc_rdf(__DN(t) *_dev)
{
    xapic_eafr_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(xapic_eafr_xaidc_extract(_regval));
}

static inline uint8_t xapic_eafr_xlc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_eafr_xlc_rdf(__DN(t) *_dev)
{
    xapic_eafr_t _regval = mackerel_read_addr_32(_dev->base, 0x400);
    return(xapic_eafr_xlc_extract(_regval));
}

/*
 * Register eacr: Extended APIC control
 * Type: xapic.eacr (Implicit type of Extended APIC control register)
 *   iern	(size 1, offset 0, init 0):	RW	Enable interrupt enable registers
 *   sn	(size 1, offset 1, init 0):	RW	Enable SEOI generation
 *   xaidn	(size 1, offset 2, init 0):	RW	Extended APIC ID enable
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline xapic_eacr_t xapic_eacr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_eacr_t xapic_eacr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline xapic_eacr_t xapic_eacr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_eacr_t xapic_eacr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x410));
}

static inline void xapic_eacr_rawwr(__DN(t) *_dev, xapic_eacr_t _regval) __attribute__ ((always_inline));
static inline void xapic_eacr_rawwr(__DN(t) *_dev, xapic_eacr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline void xapic_eacr_wr(__DN(t) *_dev, xapic_eacr_t _regval) __attribute__ ((always_inline));
static inline void xapic_eacr_wr(__DN(t) *_dev, xapic_eacr_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x410)));
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
}

static inline int xapic_eacr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_eacr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_eacr_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eacr (Extended APIC control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iern =\t%" PRIx8 "\t(Enable interrupt enable registers)\n", xapic_eacr_iern_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sn =\t%" PRIx8 "\t(Enable SEOI generation)\n", xapic_eacr_sn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xaidn =\t%" PRIx8 "\t(Extended APIC ID enable)\n", xapic_eacr_xaidn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t xapic_eacr_iern_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_eacr_iern_rdf(__DN(t) *_dev)
{
    xapic_eacr_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    return(xapic_eacr_iern_extract(_regval));
}

static inline uint8_t xapic_eacr_sn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_eacr_sn_rdf(__DN(t) *_dev)
{
    xapic_eacr_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    return(xapic_eacr_sn_extract(_regval));
}

static inline uint8_t xapic_eacr_xaidn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_eacr_xaidn_rdf(__DN(t) *_dev)
{
    xapic_eacr_t _regval = mackerel_read_addr_32(_dev->base, 0x410);
    return(xapic_eacr_xaidn_extract(_regval));
}

static inline void xapic_eacr_iern_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_eacr_iern_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_eacr_t _regval = 0x1 & (((xapic_eacr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x410)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
    // No shadow register to write to
}

static inline void xapic_eacr_sn_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_eacr_sn_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_eacr_t _regval = 0x2 & (((xapic_eacr_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x410)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
    // No shadow register to write to
}

static inline void xapic_eacr_xaidn_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_eacr_xaidn_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_eacr_t _regval = 0x4 & (((xapic_eacr_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x410)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x410, _regval);
    // No shadow register to write to
}

/*
 * Register seoi: Specific end-of-interrupt
 * Type: xapic.seoi (Implicit type of Specific end-of-interrupt register)
 *   vector	(size 8, offset 0, init 0):	WO	Vector
 *   _anon8	(size 24, offset 8, init 0):	MBZ	_
 */
static inline xapic_seoi_t xapic_seoi_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_seoi_t xapic_seoi_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x420));
}

static inline xapic_seoi_t xapic_seoi_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline xapic_seoi_t xapic_seoi_rd(__DN(t) *_dev)
{
    return(_dev->seoi_shadow);
}

static inline void xapic_seoi_rawwr(__DN(t) *_dev, xapic_seoi_t _regval) __attribute__ ((always_inline));
static inline void xapic_seoi_rawwr(__DN(t) *_dev, xapic_seoi_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
}

static inline void xapic_seoi_wr(__DN(t) *_dev, xapic_seoi_t _regval) __attribute__ ((always_inline));
static inline void xapic_seoi_wr(__DN(t) *_dev, xapic_seoi_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
}

static inline int xapic_seoi_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_seoi_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    xapic_seoi_t _regval = _dev->seoi_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register seoi (Specific end-of-interrupt): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vector =\t%" PRIx8 "\t(Vector)\n", xapic_seoi_vector_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t xapic_seoi_vector_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t xapic_seoi_vector_rd_shadow(__DN(t) *_dev)
{
    return(xapic_seoi_vector_extract(_dev->seoi_shadow));
}

static inline void xapic_seoi_vector_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void xapic_seoi_vector_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    xapic_seoi_t _regval = 0xff & (((xapic_seoi_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    _regval = (_regval & 0xff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x420, _regval);
    _dev->seoi_shadow = _regval;
}

/*
 * Register array ier: IER
 * Type: xapic.uint32 (primitive type)
 */
static const size_t xapic_ier_length = 8;
static inline uint32_t xapic_ier_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_ier_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x480 + (_i * 16)));
}

static inline uint32_t xapic_ier_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t xapic_ier_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x480 + (_i * 16)));
}

static inline void xapic_ier_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void xapic_ier_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x480 + (_i * 16), _regval);
}

// Register ier is not writeable
static inline int xapic_ier_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int xapic_ier_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x480 + (_i * 16));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ier", _i, "IER");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int xapic_ier_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_ier_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = xapic_ier_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline int xapic_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int xapic_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device xapic (Local APIC):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_id_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_version_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_lvt_timer_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_lvt_lint0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_lvt_lint1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_lvt_err_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_lvt_perf_cnt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_lvt_thermal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_esr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_dcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_init_count_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_cur_count_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_icr_lo_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_icr_hi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_ldr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_dfr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_apr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_tpr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_ppr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_isr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_tmr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_irr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_eoi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_svr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_eafr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_eacr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_seoi_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = xapic_ier_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device xapic\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __xapic_DEV_H
