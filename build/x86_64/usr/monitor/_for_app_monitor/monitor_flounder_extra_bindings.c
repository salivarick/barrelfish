/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: monitor
 * INTEFACE FILE: ../if/monitor.if
 * INTERFACE DESCRIPTION: The monitor to client Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Loopback stub
 */

#define _USE_XOPEN /* for strdup() */
#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/monitor_defs.h>
#include <if/monitor_loopback_defs.h>

/*
 * Message sender functions
 */
static  errval_t monitor_alloc_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id)
{
    // call rx handler
    assert(((_binding->rx_vtbl).alloc_iref_request) != NULL);
    ((_binding->rx_vtbl).alloc_iref_request)(_binding, service_id);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_alloc_iref_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, iref_t iref, monitor_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).alloc_iref_reply) != NULL);
    ((_binding->rx_vtbl).alloc_iref_reply)(_binding, service_id, iref, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_boot_core_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uint8_t id, int32_t hwid, int32_t type, const char *cmdline)
{
    // call rx handler
    assert(((_binding->rx_vtbl).boot_core_request) != NULL);
    ((_binding->rx_vtbl).boot_core_request)(_binding, id, hwid, type, strdup(cmdline));
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_boot_core_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).boot_core_reply) != NULL);
    ((_binding->rx_vtbl).boot_core_reply)(_binding, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_boot_initialize_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).boot_initialize_request) != NULL);
    ((_binding->rx_vtbl).boot_initialize_request)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_boot_initialize_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).boot_initialize_reply) != NULL);
    ((_binding->rx_vtbl).boot_initialize_reply)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_new_monitor_binding_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).new_monitor_binding_request) != NULL);
    ((_binding->rx_vtbl).new_monitor_binding_request)(_binding, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_new_monitor_binding_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, struct capref ep, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).new_monitor_binding_reply) != NULL);
    ((_binding->rx_vtbl).new_monitor_binding_reply)(_binding, err, ep, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_client_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t conn_id, size_t buflen, struct capref ep)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_lmp_client_request) != NULL);
    ((_binding->rx_vtbl).bind_lmp_client_request)(_binding, iref, conn_id, buflen, ep);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multiboot_cap_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uint32_t slot)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multiboot_cap_request) != NULL);
    ((_binding->rx_vtbl).multiboot_cap_request)(_binding, slot);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multiboot_cap_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, struct capref cap, monitor_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multiboot_cap_reply) != NULL);
    ((_binding->rx_vtbl).multiboot_cap_reply)(_binding, cap, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_service_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, uintptr_t mon_id, size_t buflen, struct capref ep)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_lmp_service_request) != NULL);
    ((_binding->rx_vtbl).bind_lmp_service_request)(_binding, service_id, mon_id, buflen, ep);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_reply_monitor__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, uintptr_t mon_id, uintptr_t conn_id, struct capref ep)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_lmp_reply_monitor) != NULL);
    ((_binding->rx_vtbl).bind_lmp_reply_monitor)(_binding, err, mon_id, conn_id, ep);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_lmp_reply_client__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, uintptr_t mon_id, uintptr_t conn_id, struct capref ep)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_lmp_reply_client) != NULL);
    ((_binding->rx_vtbl).bind_lmp_reply_client)(_binding, err, mon_id, conn_id, ep);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_client_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t conn_id, struct capref frame, size_t channel_length_in, size_t channel_length_out, struct capref notify)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_ump_client_request) != NULL);
    ((_binding->rx_vtbl).bind_ump_client_request)(_binding, iref, conn_id, frame, channel_length_in, channel_length_out, notify);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_service_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, uintptr_t mon_id, struct capref frame, size_t channel_length_in, size_t channel_length_out, struct capref notify)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_ump_service_request) != NULL);
    ((_binding->rx_vtbl).bind_ump_service_request)(_binding, service_id, mon_id, frame, channel_length_in, channel_length_out, notify);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_reply_monitor__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t mon_id, uintptr_t conn_id, monitor_errval_t err, struct capref notify)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_ump_reply_monitor) != NULL);
    ((_binding->rx_vtbl).bind_ump_reply_monitor)(_binding, mon_id, conn_id, err, notify);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bind_ump_reply_client__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t mon_id, uintptr_t conn_id, monitor_errval_t err, struct capref notify)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bind_ump_reply_client) != NULL);
    ((_binding->rx_vtbl).bind_ump_reply_client)(_binding, mon_id, conn_id, err, notify);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_ipi_alloc_notify_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, struct capref ep, uintptr_t state)
{
    // call rx handler
    assert(((_binding->rx_vtbl).ipi_alloc_notify_request) != NULL);
    ((_binding->rx_vtbl).ipi_alloc_notify_request)(_binding, ep, state);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_ipi_alloc_notify_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t state, struct capref notify, monitor_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).ipi_alloc_notify_reply) != NULL);
    ((_binding->rx_vtbl).ipi_alloc_notify_reply)(_binding, state, notify, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_mem_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_mem_iref_request) != NULL);
    ((_binding->rx_vtbl).get_mem_iref_request)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_mem_iref_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_mem_iref_reply) != NULL);
    ((_binding->rx_vtbl).get_mem_iref_reply)(_binding, iref);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_name_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_name_iref_request) != NULL);
    ((_binding->rx_vtbl).get_name_iref_request)(_binding, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_name_iref_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_name_iref_reply) != NULL);
    ((_binding->rx_vtbl).get_name_iref_reply)(_binding, iref, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_ramfs_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_ramfs_iref_request) != NULL);
    ((_binding->rx_vtbl).get_ramfs_iref_request)(_binding, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_ramfs_iref_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_ramfs_iref_reply) != NULL);
    ((_binding->rx_vtbl).get_ramfs_iref_reply)(_binding, iref, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_ramfs_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // call rx handler
    assert(((_binding->rx_vtbl).set_ramfs_iref_request) != NULL);
    ((_binding->rx_vtbl).set_ramfs_iref_request)(_binding, iref);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_mem_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // call rx handler
    assert(((_binding->rx_vtbl).set_mem_iref_request) != NULL);
    ((_binding->rx_vtbl).set_mem_iref_request)(_binding, iref);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_name_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // call rx handler
    assert(((_binding->rx_vtbl).set_name_iref_request) != NULL);
    ((_binding->rx_vtbl).set_name_iref_request)(_binding, iref);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_set_name_iref_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).set_name_iref_reply) != NULL);
    ((_binding->rx_vtbl).set_name_iref_reply)(_binding, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_monitor_rpc_iref_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_monitor_rpc_iref_request) != NULL);
    ((_binding->rx_vtbl).get_monitor_rpc_iref_request)(_binding, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_get_monitor_rpc_iref_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, uintptr_t st)
{
    // call rx handler
    assert(((_binding->rx_vtbl).get_monitor_rpc_iref_reply) != NULL);
    ((_binding->rx_vtbl).get_monitor_rpc_iref_reply)(_binding, iref, st);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_cap_send_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t mon_id, struct capref cap, monitor_capid_t_t capid, uint8_t give_away)
{
    // call rx handler
    assert(((_binding->rx_vtbl).cap_send_request) != NULL);
    ((_binding->rx_vtbl).cap_send_request)(_binding, mon_id, cap, capid, give_away);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_cap_receive_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t conn_id, monitor_errval_t err, struct capref cap, monitor_capid_t_t capid)
{
    // call rx handler
    assert(((_binding->rx_vtbl).cap_receive_request) != NULL);
    ((_binding->rx_vtbl).cap_receive_request)(_binding, conn_id, err, cap, capid);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_span_domain_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t domain_id, uint8_t core_id, struct capref vroot, struct capref disp)
{
    // call rx handler
    assert(((_binding->rx_vtbl).span_domain_request) != NULL);
    ((_binding->rx_vtbl).span_domain_request)(_binding, domain_id, core_id, vroot, disp);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_span_domain_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_errval_t err, uintptr_t domain_id)
{
    // call rx handler
    assert(((_binding->rx_vtbl).span_domain_reply) != NULL);
    ((_binding->rx_vtbl).span_domain_reply)(_binding, err, domain_id);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_num_cores_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).num_cores_request) != NULL);
    ((_binding->rx_vtbl).num_cores_request)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_num_cores_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uint8_t num)
{
    // call rx handler
    assert(((_binding->rx_vtbl).num_cores_reply) != NULL);
    ((_binding->rx_vtbl).num_cores_reply)(_binding, num);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_routing_table_new__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_coreid_t max_coreid, monitor_coreid_t nentries)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_routing_table_new) != NULL);
    ((_binding->rx_vtbl).multihop_routing_table_new)(_binding, max_coreid, nentries);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_routing_table_set__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_coreid_t from, const monitor_coreid_t *to, size_t len)
{
    // copy array arguments
    monitor_coreid_t *_copy_of_to = malloc((sizeof(monitor_coreid_t )) * len);
    if (_copy_of_to == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    memcpy(_copy_of_to, to, (sizeof(monitor_coreid_t )) * len);
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_routing_table_set) != NULL);
    ((_binding->rx_vtbl).multihop_routing_table_set)(_binding, from, _copy_of_to, len);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_client_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref, monitor_vci_t_t sender_vci)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_bind_client_request) != NULL);
    ((_binding->rx_vtbl).multihop_bind_client_request)(_binding, iref, sender_vci);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_client_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t receiver_vci, monitor_vci_t_t sender_vci, monitor_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_bind_client_reply) != NULL);
    ((_binding->rx_vtbl).multihop_bind_client_reply)(_binding, receiver_vci, sender_vci, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_service_request__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, uintptr_t service_id, monitor_vci_t_t sender_vci)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_bind_service_request) != NULL);
    ((_binding->rx_vtbl).multihop_bind_service_request)(_binding, service_id, sender_vci);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_bind_service_reply__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t receiver_vci, monitor_vci_t_t sender_vci, monitor_errval_t err)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_bind_service_reply) != NULL);
    ((_binding->rx_vtbl).multihop_bind_service_reply)(_binding, receiver_vci, sender_vci, err);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_message__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t vci, uint8_t direction, uint8_t flags, uint32_t ack, const uint8_t *payload, size_t size)
{
    // copy array arguments
    uint8_t *_copy_of_payload = malloc((sizeof(uint8_t )) * size);
    if (_copy_of_payload == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    memcpy(_copy_of_payload, payload, (sizeof(uint8_t )) * size);
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_message) != NULL);
    ((_binding->rx_vtbl).multihop_message)(_binding, vci, direction, flags, ack, _copy_of_payload, size);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_multihop_cap_send__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_vci_t_t vci, uint8_t direction, monitor_errval_t err, struct capref cap, monitor_capid_t_t capid)
{
    // call rx handler
    assert(((_binding->rx_vtbl).multihop_cap_send) != NULL);
    ((_binding->rx_vtbl).multihop_cap_send)(_binding, vci, direction, err, cap, capid);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_trace_prepare__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, monitor_coreid_t origin_core)
{
    // call rx handler
    assert(((_binding->rx_vtbl).trace_prepare) != NULL);
    ((_binding->rx_vtbl).trace_prepare)(_binding, origin_core);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_trace_prepare_finished__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).trace_prepare_finished) != NULL);
    ((_binding->rx_vtbl).trace_prepare_finished)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bfscope_flush_send__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation, iref_t iref)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bfscope_flush_send) != NULL);
    ((_binding->rx_vtbl).bfscope_flush_send)(_binding, iref);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}

static  errval_t monitor_bfscope_flush_ack__loopback_send(struct monitor_binding *_binding, struct event_closure _continuation)
{
    // call rx handler
    assert(((_binding->rx_vtbl).bfscope_flush_ack) != NULL);
    ((_binding->rx_vtbl).bfscope_flush_ack)(_binding);
    
    // run continuation, if any
    if ((_continuation.handler) != NULL) {
        (_continuation.handler)(_continuation.arg);
    }
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct monitor_tx_vtbl monitor_loopback_tx_vtbl = {
    .alloc_iref_request = monitor_alloc_iref_request__loopback_send,
    .alloc_iref_reply = monitor_alloc_iref_reply__loopback_send,
    .boot_core_request = monitor_boot_core_request__loopback_send,
    .boot_core_reply = monitor_boot_core_reply__loopback_send,
    .boot_initialize_request = monitor_boot_initialize_request__loopback_send,
    .boot_initialize_reply = monitor_boot_initialize_reply__loopback_send,
    .new_monitor_binding_request = monitor_new_monitor_binding_request__loopback_send,
    .new_monitor_binding_reply = monitor_new_monitor_binding_reply__loopback_send,
    .bind_lmp_client_request = monitor_bind_lmp_client_request__loopback_send,
    .multiboot_cap_request = monitor_multiboot_cap_request__loopback_send,
    .multiboot_cap_reply = monitor_multiboot_cap_reply__loopback_send,
    .bind_lmp_service_request = monitor_bind_lmp_service_request__loopback_send,
    .bind_lmp_reply_monitor = monitor_bind_lmp_reply_monitor__loopback_send,
    .bind_lmp_reply_client = monitor_bind_lmp_reply_client__loopback_send,
    .bind_ump_client_request = monitor_bind_ump_client_request__loopback_send,
    .bind_ump_service_request = monitor_bind_ump_service_request__loopback_send,
    .bind_ump_reply_monitor = monitor_bind_ump_reply_monitor__loopback_send,
    .bind_ump_reply_client = monitor_bind_ump_reply_client__loopback_send,
    .ipi_alloc_notify_request = monitor_ipi_alloc_notify_request__loopback_send,
    .ipi_alloc_notify_reply = monitor_ipi_alloc_notify_reply__loopback_send,
    .get_mem_iref_request = monitor_get_mem_iref_request__loopback_send,
    .get_mem_iref_reply = monitor_get_mem_iref_reply__loopback_send,
    .get_name_iref_request = monitor_get_name_iref_request__loopback_send,
    .get_name_iref_reply = monitor_get_name_iref_reply__loopback_send,
    .get_ramfs_iref_request = monitor_get_ramfs_iref_request__loopback_send,
    .get_ramfs_iref_reply = monitor_get_ramfs_iref_reply__loopback_send,
    .set_ramfs_iref_request = monitor_set_ramfs_iref_request__loopback_send,
    .set_mem_iref_request = monitor_set_mem_iref_request__loopback_send,
    .set_name_iref_request = monitor_set_name_iref_request__loopback_send,
    .set_name_iref_reply = monitor_set_name_iref_reply__loopback_send,
    .get_monitor_rpc_iref_request = monitor_get_monitor_rpc_iref_request__loopback_send,
    .get_monitor_rpc_iref_reply = monitor_get_monitor_rpc_iref_reply__loopback_send,
    .cap_send_request = monitor_cap_send_request__loopback_send,
    .cap_receive_request = monitor_cap_receive_request__loopback_send,
    .span_domain_request = monitor_span_domain_request__loopback_send,
    .span_domain_reply = monitor_span_domain_reply__loopback_send,
    .num_cores_request = monitor_num_cores_request__loopback_send,
    .num_cores_reply = monitor_num_cores_reply__loopback_send,
    .multihop_routing_table_new = monitor_multihop_routing_table_new__loopback_send,
    .multihop_routing_table_set = monitor_multihop_routing_table_set__loopback_send,
    .multihop_bind_client_request = monitor_multihop_bind_client_request__loopback_send,
    .multihop_bind_client_reply = monitor_multihop_bind_client_reply__loopback_send,
    .multihop_bind_service_request = monitor_multihop_bind_service_request__loopback_send,
    .multihop_bind_service_reply = monitor_multihop_bind_service_reply__loopback_send,
    .multihop_message = monitor_multihop_message__loopback_send,
    .multihop_cap_send = monitor_multihop_cap_send__loopback_send,
    .trace_prepare = monitor_trace_prepare__loopback_send,
    .trace_prepare_finished = monitor_trace_prepare_finished__loopback_send,
    .bfscope_flush_send = monitor_bfscope_flush_send__loopback_send,
    .bfscope_flush_ack = monitor_bfscope_flush_ack__loopback_send,
};
/*
 * Control functions
 */
static  bool monitor_loopback_can_send(struct monitor_binding *b)
{
    return(true);
}

static  errval_t monitor_loopback_register_send(struct monitor_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(ERR_NOTIMP);
}

static  void monitor_loopback_default_error_handler(struct monitor_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated monitor loopback binding (default handler)");
    abort();
}

static  errval_t monitor_loopback_change_waitset(struct monitor_binding *_binding, struct waitset *ws)
{
    return(ERR_NOTIMP);
}

static  errval_t monitor_loopback_control(struct monitor_binding *_binding, idc_control_t control)
{
    // no control flags are supported
    return(SYS_ERR_OK);
}

/*
 * Function to initialise the binding state
 */
 void monitor_loopback_init(struct monitor_binding *_binding)
{
    (*_binding).st = NULL;
    (*_binding).waitset = NULL;
    event_mutex_init(&((*_binding).mutex), NULL);
    (*_binding).can_send = monitor_loopback_can_send;
    (*_binding).register_send = monitor_loopback_register_send;
    (*_binding).error_handler = monitor_loopback_default_error_handler;
    (*_binding).tx_vtbl = monitor_loopback_tx_vtbl;
    memset(&((*_binding).rx_vtbl), 0, sizeof((*_binding).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((*_binding).register_chanstate));
    flounder_support_waitset_chanstate_init(&((*_binding).tx_cont_chanstate));
    (*_binding).tx_msgnum = 0;
    (*_binding).rx_msgnum = 0;
    (*_binding).tx_msg_fragment = 0;
    (*_binding).rx_msg_fragment = 0;
    (*_binding).tx_str_pos = 0;
    (*_binding).rx_str_pos = 0;
    (*_binding).tx_str_len = 0;
    (*_binding).rx_str_len = 0;
    (*_binding).bind_cont = NULL;
    _binding->change_waitset = monitor_loopback_change_waitset;
    _binding->control = monitor_loopback_control;
}

