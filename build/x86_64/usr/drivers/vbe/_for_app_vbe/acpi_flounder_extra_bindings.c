/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: acpi
 * INTEFACE FILE: ../if/acpi.if
 * INTERFACE DESCRIPTION: acpi RPC Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for RPC
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/acpi_rpcclient_defs.h>

/*
 * RPC wrapper functions
 */
static  errval_t acpi_get_pcie_confspace__rpc(struct acpi_rpc_client *_rpc, acpi_errval_t *err, uint64_t *address, uint16_t *segment, uint8_t *startbus, uint8_t *endbus)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).get_pcie_confspace_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).get_pcie_confspace_response).err);
    *address = (((_binding->rx_union).get_pcie_confspace_response).address);
    *segment = (((_binding->rx_union).get_pcie_confspace_response).segment);
    *startbus = (((_binding->rx_union).get_pcie_confspace_response).startbus);
    *endbus = (((_binding->rx_union).get_pcie_confspace_response).endbus);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_read_irq_table__rpc(struct acpi_rpc_client *_rpc, const char *handle, acpi_pci_address_t addr, uint8_t bus, acpi_errval_t *error, char **child)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).read_irq_table_call)(_rpc->b, NOP_CONT, handle, addr, bus));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *error = (((_binding->rx_union).read_irq_table_response).error);
    *child = (((_binding->rx_union).read_irq_table_response).child);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_set_device_irq__rpc(struct acpi_rpc_client *_rpc, const char *handle, uint32_t irq, acpi_errval_t *error)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).set_device_irq_call)(_rpc->b, NOP_CONT, handle, irq));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *error = (((_binding->rx_union).set_device_irq_response).error);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_enable_and_route_interrupt__rpc(struct acpi_rpc_client *_rpc, uint32_t gsi, acpi_coreid_t dest, uint32_t vector, acpi_errval_t *error_code)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).enable_and_route_interrupt_call)(_rpc->b, NOP_CONT, gsi, dest, vector));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *error_code = (((_binding->rx_union).enable_and_route_interrupt_response).error_code);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_reset__rpc(struct acpi_rpc_client *_rpc, acpi_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).reset_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).reset_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_sleep__rpc(struct acpi_rpc_client *_rpc, uint32_t state, acpi_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).sleep_call)(_rpc->b, NOP_CONT, state));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).sleep_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_get_vbe_bios_cap__rpc(struct acpi_rpc_client *_rpc, acpi_errval_t *err, struct capref *cap, uint32_t *size)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).get_vbe_bios_cap_call)(_rpc->b, NOP_CONT));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).get_vbe_bios_cap_response).err);
    *cap = (((_binding->rx_union).get_vbe_bios_cap_response).cap);
    *size = (((_binding->rx_union).get_vbe_bios_cap_response).size);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_mm_alloc_range_proxy__rpc(struct acpi_rpc_client *_rpc, uint8_t sizebits, uint64_t minbase, uint64_t maxlimit, struct capref *devframe, acpi_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).mm_alloc_range_proxy_call)(_rpc->b, NOP_CONT, sizebits, minbase, maxlimit));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *devframe = (((_binding->rx_union).mm_alloc_range_proxy_response).devframe);
    *err = (((_binding->rx_union).mm_alloc_range_proxy_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}

static  errval_t acpi_mm_free_proxy__rpc(struct acpi_rpc_client *_rpc, struct capref devframe, uint64_t base, uint8_t sizebits, acpi_errval_t *err)
{
    errval_t _err = SYS_ERR_OK;
    assert(!(_rpc->rpc_in_progress));
    assert((_rpc->async_error) == SYS_ERR_OK);
    _rpc->rpc_in_progress = true;
    _rpc->reply_present = false;
    
    // call send function
    _err = ((((_rpc->b)->tx_vtbl).mm_free_proxy_call)(_rpc->b, NOP_CONT, devframe, base, sizebits));
    if (err_is_fail(_err)) {
        goto out;
    }
    
    // wait for message to be sent and reply or error to be present
    while (((!(_rpc->reply_present)) || (!(((_rpc->b)->can_send)(_rpc->b)))) && ((_rpc->async_error) == SYS_ERR_OK)) {
        _err = event_dispatch(&(_rpc->rpc_waitset));
        if (err_is_fail(_err)) {
            _err = err_push(_err, LIB_ERR_EVENT_DISPATCH);
            goto out;
        }
    }
    
    if (err_is_fail(_rpc->async_error)) {
        _err = (_rpc->async_error);
        _rpc->async_error = SYS_ERR_OK;
        goto out;
    }
    
    // grab reply variables out of binding
    struct acpi_binding *_binding = _rpc->b;
    *err = (((_binding->rx_union).mm_free_proxy_response).err);
    
    out:
    _rpc->rpc_in_progress = false;
    return(_err);
}


/*
 * Receive handlers
 */
static  void acpi_get_pcie_confspace__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t err, uint64_t address, uint16_t segment, uint8_t startbus, uint8_t endbus)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).get_pcie_confspace_response).err = err;
    ((_binding->rx_union).get_pcie_confspace_response).address = address;
    ((_binding->rx_union).get_pcie_confspace_response).segment = segment;
    ((_binding->rx_union).get_pcie_confspace_response).startbus = startbus;
    ((_binding->rx_union).get_pcie_confspace_response).endbus = endbus;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_read_irq_table__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t error, char *child)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).read_irq_table_response).error = error;
    ((_binding->rx_union).read_irq_table_response).child = child;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_set_device_irq__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t error)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).set_device_irq_response).error = error;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_enable_and_route_interrupt__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t error_code)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).enable_and_route_interrupt_response).error_code = error_code;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_reset__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t err)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).reset_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_sleep__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t err)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).sleep_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_get_vbe_bios_cap__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t err, struct capref cap, uint32_t size)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).get_vbe_bios_cap_response).err = err;
    ((_binding->rx_union).get_vbe_bios_cap_response).cap = cap;
    ((_binding->rx_union).get_vbe_bios_cap_response).size = size;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_mm_alloc_range_proxy__rpc_rx_handler(struct acpi_binding *_binding, struct capref devframe, acpi_errval_t err)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).mm_alloc_range_proxy_response).devframe = devframe;
    ((_binding->rx_union).mm_alloc_range_proxy_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}

static  void acpi_mm_free_proxy__rpc_rx_handler(struct acpi_binding *_binding, acpi_errval_t err)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    // XXX: stash reply parameters in binding object
    // depending on the interconnect driver, they're probably already there
    ((_binding->rx_union).mm_free_proxy_response).err = err;
    
    // notify RPC function, and we're done
    _rpc->reply_present = true;
}


/*
 * RPC Vtable
 */
static  struct acpi_rpc_vtbl acpi_rpc_vtbl = {
    .get_pcie_confspace = acpi_get_pcie_confspace__rpc,
    .read_irq_table = acpi_read_irq_table__rpc,
    .set_device_irq = acpi_set_device_irq__rpc,
    .enable_and_route_interrupt = acpi_enable_and_route_interrupt__rpc,
    .reset = acpi_reset__rpc,
    .sleep = acpi_sleep__rpc,
    .get_vbe_bios_cap = acpi_get_vbe_bios_cap__rpc,
    .mm_alloc_range_proxy = acpi_mm_alloc_range_proxy__rpc,
    .mm_free_proxy = acpi_mm_free_proxy__rpc,
};

/*
 * Error handler
 */
static  void acpi_rpc_client_error(struct acpi_binding *_binding, errval_t _err)
{
    // get RPC client state pointer
    struct acpi_rpc_client *_rpc = _binding->st;
    
    if (_rpc->rpc_in_progress) {
        assert(err_is_fail(_err));
        _rpc->async_error = _err;
        // kick waitset with dummy event
        flounder_support_register(&(_rpc->rpc_waitset), &(_rpc->dummy_chanstate), dummy_event_closure, true);
    } else {
        USER_PANIC_ERR(_err, "async error in RPC");
    }
}


/*
 * Init function
 */
 errval_t acpi_rpc_client_init(struct acpi_rpc_client *rpc, struct acpi_binding *binding)
{
    errval_t _err;
    
    // Setup state of RPC client object
    rpc->b = binding;
    rpc->reply_present = false;
    rpc->rpc_in_progress = false;
    rpc->async_error = SYS_ERR_OK;
    waitset_init(&(rpc->rpc_waitset));
    flounder_support_waitset_chanstate_init(&(rpc->dummy_chanstate));
    rpc->vtbl = acpi_rpc_vtbl;
    binding->st = rpc;
    
    // Change waitset on binding
    _err = ((binding->change_waitset)(binding, &(rpc->rpc_waitset)));
    if (err_is_fail(_err)) {
        waitset_destroy(&(rpc->rpc_waitset));
        return(err_push(_err, FLOUNDER_ERR_CHANGE_WAITSET));
    }
    
    // Set RX handlers on binding object for RPCs
    (binding->rx_vtbl).get_pcie_confspace_response = acpi_get_pcie_confspace__rpc_rx_handler;
    (binding->rx_vtbl).read_irq_table_response = acpi_read_irq_table__rpc_rx_handler;
    (binding->rx_vtbl).set_device_irq_response = acpi_set_device_irq__rpc_rx_handler;
    (binding->rx_vtbl).enable_and_route_interrupt_response = acpi_enable_and_route_interrupt__rpc_rx_handler;
    (binding->rx_vtbl).reset_response = acpi_reset__rpc_rx_handler;
    (binding->rx_vtbl).sleep_response = acpi_sleep__rpc_rx_handler;
    (binding->rx_vtbl).get_vbe_bios_cap_response = acpi_get_vbe_bios_cap__rpc_rx_handler;
    (binding->rx_vtbl).mm_alloc_range_proxy_response = acpi_mm_alloc_range_proxy__rpc_rx_handler;
    (binding->rx_vtbl).mm_free_proxy_response = acpi_mm_free_proxy__rpc_rx_handler;
    
    // Set error handler on binding object
    binding->error_handler = acpi_rpc_client_error;
    
    return(SYS_ERR_OK);
}

