/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: bench
 * INTEFACE FILE: ../if/bench.if
 * INTERFACE DESCRIPTION: The bench Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/bench_defs.h>

/*
 * Export function
 */
 errval_t bench_export(void *st, idc_export_callback_fn *export_cb, bench_connect_fn *connect_cb, struct waitset *ws, idc_export_flags_t flags)
{
    struct bench_export *e = malloc(sizeof(struct bench_export ));
    if (e == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    // fill in common parts of export struct
    e->connect_cb = connect_cb;
    e->waitset = ws;
    e->st = st;
    (e->common).export_callback = export_cb;
    (e->common).flags = flags;
    (e->common).connect_cb_st = e;
    (e->common).export_cb_st = st;
    
    // fill in connect handler for each enabled backend
    #ifdef CONFIG_FLOUNDER_BACKEND_LMP
    (e->common).lmp_connect_callback = bench_lmp_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_LMP
    #ifdef CONFIG_FLOUNDER_BACKEND_UMP
    (e->common).ump_connect_callback = bench_ump_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_UMP
    #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
    (e->common).ump_connect_callback = bench_ump_ipi_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
    #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
    (e->common).multihop_connect_callback = bench_multihop_connect_handler;
    #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
    
    return(idc_export_service(&(e->common)));
}


/*
 * Generic bind function
 */
static  void bench_bind_continuation_direct(void *st, errval_t err, struct bench_binding *_binding)
{
    // This bind cont function uses the different backends in the following order:
    // lmp ump_ipi ump multihop
    
    struct flounder_generic_bind_attempt *b = st;
    switch (b->driver_num) {
    case 0:
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        // try next backend
        b->binding = malloc(sizeof(struct bench_lmp_binding ));
        assert((b->binding) != NULL);
        err = bench_lmp_bind(b->binding, b->iref, bench_bind_continuation_direct, b, b->waitset, b->flags, DEFAULT_LMP_BUF_WORDS);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
    case 1:
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (err_no(err) == MON_ERR_IDC_BIND_NOT_SAME_CORE) {
                goto try_next_1;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_1:
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        // try next backend
        b->binding = malloc(sizeof(struct bench_ump_ipi_binding ));
        assert((b->binding) != NULL);
        err = bench_ump_ipi_bind(b->binding, b->iref, bench_bind_continuation_direct, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
    case 2:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_2;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_2:
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        // try next backend
        b->binding = malloc(sizeof(struct bench_ump_binding ));
        assert((b->binding) != NULL);
        err = bench_ump_bind(b->binding, b->iref, bench_bind_continuation_direct, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
    case 3:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_3;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_3:
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        // try next backend
        b->binding = malloc(sizeof(struct bench_multihop_binding ));
        assert((b->binding) != NULL);
        err = bench_multihop_bind(b->binding, b->iref, bench_bind_continuation_direct, b, b->waitset, b->flags);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
    case 4:
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (!true) {
                _binding = NULL;
                goto out;
            }
        }
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
        err = FLOUNDER_ERR_GENERIC_BIND_NO_MORE_DRIVERS;
        _binding = NULL;
        goto out;
    default:
        assert(!("invalid state"));
    }
    
    out:
    ((bench_bind_continuation_fn *)(b->callback))(b->st, err, _binding);
    free(b);
}

static  void bench_bind_contination_multihop(void *st, errval_t err, struct bench_binding *_binding)
{
    // This bind cont function uses the different backends in the following order:
    // lmp multihop ump_ipi ump
    
    struct flounder_generic_bind_attempt *b = st;
    switch (b->driver_num) {
    case 0:
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        // try next backend
        b->binding = malloc(sizeof(struct bench_lmp_binding ));
        assert((b->binding) != NULL);
        err = bench_lmp_bind(b->binding, b->iref, bench_bind_contination_multihop, b, b->waitset, b->flags, DEFAULT_LMP_BUF_WORDS);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
    case 1:
        #ifdef CONFIG_FLOUNDER_BACKEND_LMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (err_no(err) == MON_ERR_IDC_BIND_NOT_SAME_CORE) {
                goto try_next_1;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_1:
        #endif // CONFIG_FLOUNDER_BACKEND_LMP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        // try next backend
        b->binding = malloc(sizeof(struct bench_multihop_binding ));
        assert((b->binding) != NULL);
        err = bench_multihop_bind(b->binding, b->iref, bench_bind_contination_multihop, b, b->waitset, b->flags);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
    case 2:
        #ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_2;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_2:
        #endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        // try next backend
        b->binding = malloc(sizeof(struct bench_ump_ipi_binding ));
        assert((b->binding) != NULL);
        err = bench_ump_ipi_bind(b->binding, b->iref, bench_bind_contination_multihop, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
    case 3:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP_IPI
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (true) {
                goto try_next_3;
            } else {
                // report permanent failure to user
                _binding = NULL;
                goto out;
            }
        }
        try_next_3:
        #endif // CONFIG_FLOUNDER_BACKEND_UMP_IPI
        (b->driver_num)++;
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        // try next backend
        b->binding = malloc(sizeof(struct bench_ump_binding ));
        assert((b->binding) != NULL);
        err = bench_ump_bind(b->binding, b->iref, bench_bind_contination_multihop, b, b->waitset, b->flags, DEFAULT_UMP_BUFLEN, DEFAULT_UMP_BUFLEN);
        if (err_is_fail(err)) {
            free(b->binding);
            _binding = NULL;
            goto out;
        } else {
            return;
        }
        #else
        // skip non-enabled backend (fall through)
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
    case 4:
        #ifdef CONFIG_FLOUNDER_BACKEND_UMP
        if (err_is_ok(err)) {
            goto out;
        } else {
            free(b->binding);
            if (!true) {
                _binding = NULL;
                goto out;
            }
        }
        #endif // CONFIG_FLOUNDER_BACKEND_UMP
        err = FLOUNDER_ERR_GENERIC_BIND_NO_MORE_DRIVERS;
        _binding = NULL;
        goto out;
    default:
        assert(!("invalid state"));
    }
    
    out:
    ((bench_bind_continuation_fn *)(b->callback))(b->st, err, _binding);
    free(b);
}

 errval_t bench_bind(iref_t iref, bench_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags)
{
    // allocate state
    struct flounder_generic_bind_attempt *b = malloc(sizeof(struct flounder_generic_bind_attempt ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    // fill in binding state
    b->iref = iref;
    b->waitset = waitset;
    b->driver_num = 0;
    b->callback = _continuation;
    b->st = st;
    b->flags = flags;
    
    if (flags & IDC_BIND_FLAG_MULTIHOP) {
        bench_bind_contination_multihop(b, SYS_ERR_OK, NULL);
    } else {
        bench_bind_continuation_direct(b, SYS_ERR_OK, NULL);
    }
    
    return(SYS_ERR_OK);
}

/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: bench
 * INTEFACE FILE: ../if/bench.if
 * INTERFACE DESCRIPTION: The bench Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

/*
 * Generated Stub for LMP on x86_64
 */

#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <flounder/flounder_support_lmp.h>
#include <if/bench_defs.h>

/*
 * Send handler functions
 */
static  void bench_init_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_init_request__msgnum | (((uintptr_t )(((_binding->tx_union).init_request).coreid)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_init_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_init_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_init_reply__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_init_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_token_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_token_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_token_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_token_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_token_reply__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_token_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_busy_init_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_busy_init_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_busy_init_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_busy_init_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_busy_init_reply__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_busy_init_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_busy_ping__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_busy_ping__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_busy_ping__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_ump_init_msg__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_ump_init_msg__msgnum | (((uintptr_t )(((_binding->tx_union).ump_init_msg).coreid)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_ump_init_msg__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_init_msg__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_fsb_init_msg__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_init_msg).coreid)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_init_msg__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_empty_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_fsb_empty_request__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_empty_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_empty_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_fsb_empty_reply__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_empty_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_buffer_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, bench_fsb_buffer_request__msgnum);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).fsb_buffer_request).buf, ((_binding->tx_union).fsb_buffer_request).size, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_buffer_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_buffer_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, bench_fsb_buffer_reply__msgnum);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = flounder_stub_lmp_send_buf(&(b->chan), b->flags, ((_binding->tx_union).fsb_buffer_reply).buf, ((_binding->tx_union).fsb_buffer_reply).size, &(_binding->tx_str_pos));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_buffer_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload_request).word0)) << 16), (((_binding->tx_union).fsb_payload_request).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload_request).word2)) << 32), ((_binding->tx_union).fsb_payload_request).word3);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload_reply).word0)) << 16), (((_binding->tx_union).fsb_payload_reply).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload_reply).word2)) << 32), ((_binding->tx_union).fsb_payload_reply).word3);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload1_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload1_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload1_request).word0)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload1_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload1_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload1_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload1_reply).word0)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload1_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload2_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload2_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload2_request).word0)) << 16), ((_binding->tx_union).fsb_payload2_request).word1);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload2_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload2_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload2_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload2_reply).word0)) << 16), ((_binding->tx_union).fsb_payload2_reply).word1);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload2_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload8_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload8_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word0)) << 16), (((_binding->tx_union).fsb_payload8_request).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word2)) << 32), (((_binding->tx_union).fsb_payload8_request).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word4)) << 32), (((_binding->tx_union).fsb_payload8_request).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word6)) << 32), ((_binding->tx_union).fsb_payload8_request).word7);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload8_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload8_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload8_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word0)) << 16), (((_binding->tx_union).fsb_payload8_reply).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word2)) << 32), (((_binding->tx_union).fsb_payload8_reply).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word4)) << 32), (((_binding->tx_union).fsb_payload8_reply).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word6)) << 32), ((_binding->tx_union).fsb_payload8_reply).word7);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload8_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload16_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send9(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload16_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word0)) << 16), (((_binding->tx_union).fsb_payload16_request).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word2)) << 32), (((_binding->tx_union).fsb_payload16_request).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word4)) << 32), (((_binding->tx_union).fsb_payload16_request).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word6)) << 32), (((_binding->tx_union).fsb_payload16_request).word7) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word8)) << 32), (((_binding->tx_union).fsb_payload16_request).word9) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word10)) << 32), (((_binding->tx_union).fsb_payload16_request).word11) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word12)) << 32), (((_binding->tx_union).fsb_payload16_request).word13) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word14)) << 32), ((_binding->tx_union).fsb_payload16_request).word15);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload16_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload16_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send9(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload16_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word0)) << 16), (((_binding->tx_union).fsb_payload16_reply).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word2)) << 32), (((_binding->tx_union).fsb_payload16_reply).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word4)) << 32), (((_binding->tx_union).fsb_payload16_reply).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word6)) << 32), (((_binding->tx_union).fsb_payload16_reply).word7) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word8)) << 32), (((_binding->tx_union).fsb_payload16_reply).word9) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word10)) << 32), (((_binding->tx_union).fsb_payload16_reply).word11) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word12)) << 32), (((_binding->tx_union).fsb_payload16_reply).word13) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word14)) << 32), ((_binding->tx_union).fsb_payload16_reply).word15);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload16_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_1_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_1_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_1_request).word0)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_1_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_1_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_1_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_1_reply).word0)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_1_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_1_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_1_request__msgnum, ((_binding->tx_union).fsb_payload64_1_request).word0);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_1_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_1_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_1_reply__msgnum, ((_binding->tx_union).fsb_payload64_1_reply).word0);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_1_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_2_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_2_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_2_request).word0)) << 16), ((_binding->tx_union).fsb_payload32_2_request).word1);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_2_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_2_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_2_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_2_reply).word0)) << 16), ((_binding->tx_union).fsb_payload32_2_reply).word1);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_2_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_2_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_2_request__msgnum, ((_binding->tx_union).fsb_payload64_2_request).word0, ((_binding->tx_union).fsb_payload64_2_request).word1);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_2_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_2_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_2_reply__msgnum, ((_binding->tx_union).fsb_payload64_2_reply).word0, ((_binding->tx_union).fsb_payload64_2_reply).word1);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_2_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_4_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_4_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_request).word0)) << 16), (((_binding->tx_union).fsb_payload32_4_request).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_request).word2)) << 32), ((_binding->tx_union).fsb_payload32_4_request).word3);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_4_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_4_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send3(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_4_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_reply).word0)) << 16), (((_binding->tx_union).fsb_payload32_4_reply).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_reply).word2)) << 32), ((_binding->tx_union).fsb_payload32_4_reply).word3);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_4_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_4_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_4_request__msgnum, ((_binding->tx_union).fsb_payload64_4_request).word0, ((_binding->tx_union).fsb_payload64_4_request).word1, ((_binding->tx_union).fsb_payload64_4_request).word2, ((_binding->tx_union).fsb_payload64_4_request).word3);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_4_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_4_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_4_reply__msgnum, ((_binding->tx_union).fsb_payload64_4_reply).word0, ((_binding->tx_union).fsb_payload64_4_reply).word1, ((_binding->tx_union).fsb_payload64_4_reply).word2, ((_binding->tx_union).fsb_payload64_4_reply).word3);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_4_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_8_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_8_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word0)) << 16), (((_binding->tx_union).fsb_payload32_8_request).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word2)) << 32), (((_binding->tx_union).fsb_payload32_8_request).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word4)) << 32), (((_binding->tx_union).fsb_payload32_8_request).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word6)) << 32), ((_binding->tx_union).fsb_payload32_8_request).word7);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_8_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_8_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send5(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_8_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word0)) << 16), (((_binding->tx_union).fsb_payload32_8_reply).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word2)) << 32), (((_binding->tx_union).fsb_payload32_8_reply).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word4)) << 32), (((_binding->tx_union).fsb_payload32_8_reply).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word6)) << 32), ((_binding->tx_union).fsb_payload32_8_reply).word7);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_8_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_8_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send9(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_8_request__msgnum, ((_binding->tx_union).fsb_payload64_8_request).word0, ((_binding->tx_union).fsb_payload64_8_request).word1, ((_binding->tx_union).fsb_payload64_8_request).word2, ((_binding->tx_union).fsb_payload64_8_request).word3, ((_binding->tx_union).fsb_payload64_8_request).word4, ((_binding->tx_union).fsb_payload64_8_request).word5, ((_binding->tx_union).fsb_payload64_8_request).word6, ((_binding->tx_union).fsb_payload64_8_request).word7);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_8_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_8_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send9(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload64_8_reply__msgnum, ((_binding->tx_union).fsb_payload64_8_reply).word0, ((_binding->tx_union).fsb_payload64_8_reply).word1, ((_binding->tx_union).fsb_payload64_8_reply).word2, ((_binding->tx_union).fsb_payload64_8_reply).word3, ((_binding->tx_union).fsb_payload64_8_reply).word4, ((_binding->tx_union).fsb_payload64_8_reply).word5, ((_binding->tx_union).fsb_payload64_8_reply).word6, ((_binding->tx_union).fsb_payload64_8_reply).word7);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_8_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_16_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send9(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_16_request__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word0)) << 16), (((_binding->tx_union).fsb_payload32_16_request).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word2)) << 32), (((_binding->tx_union).fsb_payload32_16_request).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word4)) << 32), (((_binding->tx_union).fsb_payload32_16_request).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word6)) << 32), (((_binding->tx_union).fsb_payload32_16_request).word7) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word8)) << 32), (((_binding->tx_union).fsb_payload32_16_request).word9) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word10)) << 32), (((_binding->tx_union).fsb_payload32_16_request).word11) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word12)) << 32), (((_binding->tx_union).fsb_payload32_16_request).word13) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word14)) << 32), ((_binding->tx_union).fsb_payload32_16_request).word15);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_16_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload32_16_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send9(&(b->chan), b->flags, NULL_CAP, bench_fsb_payload32_16_reply__msgnum | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word0)) << 16), (((_binding->tx_union).fsb_payload32_16_reply).word1) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word2)) << 32), (((_binding->tx_union).fsb_payload32_16_reply).word3) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word4)) << 32), (((_binding->tx_union).fsb_payload32_16_reply).word5) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word6)) << 32), (((_binding->tx_union).fsb_payload32_16_reply).word7) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word8)) << 32), (((_binding->tx_union).fsb_payload32_16_reply).word9) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word10)) << 32), (((_binding->tx_union).fsb_payload32_16_reply).word11) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word12)) << 32), (((_binding->tx_union).fsb_payload32_16_reply).word13) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word14)) << 32), ((_binding->tx_union).fsb_payload32_16_reply).word15);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload32_16_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_16_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send10(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, bench_fsb_payload64_16_request__msgnum, ((_binding->tx_union).fsb_payload64_16_request).word0, ((_binding->tx_union).fsb_payload64_16_request).word1, ((_binding->tx_union).fsb_payload64_16_request).word2, ((_binding->tx_union).fsb_payload64_16_request).word3, ((_binding->tx_union).fsb_payload64_16_request).word4, ((_binding->tx_union).fsb_payload64_16_request).word5, ((_binding->tx_union).fsb_payload64_16_request).word6, ((_binding->tx_union).fsb_payload64_16_request).word7, ((_binding->tx_union).fsb_payload64_16_request).word8);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send7(&(b->chan), b->flags, NULL_CAP, ((_binding->tx_union).fsb_payload64_16_request).word9, ((_binding->tx_union).fsb_payload64_16_request).word10, ((_binding->tx_union).fsb_payload64_16_request).word11, ((_binding->tx_union).fsb_payload64_16_request).word12, ((_binding->tx_union).fsb_payload64_16_request).word13, ((_binding->tx_union).fsb_payload64_16_request).word14, ((_binding->tx_union).fsb_payload64_16_request).word15);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_16_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_fsb_payload64_16_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send10(&(b->chan), (b->flags) & (~LMP_FLAG_SYNC), NULL_CAP, bench_fsb_payload64_16_reply__msgnum, ((_binding->tx_union).fsb_payload64_16_reply).word0, ((_binding->tx_union).fsb_payload64_16_reply).word1, ((_binding->tx_union).fsb_payload64_16_reply).word2, ((_binding->tx_union).fsb_payload64_16_reply).word3, ((_binding->tx_union).fsb_payload64_16_reply).word4, ((_binding->tx_union).fsb_payload64_16_reply).word5, ((_binding->tx_union).fsb_payload64_16_reply).word6, ((_binding->tx_union).fsb_payload64_16_reply).word7, ((_binding->tx_union).fsb_payload64_16_reply).word8);
        if (err_is_ok(err)) {
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        } else {
            break;
        }
    case 1:
        err = lmp_chan_send7(&(b->chan), b->flags, NULL_CAP, ((_binding->tx_union).fsb_payload64_16_reply).word9, ((_binding->tx_union).fsb_payload64_16_reply).word10, ((_binding->tx_union).fsb_payload64_16_reply).word11, ((_binding->tx_union).fsb_payload64_16_reply).word12, ((_binding->tx_union).fsb_payload64_16_reply).word13, ((_binding->tx_union).fsb_payload64_16_reply).word14, ((_binding->tx_union).fsb_payload64_16_reply).word15);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_fsb_payload64_16_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_lrpc_init__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_lrpc_init__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_lrpc_init__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_lrpc_init_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_lrpc_init_reply__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_lrpc_init_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_lrpc_bench_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send2(&(b->chan), b->flags, NULL_CAP, bench_lrpc_bench_reply__msgnum, ((_binding->tx_union).lrpc_bench_reply).value);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_lrpc_bench_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_shmc_init_request__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_shmc_init_request__msgnum | (((uintptr_t )(((_binding->tx_union).shmc_init_request).coreid)) << 16));
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_shmc_init_request__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_shmc_init_reply__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, ((_binding->tx_union).shmc_init_reply).cap, bench_shmc_init_reply__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_shmc_init_reply__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_shmc_start__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_shmc_start__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_shmc_start__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}

static  void bench_shmc_done__lmp_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        err = lmp_chan_send1(&(b->chan), b->flags, NULL_CAP, bench_shmc_done__msgnum);
        if (err_is_ok(err)) {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        } else {
            break;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    if (lmp_err_is_transient(err)) {
        // Construct retry closure and register it
        struct event_closure retry_closure = (struct event_closure){  .handler = bench_shmc_done__lmp_send_handler,  .arg = arg };
        err = lmp_chan_register_send(&(b->chan), _binding->waitset, retry_closure);
        assert(err_is_ok(err));
    } else {
        // Report error to user
        (_binding->error_handler)(_binding, err);
        _binding->tx_msgnum = 0;
        flounder_support_trigger_chan(&(_binding->register_chanstate));
        flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
    }
}


/*
 * Message sender functions
 */
static  errval_t bench_init_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).init_request).coreid = coreid;
    FL_DEBUG("lmp TX bench.init_request\n");
    
    // try to send!
    bench_init_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_init_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.init_reply\n");
    
    // try to send!
    bench_init_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_token_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_token_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.token_request\n");
    
    // try to send!
    bench_token_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_token_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_token_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.token_reply\n");
    
    // try to send!
    bench_token_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_init_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_busy_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.busy_init_request\n");
    
    // try to send!
    bench_busy_init_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_init_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_busy_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.busy_init_reply\n");
    
    // try to send!
    bench_busy_init_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_ping__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_busy_ping__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.busy_ping\n");
    
    // try to send!
    bench_busy_ping__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_ump_init_msg__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_ump_init_msg__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).ump_init_msg).coreid = coreid;
    FL_DEBUG("lmp TX bench.ump_init_msg\n");
    
    // try to send!
    bench_ump_init_msg__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_init_msg__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_init_msg__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_init_msg).coreid = coreid;
    FL_DEBUG("lmp TX bench.fsb_init_msg\n");
    
    // try to send!
    bench_fsb_init_msg__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_empty_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_empty_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.fsb_empty_request\n");
    
    // try to send!
    bench_fsb_empty_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_empty_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_empty_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.fsb_empty_reply\n");
    
    // try to send!
    bench_fsb_empty_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_buffer_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, const uint8_t *buf, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_buffer_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_buffer_request).buf = ((uint8_t *)(buf));
    ((_binding->tx_union).fsb_buffer_request).size = size;
    FL_DEBUG("lmp TX bench.fsb_buffer_request\n");
    
    // try to send!
    bench_fsb_buffer_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_buffer_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, const uint8_t *buf, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_buffer_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_buffer_reply).buf = ((uint8_t *)(buf));
    ((_binding->tx_union).fsb_buffer_reply).size = size;
    FL_DEBUG("lmp TX bench.fsb_buffer_reply\n");
    
    // try to send!
    bench_fsb_buffer_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload_request).word0 = word0;
    ((_binding->tx_union).fsb_payload_request).word1 = word1;
    ((_binding->tx_union).fsb_payload_request).word2 = word2;
    ((_binding->tx_union).fsb_payload_request).word3 = word3;
    FL_DEBUG("lmp TX bench.fsb_payload_request\n");
    
    // try to send!
    bench_fsb_payload_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload_reply).word3 = word3;
    FL_DEBUG("lmp TX bench.fsb_payload_reply\n");
    
    // try to send!
    bench_fsb_payload_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload1_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload1_request).word0 = word0;
    FL_DEBUG("lmp TX bench.fsb_payload1_request\n");
    
    // try to send!
    bench_fsb_payload1_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload1_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload1_reply).word0 = word0;
    FL_DEBUG("lmp TX bench.fsb_payload1_reply\n");
    
    // try to send!
    bench_fsb_payload1_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload2_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload2_request).word1 = word1;
    FL_DEBUG("lmp TX bench.fsb_payload2_request\n");
    
    // try to send!
    bench_fsb_payload2_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload2_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload2_reply).word1 = word1;
    FL_DEBUG("lmp TX bench.fsb_payload2_reply\n");
    
    // try to send!
    bench_fsb_payload2_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload8_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload8_request).word7 = word7;
    FL_DEBUG("lmp TX bench.fsb_payload8_request\n");
    
    // try to send!
    bench_fsb_payload8_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload8_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload8_reply).word7 = word7;
    FL_DEBUG("lmp TX bench.fsb_payload8_reply\n");
    
    // try to send!
    bench_fsb_payload8_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload16_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload16_request).word15 = word15;
    FL_DEBUG("lmp TX bench.fsb_payload16_request\n");
    
    // try to send!
    bench_fsb_payload16_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload16_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload16_reply).word15 = word15;
    FL_DEBUG("lmp TX bench.fsb_payload16_reply\n");
    
    // try to send!
    bench_fsb_payload16_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_1_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_1_request).word0 = word0;
    FL_DEBUG("lmp TX bench.fsb_payload32_1_request\n");
    
    // try to send!
    bench_fsb_payload32_1_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_1_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_1_reply).word0 = word0;
    FL_DEBUG("lmp TX bench.fsb_payload32_1_reply\n");
    
    // try to send!
    bench_fsb_payload32_1_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_1_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_1_request).word0 = word0;
    FL_DEBUG("lmp TX bench.fsb_payload64_1_request\n");
    
    // try to send!
    bench_fsb_payload64_1_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_1_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_1_reply).word0 = word0;
    FL_DEBUG("lmp TX bench.fsb_payload64_1_reply\n");
    
    // try to send!
    bench_fsb_payload64_1_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_2_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_2_request).word1 = word1;
    FL_DEBUG("lmp TX bench.fsb_payload32_2_request\n");
    
    // try to send!
    bench_fsb_payload32_2_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_2_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_2_reply).word1 = word1;
    FL_DEBUG("lmp TX bench.fsb_payload32_2_reply\n");
    
    // try to send!
    bench_fsb_payload32_2_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_2_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_2_request).word1 = word1;
    FL_DEBUG("lmp TX bench.fsb_payload64_2_request\n");
    
    // try to send!
    bench_fsb_payload64_2_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_2_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_2_reply).word1 = word1;
    FL_DEBUG("lmp TX bench.fsb_payload64_2_reply\n");
    
    // try to send!
    bench_fsb_payload64_2_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_4_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_4_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_4_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_4_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_4_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_4_request).word3 = word3;
    FL_DEBUG("lmp TX bench.fsb_payload32_4_request\n");
    
    // try to send!
    bench_fsb_payload32_4_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_4_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_4_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_4_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_4_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_4_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_4_reply).word3 = word3;
    FL_DEBUG("lmp TX bench.fsb_payload32_4_reply\n");
    
    // try to send!
    bench_fsb_payload32_4_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_4_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_4_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_4_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_4_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_4_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_4_request).word3 = word3;
    FL_DEBUG("lmp TX bench.fsb_payload64_4_request\n");
    
    // try to send!
    bench_fsb_payload64_4_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_4_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_4_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_4_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_4_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_4_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_4_reply).word3 = word3;
    FL_DEBUG("lmp TX bench.fsb_payload64_4_reply\n");
    
    // try to send!
    bench_fsb_payload64_4_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_8_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload32_8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload32_8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload32_8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload32_8_request).word7 = word7;
    FL_DEBUG("lmp TX bench.fsb_payload32_8_request\n");
    
    // try to send!
    bench_fsb_payload32_8_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_8_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload32_8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload32_8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload32_8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload32_8_reply).word7 = word7;
    FL_DEBUG("lmp TX bench.fsb_payload32_8_reply\n");
    
    // try to send!
    bench_fsb_payload32_8_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_8_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload64_8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload64_8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload64_8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload64_8_request).word7 = word7;
    FL_DEBUG("lmp TX bench.fsb_payload64_8_request\n");
    
    // try to send!
    bench_fsb_payload64_8_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_8_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload64_8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload64_8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload64_8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload64_8_reply).word7 = word7;
    FL_DEBUG("lmp TX bench.fsb_payload64_8_reply\n");
    
    // try to send!
    bench_fsb_payload64_8_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_16_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload32_16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload32_16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload32_16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload32_16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload32_16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload32_16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload32_16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload32_16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload32_16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload32_16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload32_16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload32_16_request).word15 = word15;
    FL_DEBUG("lmp TX bench.fsb_payload32_16_request\n");
    
    // try to send!
    bench_fsb_payload32_16_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_16_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload32_16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload32_16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload32_16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload32_16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload32_16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload32_16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload32_16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload32_16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload32_16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload32_16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload32_16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload32_16_reply).word15 = word15;
    FL_DEBUG("lmp TX bench.fsb_payload32_16_reply\n");
    
    // try to send!
    bench_fsb_payload32_16_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_16_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7, int64_t word8, int64_t word9, int64_t word10, int64_t word11, int64_t word12, int64_t word13, int64_t word14, int64_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload64_16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload64_16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload64_16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload64_16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload64_16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload64_16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload64_16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload64_16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload64_16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload64_16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload64_16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload64_16_request).word15 = word15;
    FL_DEBUG("lmp TX bench.fsb_payload64_16_request\n");
    
    // try to send!
    bench_fsb_payload64_16_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_16_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7, int64_t word8, int64_t word9, int64_t word10, int64_t word11, int64_t word12, int64_t word13, int64_t word14, int64_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload64_16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload64_16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload64_16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload64_16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload64_16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload64_16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload64_16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload64_16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload64_16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload64_16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload64_16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload64_16_reply).word15 = word15;
    FL_DEBUG("lmp TX bench.fsb_payload64_16_reply\n");
    
    // try to send!
    bench_fsb_payload64_16_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_init__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_lrpc_init__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.lrpc_init\n");
    
    // try to send!
    bench_lrpc_init__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_init_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_lrpc_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.lrpc_init_reply\n");
    
    // try to send!
    bench_lrpc_init_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_bench_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, uint64_t value)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_lrpc_bench_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).lrpc_bench_reply).value = value;
    FL_DEBUG("lmp TX bench.lrpc_bench_reply\n");
    
    // try to send!
    bench_lrpc_bench_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_init_request__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).shmc_init_request).coreid = coreid;
    FL_DEBUG("lmp TX bench.shmc_init_request\n");
    
    // try to send!
    bench_shmc_init_request__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_init_reply__lmp_send(struct bench_binding *_binding, struct event_closure _continuation, struct capref cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).shmc_init_reply).cap = cap;
    FL_DEBUG("lmp TX bench.shmc_init_reply\n");
    
    // try to send!
    bench_shmc_init_reply__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_start__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_start__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.shmc_start\n");
    
    // try to send!
    bench_shmc_start__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_done__lmp_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_done__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("lmp TX bench.shmc_done\n");
    
    // try to send!
    bench_shmc_done__lmp_send_handler(_binding);
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct bench_tx_vtbl bench_lmp_tx_vtbl = {
    .init_request = bench_init_request__lmp_send,
    .init_reply = bench_init_reply__lmp_send,
    .token_request = bench_token_request__lmp_send,
    .token_reply = bench_token_reply__lmp_send,
    .busy_init_request = bench_busy_init_request__lmp_send,
    .busy_init_reply = bench_busy_init_reply__lmp_send,
    .busy_ping = bench_busy_ping__lmp_send,
    .ump_init_msg = bench_ump_init_msg__lmp_send,
    .fsb_init_msg = bench_fsb_init_msg__lmp_send,
    .fsb_empty_request = bench_fsb_empty_request__lmp_send,
    .fsb_empty_reply = bench_fsb_empty_reply__lmp_send,
    .fsb_buffer_request = bench_fsb_buffer_request__lmp_send,
    .fsb_buffer_reply = bench_fsb_buffer_reply__lmp_send,
    .fsb_payload_request = bench_fsb_payload_request__lmp_send,
    .fsb_payload_reply = bench_fsb_payload_reply__lmp_send,
    .fsb_payload1_request = bench_fsb_payload1_request__lmp_send,
    .fsb_payload1_reply = bench_fsb_payload1_reply__lmp_send,
    .fsb_payload2_request = bench_fsb_payload2_request__lmp_send,
    .fsb_payload2_reply = bench_fsb_payload2_reply__lmp_send,
    .fsb_payload8_request = bench_fsb_payload8_request__lmp_send,
    .fsb_payload8_reply = bench_fsb_payload8_reply__lmp_send,
    .fsb_payload16_request = bench_fsb_payload16_request__lmp_send,
    .fsb_payload16_reply = bench_fsb_payload16_reply__lmp_send,
    .fsb_payload32_1_request = bench_fsb_payload32_1_request__lmp_send,
    .fsb_payload32_1_reply = bench_fsb_payload32_1_reply__lmp_send,
    .fsb_payload64_1_request = bench_fsb_payload64_1_request__lmp_send,
    .fsb_payload64_1_reply = bench_fsb_payload64_1_reply__lmp_send,
    .fsb_payload32_2_request = bench_fsb_payload32_2_request__lmp_send,
    .fsb_payload32_2_reply = bench_fsb_payload32_2_reply__lmp_send,
    .fsb_payload64_2_request = bench_fsb_payload64_2_request__lmp_send,
    .fsb_payload64_2_reply = bench_fsb_payload64_2_reply__lmp_send,
    .fsb_payload32_4_request = bench_fsb_payload32_4_request__lmp_send,
    .fsb_payload32_4_reply = bench_fsb_payload32_4_reply__lmp_send,
    .fsb_payload64_4_request = bench_fsb_payload64_4_request__lmp_send,
    .fsb_payload64_4_reply = bench_fsb_payload64_4_reply__lmp_send,
    .fsb_payload32_8_request = bench_fsb_payload32_8_request__lmp_send,
    .fsb_payload32_8_reply = bench_fsb_payload32_8_reply__lmp_send,
    .fsb_payload64_8_request = bench_fsb_payload64_8_request__lmp_send,
    .fsb_payload64_8_reply = bench_fsb_payload64_8_reply__lmp_send,
    .fsb_payload32_16_request = bench_fsb_payload32_16_request__lmp_send,
    .fsb_payload32_16_reply = bench_fsb_payload32_16_reply__lmp_send,
    .fsb_payload64_16_request = bench_fsb_payload64_16_request__lmp_send,
    .fsb_payload64_16_reply = bench_fsb_payload64_16_reply__lmp_send,
    .lrpc_init = bench_lrpc_init__lmp_send,
    .lrpc_init_reply = bench_lrpc_init_reply__lmp_send,
    .lrpc_bench_reply = bench_lrpc_bench_reply__lmp_send,
    .shmc_init_request = bench_shmc_init_request__lmp_send,
    .shmc_init_reply = bench_shmc_init_reply__lmp_send,
    .shmc_start = bench_shmc_start__lmp_send,
    .shmc_done = bench_shmc_done__lmp_send,
};
/*
 * Receive handler
 */
 void bench_lmp_rx_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_lmp_binding *b = arg;
    errval_t err;
    
    struct lmp_recv_msg msg = LMP_RECV_MSG_INIT;
    struct capref cap;
    struct event_closure recv_closure = (struct event_closure){  .handler = bench_lmp_rx_handler,  .arg = arg };
    
    do {
        // try to retrieve a message from the channel
        err = lmp_chan_recv(&(b->chan), &msg, &cap);
        // check if we succeeded
        if (err_is_fail(err)) {
            if (err_no(err) == LIB_ERR_NO_LMP_MSG) {
                // no message
                break;
            } else {
                // real error
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_CHAN_RECV));
                return;
            }
        }
        
        // allocate a new receive slot if needed
        if (!capref_is_null(cap)) {
            err = lmp_chan_alloc_recv_slot(&(b->chan));
            if (err_is_fail(err)) {
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT));
            }
        }
        
        // is this the start of a new message?
        if ((_binding->rx_msgnum) == 0) {
            // check message length
            if (((msg.buf).msglen) == 0) {
                (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_EMPTY_MSG);
                break;
            }
            // unmarshall message number from first word, set fragment to 0
            _binding->rx_msgnum = (((msg.words)[0]) & 0xffff);
            _binding->rx_msg_fragment = 0;
        }
        
        // switch on message number and fragment number
        switch (_binding->rx_msgnum) {
        case bench_init_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).init_request).coreid = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX bench.init_request\n");
                assert(((_binding->rx_vtbl).init_request) != NULL);
                ((_binding->rx_vtbl).init_request)(_binding, ((_binding->rx_union).init_request).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.init_reply\n");
                assert(((_binding->rx_vtbl).init_reply) != NULL);
                ((_binding->rx_vtbl).init_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_token_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.token_request\n");
                assert(((_binding->rx_vtbl).token_request) != NULL);
                ((_binding->rx_vtbl).token_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_token_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.token_reply\n");
                assert(((_binding->rx_vtbl).token_reply) != NULL);
                ((_binding->rx_vtbl).token_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_busy_init_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.busy_init_request\n");
                assert(((_binding->rx_vtbl).busy_init_request) != NULL);
                ((_binding->rx_vtbl).busy_init_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_busy_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.busy_init_reply\n");
                assert(((_binding->rx_vtbl).busy_init_reply) != NULL);
                ((_binding->rx_vtbl).busy_init_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_busy_ping__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.busy_ping\n");
                assert(((_binding->rx_vtbl).busy_ping) != NULL);
                ((_binding->rx_vtbl).busy_ping)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_ump_init_msg__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).ump_init_msg).coreid = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX bench.ump_init_msg\n");
                assert(((_binding->rx_vtbl).ump_init_msg) != NULL);
                ((_binding->rx_vtbl).ump_init_msg)(_binding, ((_binding->rx_union).ump_init_msg).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_init_msg__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_init_msg).coreid = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX bench.fsb_init_msg\n");
                assert(((_binding->rx_vtbl).fsb_init_msg) != NULL);
                ((_binding->rx_vtbl).fsb_init_msg)(_binding, ((_binding->rx_union).fsb_init_msg).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_empty_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.fsb_empty_request\n");
                assert(((_binding->rx_vtbl).fsb_empty_request) != NULL);
                ((_binding->rx_vtbl).fsb_empty_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_empty_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.fsb_empty_reply\n");
                assert(((_binding->rx_vtbl).fsb_empty_reply) != NULL);
                ((_binding->rx_vtbl).fsb_empty_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_buffer_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).fsb_buffer_request).buf)), &(((_binding->rx_union).fsb_buffer_request).size), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX bench.fsb_buffer_request\n");
                    assert(((_binding->rx_vtbl).fsb_buffer_request) != NULL);
                    ((_binding->rx_vtbl).fsb_buffer_request)(_binding, ((_binding->rx_union).fsb_buffer_request).buf, ((_binding->rx_union).fsb_buffer_request).size);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_buffer_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                err = flounder_stub_lmp_recv_buf(&msg, (void **)(&(((_binding->rx_union).fsb_buffer_reply).buf)), &(((_binding->rx_union).fsb_buffer_reply).size), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("lmp RX bench.fsb_buffer_reply\n");
                    assert(((_binding->rx_vtbl).fsb_buffer_reply) != NULL);
                    ((_binding->rx_vtbl).fsb_buffer_reply)(_binding, ((_binding->rx_union).fsb_buffer_reply).buf, ((_binding->rx_union).fsb_buffer_reply).size);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_request).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_request).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_request).word3 = (((msg.words)[2]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload_request\n");
                assert(((_binding->rx_vtbl).fsb_payload_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload_request)(_binding, ((_binding->rx_union).fsb_payload_request).word0, ((_binding->rx_union).fsb_payload_request).word1, ((_binding->rx_union).fsb_payload_request).word2, ((_binding->rx_union).fsb_payload_request).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_reply).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_reply).word3 = (((msg.words)[2]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload_reply)(_binding, ((_binding->rx_union).fsb_payload_reply).word0, ((_binding->rx_union).fsb_payload_reply).word1, ((_binding->rx_union).fsb_payload_reply).word2, ((_binding->rx_union).fsb_payload_reply).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload1_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload1_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload1_request\n");
                assert(((_binding->rx_vtbl).fsb_payload1_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload1_request)(_binding, ((_binding->rx_union).fsb_payload1_request).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload1_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload1_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload1_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload1_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload1_reply)(_binding, ((_binding->rx_union).fsb_payload1_reply).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload2_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload2_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload2_request).word1 = (((msg.words)[1]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload2_request\n");
                assert(((_binding->rx_vtbl).fsb_payload2_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload2_request)(_binding, ((_binding->rx_union).fsb_payload2_request).word0, ((_binding->rx_union).fsb_payload2_request).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload2_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload2_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload2_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload2_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload2_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload2_reply)(_binding, ((_binding->rx_union).fsb_payload2_reply).word0, ((_binding->rx_union).fsb_payload2_reply).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload8_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload8_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word7 = (((msg.words)[4]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload8_request\n");
                assert(((_binding->rx_vtbl).fsb_payload8_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload8_request)(_binding, ((_binding->rx_union).fsb_payload8_request).word0, ((_binding->rx_union).fsb_payload8_request).word1, ((_binding->rx_union).fsb_payload8_request).word2, ((_binding->rx_union).fsb_payload8_request).word3, ((_binding->rx_union).fsb_payload8_request).word4, ((_binding->rx_union).fsb_payload8_request).word5, ((_binding->rx_union).fsb_payload8_request).word6, ((_binding->rx_union).fsb_payload8_request).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload8_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload8_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word7 = (((msg.words)[4]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload8_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload8_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload8_reply)(_binding, ((_binding->rx_union).fsb_payload8_reply).word0, ((_binding->rx_union).fsb_payload8_reply).word1, ((_binding->rx_union).fsb_payload8_reply).word2, ((_binding->rx_union).fsb_payload8_reply).word3, ((_binding->rx_union).fsb_payload8_reply).word4, ((_binding->rx_union).fsb_payload8_reply).word5, ((_binding->rx_union).fsb_payload8_reply).word6, ((_binding->rx_union).fsb_payload8_reply).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload16_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 9) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload16_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word7 = (((msg.words)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word8 = ((((msg.words)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word9 = (((msg.words)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word10 = ((((msg.words)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word11 = (((msg.words)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word12 = ((((msg.words)[6]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word13 = (((msg.words)[7]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word14 = ((((msg.words)[7]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word15 = (((msg.words)[8]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload16_request\n");
                assert(((_binding->rx_vtbl).fsb_payload16_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload16_request)(_binding, ((_binding->rx_union).fsb_payload16_request).word0, ((_binding->rx_union).fsb_payload16_request).word1, ((_binding->rx_union).fsb_payload16_request).word2, ((_binding->rx_union).fsb_payload16_request).word3, ((_binding->rx_union).fsb_payload16_request).word4, ((_binding->rx_union).fsb_payload16_request).word5, ((_binding->rx_union).fsb_payload16_request).word6, ((_binding->rx_union).fsb_payload16_request).word7, ((_binding->rx_union).fsb_payload16_request).word8, ((_binding->rx_union).fsb_payload16_request).word9, ((_binding->rx_union).fsb_payload16_request).word10, ((_binding->rx_union).fsb_payload16_request).word11, ((_binding->rx_union).fsb_payload16_request).word12, ((_binding->rx_union).fsb_payload16_request).word13, ((_binding->rx_union).fsb_payload16_request).word14, ((_binding->rx_union).fsb_payload16_request).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload16_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 9) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload16_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word7 = (((msg.words)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word8 = ((((msg.words)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word9 = (((msg.words)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word10 = ((((msg.words)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word11 = (((msg.words)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word12 = ((((msg.words)[6]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word13 = (((msg.words)[7]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word14 = ((((msg.words)[7]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word15 = (((msg.words)[8]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload16_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload16_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload16_reply)(_binding, ((_binding->rx_union).fsb_payload16_reply).word0, ((_binding->rx_union).fsb_payload16_reply).word1, ((_binding->rx_union).fsb_payload16_reply).word2, ((_binding->rx_union).fsb_payload16_reply).word3, ((_binding->rx_union).fsb_payload16_reply).word4, ((_binding->rx_union).fsb_payload16_reply).word5, ((_binding->rx_union).fsb_payload16_reply).word6, ((_binding->rx_union).fsb_payload16_reply).word7, ((_binding->rx_union).fsb_payload16_reply).word8, ((_binding->rx_union).fsb_payload16_reply).word9, ((_binding->rx_union).fsb_payload16_reply).word10, ((_binding->rx_union).fsb_payload16_reply).word11, ((_binding->rx_union).fsb_payload16_reply).word12, ((_binding->rx_union).fsb_payload16_reply).word13, ((_binding->rx_union).fsb_payload16_reply).word14, ((_binding->rx_union).fsb_payload16_reply).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_1_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_1_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_1_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_1_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_1_request)(_binding, ((_binding->rx_union).fsb_payload32_1_request).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_1_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_1_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_1_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_1_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_1_reply)(_binding, ((_binding->rx_union).fsb_payload32_1_reply).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_1_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_1_request).word0 = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_1_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_1_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_1_request)(_binding, ((_binding->rx_union).fsb_payload64_1_request).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_1_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_1_reply).word0 = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_1_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_1_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_1_reply)(_binding, ((_binding->rx_union).fsb_payload64_1_reply).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_2_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_2_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_2_request).word1 = (((msg.words)[1]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_2_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_2_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_2_request)(_binding, ((_binding->rx_union).fsb_payload32_2_request).word0, ((_binding->rx_union).fsb_payload32_2_request).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_2_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_2_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_2_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_2_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_2_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_2_reply)(_binding, ((_binding->rx_union).fsb_payload32_2_reply).word0, ((_binding->rx_union).fsb_payload32_2_reply).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_2_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_2_request).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_2_request).word1 = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_2_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_2_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_2_request)(_binding, ((_binding->rx_union).fsb_payload64_2_request).word0, ((_binding->rx_union).fsb_payload64_2_request).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_2_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_2_reply).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_2_reply).word1 = ((msg.words)[2]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_2_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_2_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_2_reply)(_binding, ((_binding->rx_union).fsb_payload64_2_reply).word0, ((_binding->rx_union).fsb_payload64_2_reply).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_4_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_4_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_request).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_request).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_request).word3 = (((msg.words)[2]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_4_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_4_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_4_request)(_binding, ((_binding->rx_union).fsb_payload32_4_request).word0, ((_binding->rx_union).fsb_payload32_4_request).word1, ((_binding->rx_union).fsb_payload32_4_request).word2, ((_binding->rx_union).fsb_payload32_4_request).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_4_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_4_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_reply).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_reply).word3 = (((msg.words)[2]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_4_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_4_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_4_reply)(_binding, ((_binding->rx_union).fsb_payload32_4_reply).word0, ((_binding->rx_union).fsb_payload32_4_reply).word1, ((_binding->rx_union).fsb_payload32_4_reply).word2, ((_binding->rx_union).fsb_payload32_4_reply).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_4_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_4_request).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_4_request).word1 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_4_request).word2 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_4_request).word3 = ((msg.words)[4]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_4_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_4_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_4_request)(_binding, ((_binding->rx_union).fsb_payload64_4_request).word0, ((_binding->rx_union).fsb_payload64_4_request).word1, ((_binding->rx_union).fsb_payload64_4_request).word2, ((_binding->rx_union).fsb_payload64_4_request).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_4_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_4_reply).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_4_reply).word1 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_4_reply).word2 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_4_reply).word3 = ((msg.words)[4]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_4_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_4_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_4_reply)(_binding, ((_binding->rx_union).fsb_payload64_4_reply).word0, ((_binding->rx_union).fsb_payload64_4_reply).word1, ((_binding->rx_union).fsb_payload64_4_reply).word2, ((_binding->rx_union).fsb_payload64_4_reply).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_8_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_8_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word7 = (((msg.words)[4]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_8_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_8_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_8_request)(_binding, ((_binding->rx_union).fsb_payload32_8_request).word0, ((_binding->rx_union).fsb_payload32_8_request).word1, ((_binding->rx_union).fsb_payload32_8_request).word2, ((_binding->rx_union).fsb_payload32_8_request).word3, ((_binding->rx_union).fsb_payload32_8_request).word4, ((_binding->rx_union).fsb_payload32_8_request).word5, ((_binding->rx_union).fsb_payload32_8_request).word6, ((_binding->rx_union).fsb_payload32_8_request).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_8_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 5) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_8_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word7 = (((msg.words)[4]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_8_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_8_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_8_reply)(_binding, ((_binding->rx_union).fsb_payload32_8_reply).word0, ((_binding->rx_union).fsb_payload32_8_reply).word1, ((_binding->rx_union).fsb_payload32_8_reply).word2, ((_binding->rx_union).fsb_payload32_8_reply).word3, ((_binding->rx_union).fsb_payload32_8_reply).word4, ((_binding->rx_union).fsb_payload32_8_reply).word5, ((_binding->rx_union).fsb_payload32_8_reply).word6, ((_binding->rx_union).fsb_payload32_8_reply).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_8_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 9) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_8_request).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_8_request).word1 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_8_request).word2 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_8_request).word3 = ((msg.words)[4]);
                ((_binding->rx_union).fsb_payload64_8_request).word4 = ((msg.words)[5]);
                ((_binding->rx_union).fsb_payload64_8_request).word5 = ((msg.words)[6]);
                ((_binding->rx_union).fsb_payload64_8_request).word6 = ((msg.words)[7]);
                ((_binding->rx_union).fsb_payload64_8_request).word7 = ((msg.words)[8]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_8_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_8_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_8_request)(_binding, ((_binding->rx_union).fsb_payload64_8_request).word0, ((_binding->rx_union).fsb_payload64_8_request).word1, ((_binding->rx_union).fsb_payload64_8_request).word2, ((_binding->rx_union).fsb_payload64_8_request).word3, ((_binding->rx_union).fsb_payload64_8_request).word4, ((_binding->rx_union).fsb_payload64_8_request).word5, ((_binding->rx_union).fsb_payload64_8_request).word6, ((_binding->rx_union).fsb_payload64_8_request).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_8_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 9) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_8_reply).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_8_reply).word1 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_8_reply).word2 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_8_reply).word3 = ((msg.words)[4]);
                ((_binding->rx_union).fsb_payload64_8_reply).word4 = ((msg.words)[5]);
                ((_binding->rx_union).fsb_payload64_8_reply).word5 = ((msg.words)[6]);
                ((_binding->rx_union).fsb_payload64_8_reply).word6 = ((msg.words)[7]);
                ((_binding->rx_union).fsb_payload64_8_reply).word7 = ((msg.words)[8]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_8_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_8_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_8_reply)(_binding, ((_binding->rx_union).fsb_payload64_8_reply).word0, ((_binding->rx_union).fsb_payload64_8_reply).word1, ((_binding->rx_union).fsb_payload64_8_reply).word2, ((_binding->rx_union).fsb_payload64_8_reply).word3, ((_binding->rx_union).fsb_payload64_8_reply).word4, ((_binding->rx_union).fsb_payload64_8_reply).word5, ((_binding->rx_union).fsb_payload64_8_reply).word6, ((_binding->rx_union).fsb_payload64_8_reply).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_16_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 9) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_16_request).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word7 = (((msg.words)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word8 = ((((msg.words)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word9 = (((msg.words)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word10 = ((((msg.words)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word11 = (((msg.words)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word12 = ((((msg.words)[6]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word13 = (((msg.words)[7]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word14 = ((((msg.words)[7]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word15 = (((msg.words)[8]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_16_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_16_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_16_request)(_binding, ((_binding->rx_union).fsb_payload32_16_request).word0, ((_binding->rx_union).fsb_payload32_16_request).word1, ((_binding->rx_union).fsb_payload32_16_request).word2, ((_binding->rx_union).fsb_payload32_16_request).word3, ((_binding->rx_union).fsb_payload32_16_request).word4, ((_binding->rx_union).fsb_payload32_16_request).word5, ((_binding->rx_union).fsb_payload32_16_request).word6, ((_binding->rx_union).fsb_payload32_16_request).word7, ((_binding->rx_union).fsb_payload32_16_request).word8, ((_binding->rx_union).fsb_payload32_16_request).word9, ((_binding->rx_union).fsb_payload32_16_request).word10, ((_binding->rx_union).fsb_payload32_16_request).word11, ((_binding->rx_union).fsb_payload32_16_request).word12, ((_binding->rx_union).fsb_payload32_16_request).word13, ((_binding->rx_union).fsb_payload32_16_request).word14, ((_binding->rx_union).fsb_payload32_16_request).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_16_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 9) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload32_16_reply).word0 = ((((msg.words)[0]) >> 16) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word1 = (((msg.words)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word2 = ((((msg.words)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word3 = (((msg.words)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word4 = ((((msg.words)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word5 = (((msg.words)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word6 = ((((msg.words)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word7 = (((msg.words)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word8 = ((((msg.words)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word9 = (((msg.words)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word10 = ((((msg.words)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word11 = (((msg.words)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word12 = ((((msg.words)[6]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word13 = (((msg.words)[7]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word14 = ((((msg.words)[7]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word15 = (((msg.words)[8]) & 0xffffffff);
                
                FL_DEBUG("lmp RX bench.fsb_payload32_16_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_16_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_16_reply)(_binding, ((_binding->rx_union).fsb_payload32_16_reply).word0, ((_binding->rx_union).fsb_payload32_16_reply).word1, ((_binding->rx_union).fsb_payload32_16_reply).word2, ((_binding->rx_union).fsb_payload32_16_reply).word3, ((_binding->rx_union).fsb_payload32_16_reply).word4, ((_binding->rx_union).fsb_payload32_16_reply).word5, ((_binding->rx_union).fsb_payload32_16_reply).word6, ((_binding->rx_union).fsb_payload32_16_reply).word7, ((_binding->rx_union).fsb_payload32_16_reply).word8, ((_binding->rx_union).fsb_payload32_16_reply).word9, ((_binding->rx_union).fsb_payload32_16_reply).word10, ((_binding->rx_union).fsb_payload32_16_reply).word11, ((_binding->rx_union).fsb_payload32_16_reply).word12, ((_binding->rx_union).fsb_payload32_16_reply).word13, ((_binding->rx_union).fsb_payload32_16_reply).word14, ((_binding->rx_union).fsb_payload32_16_reply).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_16_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 10) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_16_request).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_16_request).word1 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_16_request).word2 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_16_request).word3 = ((msg.words)[4]);
                ((_binding->rx_union).fsb_payload64_16_request).word4 = ((msg.words)[5]);
                ((_binding->rx_union).fsb_payload64_16_request).word5 = ((msg.words)[6]);
                ((_binding->rx_union).fsb_payload64_16_request).word6 = ((msg.words)[7]);
                ((_binding->rx_union).fsb_payload64_16_request).word7 = ((msg.words)[8]);
                ((_binding->rx_union).fsb_payload64_16_request).word8 = ((msg.words)[9]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_16_request).word9 = ((msg.words)[0]);
                ((_binding->rx_union).fsb_payload64_16_request).word10 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_16_request).word11 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_16_request).word12 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_16_request).word13 = ((msg.words)[4]);
                ((_binding->rx_union).fsb_payload64_16_request).word14 = ((msg.words)[5]);
                ((_binding->rx_union).fsb_payload64_16_request).word15 = ((msg.words)[6]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_16_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_16_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_16_request)(_binding, ((_binding->rx_union).fsb_payload64_16_request).word0, ((_binding->rx_union).fsb_payload64_16_request).word1, ((_binding->rx_union).fsb_payload64_16_request).word2, ((_binding->rx_union).fsb_payload64_16_request).word3, ((_binding->rx_union).fsb_payload64_16_request).word4, ((_binding->rx_union).fsb_payload64_16_request).word5, ((_binding->rx_union).fsb_payload64_16_request).word6, ((_binding->rx_union).fsb_payload64_16_request).word7, ((_binding->rx_union).fsb_payload64_16_request).word8, ((_binding->rx_union).fsb_payload64_16_request).word9, ((_binding->rx_union).fsb_payload64_16_request).word10, ((_binding->rx_union).fsb_payload64_16_request).word11, ((_binding->rx_union).fsb_payload64_16_request).word12, ((_binding->rx_union).fsb_payload64_16_request).word13, ((_binding->rx_union).fsb_payload64_16_request).word14, ((_binding->rx_union).fsb_payload64_16_request).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_16_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) != 10) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_16_reply).word0 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_16_reply).word1 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_16_reply).word2 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_16_reply).word3 = ((msg.words)[4]);
                ((_binding->rx_union).fsb_payload64_16_reply).word4 = ((msg.words)[5]);
                ((_binding->rx_union).fsb_payload64_16_reply).word5 = ((msg.words)[6]);
                ((_binding->rx_union).fsb_payload64_16_reply).word6 = ((msg.words)[7]);
                ((_binding->rx_union).fsb_payload64_16_reply).word7 = ((msg.words)[8]);
                ((_binding->rx_union).fsb_payload64_16_reply).word8 = ((msg.words)[9]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                // check length
                if (((msg.buf).msglen) != 7) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).fsb_payload64_16_reply).word9 = ((msg.words)[0]);
                ((_binding->rx_union).fsb_payload64_16_reply).word10 = ((msg.words)[1]);
                ((_binding->rx_union).fsb_payload64_16_reply).word11 = ((msg.words)[2]);
                ((_binding->rx_union).fsb_payload64_16_reply).word12 = ((msg.words)[3]);
                ((_binding->rx_union).fsb_payload64_16_reply).word13 = ((msg.words)[4]);
                ((_binding->rx_union).fsb_payload64_16_reply).word14 = ((msg.words)[5]);
                ((_binding->rx_union).fsb_payload64_16_reply).word15 = ((msg.words)[6]);
                
                FL_DEBUG("lmp RX bench.fsb_payload64_16_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_16_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_16_reply)(_binding, ((_binding->rx_union).fsb_payload64_16_reply).word0, ((_binding->rx_union).fsb_payload64_16_reply).word1, ((_binding->rx_union).fsb_payload64_16_reply).word2, ((_binding->rx_union).fsb_payload64_16_reply).word3, ((_binding->rx_union).fsb_payload64_16_reply).word4, ((_binding->rx_union).fsb_payload64_16_reply).word5, ((_binding->rx_union).fsb_payload64_16_reply).word6, ((_binding->rx_union).fsb_payload64_16_reply).word7, ((_binding->rx_union).fsb_payload64_16_reply).word8, ((_binding->rx_union).fsb_payload64_16_reply).word9, ((_binding->rx_union).fsb_payload64_16_reply).word10, ((_binding->rx_union).fsb_payload64_16_reply).word11, ((_binding->rx_union).fsb_payload64_16_reply).word12, ((_binding->rx_union).fsb_payload64_16_reply).word13, ((_binding->rx_union).fsb_payload64_16_reply).word14, ((_binding->rx_union).fsb_payload64_16_reply).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_lrpc_init__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.lrpc_init\n");
                assert(((_binding->rx_vtbl).lrpc_init) != NULL);
                ((_binding->rx_vtbl).lrpc_init)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_lrpc_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.lrpc_init_reply\n");
                assert(((_binding->rx_vtbl).lrpc_init_reply) != NULL);
                ((_binding->rx_vtbl).lrpc_init_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_lrpc_bench_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).lrpc_bench_reply).value = ((msg.words)[1]);
                
                FL_DEBUG("lmp RX bench.lrpc_bench_reply\n");
                assert(((_binding->rx_vtbl).lrpc_bench_reply) != NULL);
                ((_binding->rx_vtbl).lrpc_bench_reply)(_binding, ((_binding->rx_union).lrpc_bench_reply).value);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_init_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).shmc_init_request).coreid = ((((msg.words)[0]) >> 16) & 0xff);
                
                FL_DEBUG("lmp RX bench.shmc_init_request\n");
                assert(((_binding->rx_vtbl).shmc_init_request) != NULL);
                ((_binding->rx_vtbl).shmc_init_request)(_binding, ((_binding->rx_union).shmc_init_request).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                ((_binding->rx_union).shmc_init_reply).cap = cap;
                
                FL_DEBUG("lmp RX bench.shmc_init_reply\n");
                assert(((_binding->rx_vtbl).shmc_init_reply) != NULL);
                ((_binding->rx_vtbl).shmc_init_reply)(_binding, ((_binding->rx_union).shmc_init_reply).cap);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_start__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.shmc_start\n");
                assert(((_binding->rx_vtbl).shmc_start) != NULL);
                ((_binding->rx_vtbl).shmc_start)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_done__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                // check length
                if (((msg.buf).msglen) > 4) {
                    (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_LENGTH);
                    goto out;
                }
                
                
                FL_DEBUG("lmp RX bench.shmc_done\n");
                assert(((_binding->rx_vtbl).shmc_done) != NULL);
                ((_binding->rx_vtbl).shmc_done)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        default:
            (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_MSGNUM);
            goto out;
        }
    } while (err_is_ok(err));
    out:
    // re-register for another receive notification
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, recv_closure);
    assert(err_is_ok(err));
}


/*
 * Control functions
 */
static  bool bench_lmp_can_send(struct bench_binding *b)
{
    return((b->tx_msgnum) == 0);
}

static  errval_t bench_lmp_register_send(struct bench_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(flounder_support_register(ws, &(b->register_chanstate), _continuation, bench_lmp_can_send(b)));
}

static  void bench_lmp_default_error_handler(struct bench_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated bench lmp binding (default handler)");
    abort();
}

static  errval_t bench_lmp_change_waitset(struct bench_binding *_binding, struct waitset *ws)
{
    struct bench_lmp_binding *b = (void *)(_binding);
    
    // Migrate register and TX continuation notifications
    flounder_support_migrate_notify(&(_binding->register_chanstate), ws);
    flounder_support_migrate_notify(&(_binding->tx_cont_chanstate), ws);
    
    // change waitset on binding
    _binding->waitset = ws;
    
    // Migrate send and receive notifications
    lmp_chan_migrate_recv(&(b->chan), ws);
    lmp_chan_migrate_send(&(b->chan), ws);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lmp_control(struct bench_binding *_binding, idc_control_t control)
{
    struct bench_lmp_binding *b = (void *)(_binding);
    
    b->flags = idc_control_to_lmp_flags(control, b->flags);
    
    return(SYS_ERR_OK);
}

/*
 * Functions to initialise/destroy the binding state
 */
 void bench_lmp_init(struct bench_lmp_binding *b, struct waitset *waitset)
{
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = bench_lmp_can_send;
    (b->b).register_send = bench_lmp_register_send;
    (b->b).error_handler = bench_lmp_default_error_handler;
    (b->b).tx_vtbl = bench_lmp_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    lmp_chan_init(&(b->chan));
    (b->b).change_waitset = bench_lmp_change_waitset;
    (b->b).control = bench_lmp_control;
    b->flags = LMP_SEND_FLAGS_DEFAULT;
}

 void bench_lmp_destroy(struct bench_lmp_binding *b)
{
    flounder_support_waitset_chanstate_destroy(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_destroy(&((b->b).tx_cont_chanstate));
    lmp_chan_destroy(&(b->chan));
}


/*
 * Bind function
 */
static  void bench_lmp_bind_continuation(void *st, errval_t err, struct lmp_chan *chan)
{
    struct bench_lmp_binding *b = st;
    
    if (err_is_ok(err)) {
        // allocate a cap receive slot
        err = lmp_chan_alloc_recv_slot(chan);
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
            goto fail;
        }
        
        // register for receive
        err = lmp_chan_register_recv(chan, (b->b).waitset, (struct event_closure){  .handler = bench_lmp_rx_handler,  .arg = b });
        if (err_is_fail(err)) {
            err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
            goto fail;
        }
    } else {
        fail:
        bench_lmp_destroy(b);
    }
    
    ((b->b).bind_cont)((b->b).st, err, &(b->b));
}

 errval_t bench_lmp_bind(struct bench_lmp_binding *b, iref_t iref, bench_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags, size_t lmp_buflen)
{
    errval_t err;
    bench_lmp_init(b, waitset);
    (b->b).st = st;
    (b->b).bind_cont = _continuation;
    err = lmp_chan_bind(&(b->chan), (struct lmp_bind_continuation){  .handler = bench_lmp_bind_continuation,  .st = b }, &((b->b).event_qnode), iref, lmp_buflen);
    if (err_is_fail(err)) {
        bench_lmp_destroy(b);
    }
    return(err);
}


/*
 * Connect callback for export
 */
 errval_t bench_lmp_connect_handler(void *st, size_t buflen_words, struct capref endpoint, struct lmp_chan **retchan)
{
    struct bench_export *e = st;
    errval_t err;
    
    // allocate storage for binding
    struct bench_lmp_binding *b = malloc(sizeof(struct bench_lmp_binding ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    struct bench_binding *_binding = &(b->b);
    bench_lmp_init(b, e->waitset);
    
    // run user's connect handler
    err = ((e->connect_cb)(e->st, _binding));
    if (err_is_fail(err)) {
        // connection refused
        bench_lmp_destroy(b);
        return(err);
    }
    
    // accept the connection and setup the channel
    // FIXME: user policy needed to decide on the size of the message buffer?
    err = lmp_chan_accept(&(b->chan), buflen_words, endpoint);
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_CHAN_ACCEPT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // allocate a cap receive slot
    err = lmp_chan_alloc_recv_slot(&(b->chan));
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_LMP_ALLOC_RECV_SLOT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // register for receive
    err = lmp_chan_register_recv(&(b->chan), _binding->waitset, (struct event_closure){  .handler = bench_lmp_rx_handler,  .arg = b });
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_CHAN_REGISTER_RECV);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    *retchan = (&(b->chan));
    
    return(SYS_ERR_OK);
}

/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: bench
 * INTEFACE FILE: ../if/bench.if
 * INTERFACE DESCRIPTION: The bench Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#ifdef CONFIG_FLOUNDER_BACKEND_UMP

/*
 * Generated Stub for UMP
 */

#include <barrelfish/barrelfish.h>
#include <barrelfish/monitor_client.h>
#include <flounder/flounder_support.h>
#include <flounder/flounder_support_ump.h>
#include <if/bench_defs.h>

/*
 * Send handler function
 */
static  void bench_ump_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_ump_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    volatile struct ump_message *msg;
    struct ump_control ctrl;
    bool tx_notify = false;
    
    // do we need to (and can we) send a cap ack?
    if ((((b->ump_state).capst).tx_cap_ack) && flounder_stub_ump_can_send(&(b->ump_state))) {
        flounder_stub_ump_send_cap_ack(&(b->ump_state));
        ((b->ump_state).capst).tx_cap_ack = false;
        tx_notify = true;
    }
    
    // Switch on current outgoing message number
    switch (_binding->tx_msgnum) {
    case 0:
        break;
    case bench_init_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_init_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).init_request).coreid);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_init_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_init_reply__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_token_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_token_request__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_token_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_token_reply__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_busy_init_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_busy_init_request__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_busy_init_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_busy_init_reply__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_busy_ping__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_busy_ping__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_ump_init_msg__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_ump_init_msg__msgnum);
            (msg->data)[0] = (((_binding->tx_union).ump_init_msg).coreid);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_init_msg__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_init_msg__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_init_msg).coreid);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_empty_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_empty_request__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_empty_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_empty_reply__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_buffer_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            err = flounder_stub_ump_send_buf(&(b->ump_state), bench_fsb_buffer_request__msgnum, ((_binding->tx_union).fsb_buffer_request).buf, ((_binding->tx_union).fsb_buffer_request).size, &(_binding->tx_str_pos));
            if (err_is_fail(err)) {
                if (err_no(err) == FLOUNDER_ERR_BUF_SEND_MORE) {
                    tx_notify = true;
                } else {
                    // Permanent error, report to user
                    (_binding->error_handler)(_binding, err);
                    _binding->tx_msgnum = 0;
                    flounder_support_trigger_chan(&(_binding->register_chanstate));
                    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                }
                break;
            }
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_buffer_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            err = flounder_stub_ump_send_buf(&(b->ump_state), bench_fsb_buffer_reply__msgnum, ((_binding->tx_union).fsb_buffer_reply).buf, ((_binding->tx_union).fsb_buffer_reply).size, &(_binding->tx_str_pos));
            if (err_is_fail(err)) {
                if (err_no(err) == FLOUNDER_ERR_BUF_SEND_MORE) {
                    tx_notify = true;
                } else {
                    // Permanent error, report to user
                    (_binding->error_handler)(_binding, err);
                    _binding->tx_msgnum = 0;
                    flounder_support_trigger_chan(&(_binding->register_chanstate));
                    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                }
                break;
            }
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload_request).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload_request).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload_request).word3)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload_reply).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload_reply).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload_reply).word3)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload1_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload1_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload1_request).word0);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload1_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload1_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload1_reply).word0);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload2_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload2_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload2_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload2_request).word1)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload2_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload2_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload2_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload2_reply).word1)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload8_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload8_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload8_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload8_request).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload8_request).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload8_request).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_request).word7)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload8_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload8_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload8_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload8_reply).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload8_reply).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload8_reply).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload8_reply).word7)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload16_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload16_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload16_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload16_request).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload16_request).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload16_request).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word7)) << 32));
            (msg->data)[4] = ((((_binding->tx_union).fsb_payload16_request).word8) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word9)) << 32));
            (msg->data)[5] = ((((_binding->tx_union).fsb_payload16_request).word10) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word11)) << 32));
            (msg->data)[6] = ((((_binding->tx_union).fsb_payload16_request).word12) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word13)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload16_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload16_request).word14) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_request).word15)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload16_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload16_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload16_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload16_reply).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload16_reply).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload16_reply).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word7)) << 32));
            (msg->data)[4] = ((((_binding->tx_union).fsb_payload16_reply).word8) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word9)) << 32));
            (msg->data)[5] = ((((_binding->tx_union).fsb_payload16_reply).word10) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word11)) << 32));
            (msg->data)[6] = ((((_binding->tx_union).fsb_payload16_reply).word12) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word13)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload16_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload16_reply).word14) | (((uintptr_t )(((_binding->tx_union).fsb_payload16_reply).word15)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_1_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_1_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload32_1_request).word0);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_1_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_1_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload32_1_reply).word0);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_1_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_1_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_1_request).word0);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_1_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_1_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_1_reply).word0);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_2_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_2_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_2_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_2_request).word1)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_2_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_2_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_2_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_2_reply).word1)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_2_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_2_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_2_request).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_2_request).word1);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_2_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_2_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_2_reply).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_2_reply).word1);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_4_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_4_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_4_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_request).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload32_4_request).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_request).word3)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_4_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_4_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_4_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_reply).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload32_4_reply).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_4_reply).word3)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_4_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_4_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_4_request).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_4_request).word1);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_4_request).word2);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_4_request).word3);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_4_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_4_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_4_reply).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_4_reply).word1);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_4_reply).word2);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_4_reply).word3);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_8_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_8_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_8_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload32_8_request).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload32_8_request).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload32_8_request).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_request).word7)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_8_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_8_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_8_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload32_8_reply).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload32_8_reply).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload32_8_reply).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_8_reply).word7)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_8_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_8_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_8_request).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_8_request).word1);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_8_request).word2);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_8_request).word3);
            (msg->data)[4] = (((_binding->tx_union).fsb_payload64_8_request).word4);
            (msg->data)[5] = (((_binding->tx_union).fsb_payload64_8_request).word5);
            (msg->data)[6] = (((_binding->tx_union).fsb_payload64_8_request).word6);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_8_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_8_request).word7);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_8_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_8_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_8_reply).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_8_reply).word1);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_8_reply).word2);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_8_reply).word3);
            (msg->data)[4] = (((_binding->tx_union).fsb_payload64_8_reply).word4);
            (msg->data)[5] = (((_binding->tx_union).fsb_payload64_8_reply).word5);
            (msg->data)[6] = (((_binding->tx_union).fsb_payload64_8_reply).word6);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_8_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_8_reply).word7);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_16_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_16_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_16_request).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload32_16_request).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload32_16_request).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload32_16_request).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word7)) << 32));
            (msg->data)[4] = ((((_binding->tx_union).fsb_payload32_16_request).word8) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word9)) << 32));
            (msg->data)[5] = ((((_binding->tx_union).fsb_payload32_16_request).word10) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word11)) << 32));
            (msg->data)[6] = ((((_binding->tx_union).fsb_payload32_16_request).word12) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word13)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_16_request__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_16_request).word14) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_request).word15)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload32_16_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_16_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_16_reply).word0) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word1)) << 32));
            (msg->data)[1] = ((((_binding->tx_union).fsb_payload32_16_reply).word2) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word3)) << 32));
            (msg->data)[2] = ((((_binding->tx_union).fsb_payload32_16_reply).word4) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word5)) << 32));
            (msg->data)[3] = ((((_binding->tx_union).fsb_payload32_16_reply).word6) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word7)) << 32));
            (msg->data)[4] = ((((_binding->tx_union).fsb_payload32_16_reply).word8) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word9)) << 32));
            (msg->data)[5] = ((((_binding->tx_union).fsb_payload32_16_reply).word10) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word11)) << 32));
            (msg->data)[6] = ((((_binding->tx_union).fsb_payload32_16_reply).word12) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word13)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload32_16_reply__msgnum);
            (msg->data)[0] = ((((_binding->tx_union).fsb_payload32_16_reply).word14) | (((uintptr_t )(((_binding->tx_union).fsb_payload32_16_reply).word15)) << 32));
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 2:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_16_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_16_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_16_request).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_16_request).word1);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_16_request).word2);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_16_request).word3);
            (msg->data)[4] = (((_binding->tx_union).fsb_payload64_16_request).word4);
            (msg->data)[5] = (((_binding->tx_union).fsb_payload64_16_request).word5);
            (msg->data)[6] = (((_binding->tx_union).fsb_payload64_16_request).word6);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_16_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_16_request).word7);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_16_request).word8);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_16_request).word9);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_16_request).word10);
            (msg->data)[4] = (((_binding->tx_union).fsb_payload64_16_request).word11);
            (msg->data)[5] = (((_binding->tx_union).fsb_payload64_16_request).word12);
            (msg->data)[6] = (((_binding->tx_union).fsb_payload64_16_request).word13);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 2:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_16_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_16_request).word14);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_16_request).word15);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 3:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_fsb_payload64_16_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_16_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_16_reply).word0);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_16_reply).word1);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_16_reply).word2);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_16_reply).word3);
            (msg->data)[4] = (((_binding->tx_union).fsb_payload64_16_reply).word4);
            (msg->data)[5] = (((_binding->tx_union).fsb_payload64_16_reply).word5);
            (msg->data)[6] = (((_binding->tx_union).fsb_payload64_16_reply).word6);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 1:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_16_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_16_reply).word7);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_16_reply).word8);
            (msg->data)[2] = (((_binding->tx_union).fsb_payload64_16_reply).word9);
            (msg->data)[3] = (((_binding->tx_union).fsb_payload64_16_reply).word10);
            (msg->data)[4] = (((_binding->tx_union).fsb_payload64_16_reply).word11);
            (msg->data)[5] = (((_binding->tx_union).fsb_payload64_16_reply).word12);
            (msg->data)[6] = (((_binding->tx_union).fsb_payload64_16_reply).word13);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            // fall through to next fragment
        case 2:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_fsb_payload64_16_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).fsb_payload64_16_reply).word14);
            (msg->data)[1] = (((_binding->tx_union).fsb_payload64_16_reply).word15);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 3:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_lrpc_init__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_lrpc_init__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_lrpc_init_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_lrpc_init_reply__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_lrpc_bench_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_lrpc_bench_reply__msgnum);
            (msg->data)[0] = (((_binding->tx_union).lrpc_bench_reply).value);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_shmc_init_request__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_shmc_init_request__msgnum);
            (msg->data)[0] = (((_binding->tx_union).shmc_init_request).coreid);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_shmc_init_reply__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_shmc_init_reply__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            if ((((b->ump_state).capst).tx_capnum) == 2) {
                _binding->tx_msgnum = 0;
                flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
                flounder_support_trigger_chan(&(_binding->register_chanstate));
            }
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 1);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_shmc_start__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_shmc_start__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    case bench_shmc_done__msgnum:
        // Switch on current outgoing message fragment
        switch (_binding->tx_msg_fragment) {
        case 0:
            // check if we can send another message
            if (!flounder_stub_ump_can_send(&(b->ump_state))) {
                tx_notify = true;
                break;
            }
            
            // send the next fragment
            msg = ump_chan_get_next(&((b->ump_state).chan), &ctrl);
            flounder_stub_ump_control_fill(&(b->ump_state), &ctrl, bench_shmc_done__msgnum);
            flounder_stub_ump_barrier();
            (msg->header).control = ctrl;
            (_binding->tx_msg_fragment)++;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        case 1:
            // we've sent all the fragments, we must just be waiting for caps
            assert((((b->ump_state).capst).tx_capnum) <= 0);
            break;
        default:
            assert(!("invalid fragment"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    default:
        assert(!("invalid msgnum"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
    
    // Send a notification if necessary
    if (tx_notify) {
    }
}


/*
 * Capability sender function
 */
static  void bench_ump_cap_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_ump_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    assert(((b->ump_state).capst).rx_cap_ack);
    assert(((b->ump_state).capst).monitor_mutex_held);
    
    // Switch on current outgoing message
    switch (_binding->tx_msgnum) {
    case bench_shmc_init_reply__msgnum:
        // Switch on current outgoing cap
        switch (((b->ump_state).capst).tx_capnum) {
        case 0:
            err = flounder_stub_send_cap(&((b->ump_state).capst), ((b->ump_state).chan).monitor_binding, ((b->ump_state).chan).monitor_id, ((_binding->tx_union).shmc_init_reply).cap, false, bench_ump_cap_send_handler);
            if (err_is_fail(err)) {
                (_binding->error_handler)(_binding, err);
                _binding->tx_msgnum = 0;
                flounder_support_trigger_chan(&(_binding->register_chanstate));
                flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                break;
            }
            break;
        case 1:
            flounder_support_monitor_mutex_unlock(((b->ump_state).chan).monitor_binding);
            if ((_binding->tx_msg_fragment) == 1) {
                _binding->tx_msgnum = 0;
                flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
                flounder_support_trigger_chan(&(_binding->register_chanstate));
            }
            break;
        default:
            assert(!("invalid cap number"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    default:
        assert(!("invalid message number"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
}


/*
 * Receive handler
 */
 void bench_ump_rx_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_ump_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    volatile struct ump_message *msg;
    int msgnum;
    
    while (true) {
        // try to retrieve a message from the channel
        err = ump_chan_recv(&((b->ump_state).chan), &msg);
        // check if we succeeded
        if (err_is_fail(err)) {
            if (err_no(err) == LIB_ERR_NO_UMP_MSG) {
                // no message
                break;
            } else {
                // real error
                (_binding->error_handler)(_binding, err_push(err, LIB_ERR_UMP_CHAN_RECV));
                return;
            }
        }
        
        // process control word
        msgnum = flounder_stub_ump_control_process(&(b->ump_state), (msg->header).control);
        
        // is this a dummy message (ACK)?
        if (msgnum == FL_UMP_ACK) {
            goto loopnext;
        }
        
        // is this a cap ack for a pending tx message
        if (msgnum == FL_UMP_CAP_ACK) {
            assert(!(((b->ump_state).capst).rx_cap_ack));
            ((b->ump_state).capst).rx_cap_ack = true;
            if (((b->ump_state).capst).monitor_mutex_held) {
                bench_ump_cap_send_handler(b);
            }
            goto loopnext;
        }
        
        // is this the start of a new message?
        if ((_binding->rx_msgnum) == 0) {
            _binding->rx_msgnum = msgnum;
            _binding->rx_msg_fragment = 0;
        }
        
        // switch on message number and fragment number
        switch (_binding->rx_msgnum) {
        case bench_init_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).init_request).coreid = (((msg->data)[0]) & 0xff);
                
                FL_DEBUG("ump RX bench.init_request\n");
                assert(((_binding->rx_vtbl).init_request) != NULL);
                ((_binding->rx_vtbl).init_request)(_binding, ((_binding->rx_union).init_request).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.init_reply\n");
                assert(((_binding->rx_vtbl).init_reply) != NULL);
                ((_binding->rx_vtbl).init_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_token_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.token_request\n");
                assert(((_binding->rx_vtbl).token_request) != NULL);
                ((_binding->rx_vtbl).token_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_token_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.token_reply\n");
                assert(((_binding->rx_vtbl).token_reply) != NULL);
                ((_binding->rx_vtbl).token_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_busy_init_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.busy_init_request\n");
                assert(((_binding->rx_vtbl).busy_init_request) != NULL);
                ((_binding->rx_vtbl).busy_init_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_busy_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.busy_init_reply\n");
                assert(((_binding->rx_vtbl).busy_init_reply) != NULL);
                ((_binding->rx_vtbl).busy_init_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_busy_ping__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.busy_ping\n");
                assert(((_binding->rx_vtbl).busy_ping) != NULL);
                ((_binding->rx_vtbl).busy_ping)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_ump_init_msg__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).ump_init_msg).coreid = (((msg->data)[0]) & 0xff);
                
                FL_DEBUG("ump RX bench.ump_init_msg\n");
                assert(((_binding->rx_vtbl).ump_init_msg) != NULL);
                ((_binding->rx_vtbl).ump_init_msg)(_binding, ((_binding->rx_union).ump_init_msg).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_init_msg__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_init_msg).coreid = (((msg->data)[0]) & 0xff);
                
                FL_DEBUG("ump RX bench.fsb_init_msg\n");
                assert(((_binding->rx_vtbl).fsb_init_msg) != NULL);
                ((_binding->rx_vtbl).fsb_init_msg)(_binding, ((_binding->rx_union).fsb_init_msg).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_empty_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.fsb_empty_request\n");
                assert(((_binding->rx_vtbl).fsb_empty_request) != NULL);
                ((_binding->rx_vtbl).fsb_empty_request)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_empty_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.fsb_empty_reply\n");
                assert(((_binding->rx_vtbl).fsb_empty_reply) != NULL);
                ((_binding->rx_vtbl).fsb_empty_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_buffer_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                err = flounder_stub_ump_recv_buf(msg, (void **)(&(((_binding->rx_union).fsb_buffer_request).buf)), &(((_binding->rx_union).fsb_buffer_request).size), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("ump RX bench.fsb_buffer_request\n");
                    assert(((_binding->rx_vtbl).fsb_buffer_request) != NULL);
                    ((_binding->rx_vtbl).fsb_buffer_request)(_binding, ((_binding->rx_union).fsb_buffer_request).buf, ((_binding->rx_union).fsb_buffer_request).size);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_buffer_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                err = flounder_stub_ump_recv_buf(msg, (void **)(&(((_binding->rx_union).fsb_buffer_reply).buf)), &(((_binding->rx_union).fsb_buffer_reply).size), &(_binding->rx_str_pos));
                if (err_is_ok(err)) {
                    FL_DEBUG("ump RX bench.fsb_buffer_reply\n");
                    assert(((_binding->rx_vtbl).fsb_buffer_reply) != NULL);
                    ((_binding->rx_vtbl).fsb_buffer_reply)(_binding, ((_binding->rx_union).fsb_buffer_reply).buf, ((_binding->rx_union).fsb_buffer_reply).size);
                    _binding->rx_msgnum = 0;
                } else {
                    if (err_no(err) != FLOUNDER_ERR_BUF_RECV_MORE) {
                        (_binding->error_handler)(_binding, err);
                    }
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_request).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_request).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload_request\n");
                assert(((_binding->rx_vtbl).fsb_payload_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload_request)(_binding, ((_binding->rx_union).fsb_payload_request).word0, ((_binding->rx_union).fsb_payload_request).word1, ((_binding->rx_union).fsb_payload_request).word2, ((_binding->rx_union).fsb_payload_request).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_reply).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload_reply).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload_reply)(_binding, ((_binding->rx_union).fsb_payload_reply).word0, ((_binding->rx_union).fsb_payload_reply).word1, ((_binding->rx_union).fsb_payload_reply).word2, ((_binding->rx_union).fsb_payload_reply).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload1_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload1_request).word0 = (((msg->data)[0]) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload1_request\n");
                assert(((_binding->rx_vtbl).fsb_payload1_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload1_request)(_binding, ((_binding->rx_union).fsb_payload1_request).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload1_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload1_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload1_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload1_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload1_reply)(_binding, ((_binding->rx_union).fsb_payload1_reply).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload2_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload2_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload2_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload2_request\n");
                assert(((_binding->rx_vtbl).fsb_payload2_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload2_request)(_binding, ((_binding->rx_union).fsb_payload2_request).word0, ((_binding->rx_union).fsb_payload2_request).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload2_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload2_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload2_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload2_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload2_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload2_reply)(_binding, ((_binding->rx_union).fsb_payload2_reply).word0, ((_binding->rx_union).fsb_payload2_reply).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload8_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload8_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_request).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload8_request\n");
                assert(((_binding->rx_vtbl).fsb_payload8_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload8_request)(_binding, ((_binding->rx_union).fsb_payload8_request).word0, ((_binding->rx_union).fsb_payload8_request).word1, ((_binding->rx_union).fsb_payload8_request).word2, ((_binding->rx_union).fsb_payload8_request).word3, ((_binding->rx_union).fsb_payload8_request).word4, ((_binding->rx_union).fsb_payload8_request).word5, ((_binding->rx_union).fsb_payload8_request).word6, ((_binding->rx_union).fsb_payload8_request).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload8_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload8_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload8_reply).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload8_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload8_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload8_reply)(_binding, ((_binding->rx_union).fsb_payload8_reply).word0, ((_binding->rx_union).fsb_payload8_reply).word1, ((_binding->rx_union).fsb_payload8_reply).word2, ((_binding->rx_union).fsb_payload8_reply).word3, ((_binding->rx_union).fsb_payload8_reply).word4, ((_binding->rx_union).fsb_payload8_reply).word5, ((_binding->rx_union).fsb_payload8_reply).word6, ((_binding->rx_union).fsb_payload8_reply).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload16_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload16_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word8 = (((msg->data)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word9 = ((((msg->data)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word10 = (((msg->data)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word11 = ((((msg->data)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word12 = (((msg->data)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word13 = ((((msg->data)[6]) >> 32) & 0xffffffff);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload16_request).word14 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_request).word15 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload16_request\n");
                assert(((_binding->rx_vtbl).fsb_payload16_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload16_request)(_binding, ((_binding->rx_union).fsb_payload16_request).word0, ((_binding->rx_union).fsb_payload16_request).word1, ((_binding->rx_union).fsb_payload16_request).word2, ((_binding->rx_union).fsb_payload16_request).word3, ((_binding->rx_union).fsb_payload16_request).word4, ((_binding->rx_union).fsb_payload16_request).word5, ((_binding->rx_union).fsb_payload16_request).word6, ((_binding->rx_union).fsb_payload16_request).word7, ((_binding->rx_union).fsb_payload16_request).word8, ((_binding->rx_union).fsb_payload16_request).word9, ((_binding->rx_union).fsb_payload16_request).word10, ((_binding->rx_union).fsb_payload16_request).word11, ((_binding->rx_union).fsb_payload16_request).word12, ((_binding->rx_union).fsb_payload16_request).word13, ((_binding->rx_union).fsb_payload16_request).word14, ((_binding->rx_union).fsb_payload16_request).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload16_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload16_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word8 = (((msg->data)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word9 = ((((msg->data)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word10 = (((msg->data)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word11 = ((((msg->data)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word12 = (((msg->data)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word13 = ((((msg->data)[6]) >> 32) & 0xffffffff);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload16_reply).word14 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload16_reply).word15 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload16_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload16_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload16_reply)(_binding, ((_binding->rx_union).fsb_payload16_reply).word0, ((_binding->rx_union).fsb_payload16_reply).word1, ((_binding->rx_union).fsb_payload16_reply).word2, ((_binding->rx_union).fsb_payload16_reply).word3, ((_binding->rx_union).fsb_payload16_reply).word4, ((_binding->rx_union).fsb_payload16_reply).word5, ((_binding->rx_union).fsb_payload16_reply).word6, ((_binding->rx_union).fsb_payload16_reply).word7, ((_binding->rx_union).fsb_payload16_reply).word8, ((_binding->rx_union).fsb_payload16_reply).word9, ((_binding->rx_union).fsb_payload16_reply).word10, ((_binding->rx_union).fsb_payload16_reply).word11, ((_binding->rx_union).fsb_payload16_reply).word12, ((_binding->rx_union).fsb_payload16_reply).word13, ((_binding->rx_union).fsb_payload16_reply).word14, ((_binding->rx_union).fsb_payload16_reply).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_1_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_1_request).word0 = (((msg->data)[0]) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_1_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_1_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_1_request)(_binding, ((_binding->rx_union).fsb_payload32_1_request).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_1_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_1_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_1_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_1_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_1_reply)(_binding, ((_binding->rx_union).fsb_payload32_1_reply).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_1_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_1_request).word0 = ((msg->data)[0]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_1_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_1_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_1_request)(_binding, ((_binding->rx_union).fsb_payload64_1_request).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_1_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_1_reply).word0 = ((msg->data)[0]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_1_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_1_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_1_reply)(_binding, ((_binding->rx_union).fsb_payload64_1_reply).word0);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_2_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_2_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_2_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_2_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_2_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_2_request)(_binding, ((_binding->rx_union).fsb_payload32_2_request).word0, ((_binding->rx_union).fsb_payload32_2_request).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_2_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_2_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_2_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_2_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_2_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_2_reply)(_binding, ((_binding->rx_union).fsb_payload32_2_reply).word0, ((_binding->rx_union).fsb_payload32_2_reply).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_2_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_2_request).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_2_request).word1 = ((msg->data)[1]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_2_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_2_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_2_request)(_binding, ((_binding->rx_union).fsb_payload64_2_request).word0, ((_binding->rx_union).fsb_payload64_2_request).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_2_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_2_reply).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_2_reply).word1 = ((msg->data)[1]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_2_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_2_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_2_reply)(_binding, ((_binding->rx_union).fsb_payload64_2_reply).word0, ((_binding->rx_union).fsb_payload64_2_reply).word1);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_4_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_4_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_request).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_request).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_4_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_4_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_4_request)(_binding, ((_binding->rx_union).fsb_payload32_4_request).word0, ((_binding->rx_union).fsb_payload32_4_request).word1, ((_binding->rx_union).fsb_payload32_4_request).word2, ((_binding->rx_union).fsb_payload32_4_request).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_4_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_4_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_reply).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_4_reply).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_4_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_4_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_4_reply)(_binding, ((_binding->rx_union).fsb_payload32_4_reply).word0, ((_binding->rx_union).fsb_payload32_4_reply).word1, ((_binding->rx_union).fsb_payload32_4_reply).word2, ((_binding->rx_union).fsb_payload32_4_reply).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_4_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_4_request).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_4_request).word1 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_4_request).word2 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_4_request).word3 = ((msg->data)[3]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_4_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_4_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_4_request)(_binding, ((_binding->rx_union).fsb_payload64_4_request).word0, ((_binding->rx_union).fsb_payload64_4_request).word1, ((_binding->rx_union).fsb_payload64_4_request).word2, ((_binding->rx_union).fsb_payload64_4_request).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_4_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_4_reply).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_4_reply).word1 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_4_reply).word2 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_4_reply).word3 = ((msg->data)[3]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_4_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_4_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_4_reply)(_binding, ((_binding->rx_union).fsb_payload64_4_reply).word0, ((_binding->rx_union).fsb_payload64_4_reply).word1, ((_binding->rx_union).fsb_payload64_4_reply).word2, ((_binding->rx_union).fsb_payload64_4_reply).word3);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_8_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_8_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_request).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_8_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_8_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_8_request)(_binding, ((_binding->rx_union).fsb_payload32_8_request).word0, ((_binding->rx_union).fsb_payload32_8_request).word1, ((_binding->rx_union).fsb_payload32_8_request).word2, ((_binding->rx_union).fsb_payload32_8_request).word3, ((_binding->rx_union).fsb_payload32_8_request).word4, ((_binding->rx_union).fsb_payload32_8_request).word5, ((_binding->rx_union).fsb_payload32_8_request).word6, ((_binding->rx_union).fsb_payload32_8_request).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_8_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_8_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_8_reply).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_8_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_8_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_8_reply)(_binding, ((_binding->rx_union).fsb_payload32_8_reply).word0, ((_binding->rx_union).fsb_payload32_8_reply).word1, ((_binding->rx_union).fsb_payload32_8_reply).word2, ((_binding->rx_union).fsb_payload32_8_reply).word3, ((_binding->rx_union).fsb_payload32_8_reply).word4, ((_binding->rx_union).fsb_payload32_8_reply).word5, ((_binding->rx_union).fsb_payload32_8_reply).word6, ((_binding->rx_union).fsb_payload32_8_reply).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_8_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_8_request).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_8_request).word1 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_8_request).word2 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_8_request).word3 = ((msg->data)[3]);
                ((_binding->rx_union).fsb_payload64_8_request).word4 = ((msg->data)[4]);
                ((_binding->rx_union).fsb_payload64_8_request).word5 = ((msg->data)[5]);
                ((_binding->rx_union).fsb_payload64_8_request).word6 = ((msg->data)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload64_8_request).word7 = ((msg->data)[0]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_8_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_8_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_8_request)(_binding, ((_binding->rx_union).fsb_payload64_8_request).word0, ((_binding->rx_union).fsb_payload64_8_request).word1, ((_binding->rx_union).fsb_payload64_8_request).word2, ((_binding->rx_union).fsb_payload64_8_request).word3, ((_binding->rx_union).fsb_payload64_8_request).word4, ((_binding->rx_union).fsb_payload64_8_request).word5, ((_binding->rx_union).fsb_payload64_8_request).word6, ((_binding->rx_union).fsb_payload64_8_request).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_8_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_8_reply).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_8_reply).word1 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_8_reply).word2 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_8_reply).word3 = ((msg->data)[3]);
                ((_binding->rx_union).fsb_payload64_8_reply).word4 = ((msg->data)[4]);
                ((_binding->rx_union).fsb_payload64_8_reply).word5 = ((msg->data)[5]);
                ((_binding->rx_union).fsb_payload64_8_reply).word6 = ((msg->data)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload64_8_reply).word7 = ((msg->data)[0]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_8_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_8_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_8_reply)(_binding, ((_binding->rx_union).fsb_payload64_8_reply).word0, ((_binding->rx_union).fsb_payload64_8_reply).word1, ((_binding->rx_union).fsb_payload64_8_reply).word2, ((_binding->rx_union).fsb_payload64_8_reply).word3, ((_binding->rx_union).fsb_payload64_8_reply).word4, ((_binding->rx_union).fsb_payload64_8_reply).word5, ((_binding->rx_union).fsb_payload64_8_reply).word6, ((_binding->rx_union).fsb_payload64_8_reply).word7);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_16_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_16_request).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word8 = (((msg->data)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word9 = ((((msg->data)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word10 = (((msg->data)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word11 = ((((msg->data)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word12 = (((msg->data)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word13 = ((((msg->data)[6]) >> 32) & 0xffffffff);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload32_16_request).word14 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_request).word15 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_16_request\n");
                assert(((_binding->rx_vtbl).fsb_payload32_16_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_16_request)(_binding, ((_binding->rx_union).fsb_payload32_16_request).word0, ((_binding->rx_union).fsb_payload32_16_request).word1, ((_binding->rx_union).fsb_payload32_16_request).word2, ((_binding->rx_union).fsb_payload32_16_request).word3, ((_binding->rx_union).fsb_payload32_16_request).word4, ((_binding->rx_union).fsb_payload32_16_request).word5, ((_binding->rx_union).fsb_payload32_16_request).word6, ((_binding->rx_union).fsb_payload32_16_request).word7, ((_binding->rx_union).fsb_payload32_16_request).word8, ((_binding->rx_union).fsb_payload32_16_request).word9, ((_binding->rx_union).fsb_payload32_16_request).word10, ((_binding->rx_union).fsb_payload32_16_request).word11, ((_binding->rx_union).fsb_payload32_16_request).word12, ((_binding->rx_union).fsb_payload32_16_request).word13, ((_binding->rx_union).fsb_payload32_16_request).word14, ((_binding->rx_union).fsb_payload32_16_request).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload32_16_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload32_16_reply).word0 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word1 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word2 = (((msg->data)[1]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word3 = ((((msg->data)[1]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word4 = (((msg->data)[2]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word5 = ((((msg->data)[2]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word6 = (((msg->data)[3]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word7 = ((((msg->data)[3]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word8 = (((msg->data)[4]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word9 = ((((msg->data)[4]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word10 = (((msg->data)[5]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word11 = ((((msg->data)[5]) >> 32) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word12 = (((msg->data)[6]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word13 = ((((msg->data)[6]) >> 32) & 0xffffffff);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload32_16_reply).word14 = (((msg->data)[0]) & 0xffffffff);
                ((_binding->rx_union).fsb_payload32_16_reply).word15 = ((((msg->data)[0]) >> 32) & 0xffffffff);
                
                FL_DEBUG("ump RX bench.fsb_payload32_16_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload32_16_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload32_16_reply)(_binding, ((_binding->rx_union).fsb_payload32_16_reply).word0, ((_binding->rx_union).fsb_payload32_16_reply).word1, ((_binding->rx_union).fsb_payload32_16_reply).word2, ((_binding->rx_union).fsb_payload32_16_reply).word3, ((_binding->rx_union).fsb_payload32_16_reply).word4, ((_binding->rx_union).fsb_payload32_16_reply).word5, ((_binding->rx_union).fsb_payload32_16_reply).word6, ((_binding->rx_union).fsb_payload32_16_reply).word7, ((_binding->rx_union).fsb_payload32_16_reply).word8, ((_binding->rx_union).fsb_payload32_16_reply).word9, ((_binding->rx_union).fsb_payload32_16_reply).word10, ((_binding->rx_union).fsb_payload32_16_reply).word11, ((_binding->rx_union).fsb_payload32_16_reply).word12, ((_binding->rx_union).fsb_payload32_16_reply).word13, ((_binding->rx_union).fsb_payload32_16_reply).word14, ((_binding->rx_union).fsb_payload32_16_reply).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_16_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_16_request).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_16_request).word1 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_16_request).word2 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_16_request).word3 = ((msg->data)[3]);
                ((_binding->rx_union).fsb_payload64_16_request).word4 = ((msg->data)[4]);
                ((_binding->rx_union).fsb_payload64_16_request).word5 = ((msg->data)[5]);
                ((_binding->rx_union).fsb_payload64_16_request).word6 = ((msg->data)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload64_16_request).word7 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_16_request).word8 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_16_request).word9 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_16_request).word10 = ((msg->data)[3]);
                ((_binding->rx_union).fsb_payload64_16_request).word11 = ((msg->data)[4]);
                ((_binding->rx_union).fsb_payload64_16_request).word12 = ((msg->data)[5]);
                ((_binding->rx_union).fsb_payload64_16_request).word13 = ((msg->data)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 2:
                ((_binding->rx_union).fsb_payload64_16_request).word14 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_16_request).word15 = ((msg->data)[1]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_16_request\n");
                assert(((_binding->rx_vtbl).fsb_payload64_16_request) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_16_request)(_binding, ((_binding->rx_union).fsb_payload64_16_request).word0, ((_binding->rx_union).fsb_payload64_16_request).word1, ((_binding->rx_union).fsb_payload64_16_request).word2, ((_binding->rx_union).fsb_payload64_16_request).word3, ((_binding->rx_union).fsb_payload64_16_request).word4, ((_binding->rx_union).fsb_payload64_16_request).word5, ((_binding->rx_union).fsb_payload64_16_request).word6, ((_binding->rx_union).fsb_payload64_16_request).word7, ((_binding->rx_union).fsb_payload64_16_request).word8, ((_binding->rx_union).fsb_payload64_16_request).word9, ((_binding->rx_union).fsb_payload64_16_request).word10, ((_binding->rx_union).fsb_payload64_16_request).word11, ((_binding->rx_union).fsb_payload64_16_request).word12, ((_binding->rx_union).fsb_payload64_16_request).word13, ((_binding->rx_union).fsb_payload64_16_request).word14, ((_binding->rx_union).fsb_payload64_16_request).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_fsb_payload64_16_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).fsb_payload64_16_reply).word0 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_16_reply).word1 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_16_reply).word2 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_16_reply).word3 = ((msg->data)[3]);
                ((_binding->rx_union).fsb_payload64_16_reply).word4 = ((msg->data)[4]);
                ((_binding->rx_union).fsb_payload64_16_reply).word5 = ((msg->data)[5]);
                ((_binding->rx_union).fsb_payload64_16_reply).word6 = ((msg->data)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 1:
                ((_binding->rx_union).fsb_payload64_16_reply).word7 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_16_reply).word8 = ((msg->data)[1]);
                ((_binding->rx_union).fsb_payload64_16_reply).word9 = ((msg->data)[2]);
                ((_binding->rx_union).fsb_payload64_16_reply).word10 = ((msg->data)[3]);
                ((_binding->rx_union).fsb_payload64_16_reply).word11 = ((msg->data)[4]);
                ((_binding->rx_union).fsb_payload64_16_reply).word12 = ((msg->data)[5]);
                ((_binding->rx_union).fsb_payload64_16_reply).word13 = ((msg->data)[6]);
                
                (_binding->rx_msg_fragment)++;
                break;
            case 2:
                ((_binding->rx_union).fsb_payload64_16_reply).word14 = ((msg->data)[0]);
                ((_binding->rx_union).fsb_payload64_16_reply).word15 = ((msg->data)[1]);
                
                FL_DEBUG("ump RX bench.fsb_payload64_16_reply\n");
                assert(((_binding->rx_vtbl).fsb_payload64_16_reply) != NULL);
                ((_binding->rx_vtbl).fsb_payload64_16_reply)(_binding, ((_binding->rx_union).fsb_payload64_16_reply).word0, ((_binding->rx_union).fsb_payload64_16_reply).word1, ((_binding->rx_union).fsb_payload64_16_reply).word2, ((_binding->rx_union).fsb_payload64_16_reply).word3, ((_binding->rx_union).fsb_payload64_16_reply).word4, ((_binding->rx_union).fsb_payload64_16_reply).word5, ((_binding->rx_union).fsb_payload64_16_reply).word6, ((_binding->rx_union).fsb_payload64_16_reply).word7, ((_binding->rx_union).fsb_payload64_16_reply).word8, ((_binding->rx_union).fsb_payload64_16_reply).word9, ((_binding->rx_union).fsb_payload64_16_reply).word10, ((_binding->rx_union).fsb_payload64_16_reply).word11, ((_binding->rx_union).fsb_payload64_16_reply).word12, ((_binding->rx_union).fsb_payload64_16_reply).word13, ((_binding->rx_union).fsb_payload64_16_reply).word14, ((_binding->rx_union).fsb_payload64_16_reply).word15);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_lrpc_init__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.lrpc_init\n");
                assert(((_binding->rx_vtbl).lrpc_init) != NULL);
                ((_binding->rx_vtbl).lrpc_init)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_lrpc_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.lrpc_init_reply\n");
                assert(((_binding->rx_vtbl).lrpc_init_reply) != NULL);
                ((_binding->rx_vtbl).lrpc_init_reply)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_lrpc_bench_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).lrpc_bench_reply).value = ((msg->data)[0]);
                
                FL_DEBUG("ump RX bench.lrpc_bench_reply\n");
                assert(((_binding->rx_vtbl).lrpc_bench_reply) != NULL);
                ((_binding->rx_vtbl).lrpc_bench_reply)(_binding, ((_binding->rx_union).lrpc_bench_reply).value);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_init_request__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((_binding->rx_union).shmc_init_request).coreid = (((msg->data)[0]) & 0xff);
                
                FL_DEBUG("ump RX bench.shmc_init_request\n");
                assert(((_binding->rx_vtbl).shmc_init_request) != NULL);
                ((_binding->rx_vtbl).shmc_init_request)(_binding, ((_binding->rx_union).shmc_init_request).coreid);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_init_reply__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                ((b->ump_state).capst).tx_cap_ack = true;
                ((b->ump_state).capst).rx_capnum = 0;
                
                (_binding->rx_msg_fragment)++;
                if ((((b->ump_state).capst).rx_capnum) == 1) {
                    FL_DEBUG("ump RX bench.shmc_init_reply\n");
                    assert(((_binding->rx_vtbl).shmc_init_reply) != NULL);
                    ((_binding->rx_vtbl).shmc_init_reply)(_binding, ((_binding->rx_union).shmc_init_reply).cap);
                    _binding->rx_msgnum = 0;
                } else {
                    // don't process anything else until we're done
                    goto out_no_reregister;
                }
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_start__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.shmc_start\n");
                assert(((_binding->rx_vtbl).shmc_start) != NULL);
                ((_binding->rx_vtbl).shmc_start)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        case bench_shmc_done__msgnum:
            switch (_binding->rx_msg_fragment) {
            case 0:
                
                FL_DEBUG("ump RX bench.shmc_done\n");
                assert(((_binding->rx_vtbl).shmc_done) != NULL);
                ((_binding->rx_vtbl).shmc_done)(_binding);
                _binding->rx_msgnum = 0;
                break;
            default:
                (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
                goto out;
            }
            break;
        default:
            (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_MSGNUM);
            goto out;
        }
        
        loopnext:
        // send an ack if the channel is now full
        if (flounder_stub_ump_needs_ack(&(b->ump_state))) {
            // run our send process if we need to
            if ((((b->ump_state).capst).tx_cap_ack) || ((_binding->tx_msgnum) != 0)) {
                bench_ump_send_handler(b);
            } else {
                flounder_stub_ump_send_ack(&(b->ump_state));
            }
        }
    }
    
    out:
    // register for receive notification
    err = ump_chan_register_recv(&((b->ump_state).chan), _binding->waitset, (struct event_closure){  .handler = bench_ump_rx_handler,  .arg = _binding });
    if (err_is_fail(err)) {
        (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
    }
    
    out_no_reregister:
    __attribute__((unused));
    // run our send process, if we need to
    if ((((b->ump_state).capst).tx_cap_ack) || ((_binding->tx_msgnum) != 0)) {
        bench_ump_send_handler(b);
    } else {
        // otherwise send a forced ack if the channel is now full
        if (flounder_stub_ump_needs_ack(&(b->ump_state))) {
            flounder_stub_ump_send_ack(&(b->ump_state));
        }
    }
}


/*
 * Cap send/receive handlers
 */
static  void bench_ump_cap_rx_handler(void *arg, errval_t success, struct capref cap, uint32_t capid)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_ump_binding *b = arg;
    errval_t err;
    err = SYS_ERR_OK;
    
    assert(capid == (((b->ump_state).capst).rx_capnum));
    
    // Check if there's an associated error
    // FIXME: how should we report this to the user? at present we just deliver a NULL capref
    if (err_is_fail(success)) {
        DEBUG_ERR(err, "error in cap transfer");
    }
    
    // Switch on current incoming message
    switch (_binding->rx_msgnum) {
    case bench_shmc_init_reply__msgnum:
        // Switch on current incoming cap
        switch ((((b->ump_state).capst).rx_capnum)++) {
        case 0:
            ((_binding->rx_union).shmc_init_reply).cap = cap;
            if ((_binding->rx_msg_fragment) == 1) {
                FL_DEBUG("ump RX bench.shmc_init_reply\n");
                assert(((_binding->rx_vtbl).shmc_init_reply) != NULL);
                ((_binding->rx_vtbl).shmc_init_reply)(_binding, ((_binding->rx_union).shmc_init_reply).cap);
                _binding->rx_msgnum = 0;
                // register for receive notification
                err = ump_chan_register_recv(&((b->ump_state).chan), _binding->waitset, (struct event_closure){  .handler = bench_ump_rx_handler,  .arg = _binding });
                if (err_is_fail(err)) {
                    (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
                }
            }
            break;
        default:
            assert(!("invalid cap number"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    default:
        assert(!("invalid message number"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
}


/*
 * Monitor mutex acquire continuation
 */
static  void bench_ump_monitor_mutex_cont(void *arg)
{
    struct bench_ump_binding *b = arg;
    assert(!(((b->ump_state).capst).monitor_mutex_held));
    ((b->ump_state).capst).monitor_mutex_held = true;
    if (((b->ump_state).capst).rx_cap_ack) {
        bench_ump_cap_send_handler(b);
    }
}


/*
 * Message sender functions
 */
static  errval_t bench_init_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).init_request).coreid = coreid;
    FL_DEBUG("ump TX bench.init_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_init_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.init_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_token_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_token_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.token_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_token_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_token_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.token_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_init_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_busy_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.busy_init_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_init_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_busy_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.busy_init_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_ping__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_busy_ping__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.busy_ping\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_ump_init_msg__ump_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_ump_init_msg__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).ump_init_msg).coreid = coreid;
    FL_DEBUG("ump TX bench.ump_init_msg\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_init_msg__ump_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_init_msg__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_init_msg).coreid = coreid;
    FL_DEBUG("ump TX bench.fsb_init_msg\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_empty_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_empty_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.fsb_empty_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_empty_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_empty_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.fsb_empty_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_buffer_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, const uint8_t *buf, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_buffer_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_buffer_request).buf = ((uint8_t *)(buf));
    ((_binding->tx_union).fsb_buffer_request).size = size;
    FL_DEBUG("ump TX bench.fsb_buffer_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_buffer_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, const uint8_t *buf, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_buffer_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_buffer_reply).buf = ((uint8_t *)(buf));
    ((_binding->tx_union).fsb_buffer_reply).size = size;
    FL_DEBUG("ump TX bench.fsb_buffer_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload_request).word0 = word0;
    ((_binding->tx_union).fsb_payload_request).word1 = word1;
    ((_binding->tx_union).fsb_payload_request).word2 = word2;
    ((_binding->tx_union).fsb_payload_request).word3 = word3;
    FL_DEBUG("ump TX bench.fsb_payload_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload_reply).word3 = word3;
    FL_DEBUG("ump TX bench.fsb_payload_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload1_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload1_request).word0 = word0;
    FL_DEBUG("ump TX bench.fsb_payload1_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload1_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload1_reply).word0 = word0;
    FL_DEBUG("ump TX bench.fsb_payload1_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload2_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload2_request).word1 = word1;
    FL_DEBUG("ump TX bench.fsb_payload2_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload2_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload2_reply).word1 = word1;
    FL_DEBUG("ump TX bench.fsb_payload2_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload8_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload8_request).word7 = word7;
    FL_DEBUG("ump TX bench.fsb_payload8_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload8_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload8_reply).word7 = word7;
    FL_DEBUG("ump TX bench.fsb_payload8_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload16_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload16_request).word15 = word15;
    FL_DEBUG("ump TX bench.fsb_payload16_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload16_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload16_reply).word15 = word15;
    FL_DEBUG("ump TX bench.fsb_payload16_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_1_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_1_request).word0 = word0;
    FL_DEBUG("ump TX bench.fsb_payload32_1_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_1_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_1_reply).word0 = word0;
    FL_DEBUG("ump TX bench.fsb_payload32_1_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_1_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_1_request).word0 = word0;
    FL_DEBUG("ump TX bench.fsb_payload64_1_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_1_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_1_reply).word0 = word0;
    FL_DEBUG("ump TX bench.fsb_payload64_1_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_2_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_2_request).word1 = word1;
    FL_DEBUG("ump TX bench.fsb_payload32_2_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_2_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_2_reply).word1 = word1;
    FL_DEBUG("ump TX bench.fsb_payload32_2_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_2_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_2_request).word1 = word1;
    FL_DEBUG("ump TX bench.fsb_payload64_2_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_2_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_2_reply).word1 = word1;
    FL_DEBUG("ump TX bench.fsb_payload64_2_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_4_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_4_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_4_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_4_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_4_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_4_request).word3 = word3;
    FL_DEBUG("ump TX bench.fsb_payload32_4_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_4_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_4_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_4_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_4_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_4_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_4_reply).word3 = word3;
    FL_DEBUG("ump TX bench.fsb_payload32_4_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_4_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_4_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_4_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_4_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_4_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_4_request).word3 = word3;
    FL_DEBUG("ump TX bench.fsb_payload64_4_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_4_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_4_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_4_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_4_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_4_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_4_reply).word3 = word3;
    FL_DEBUG("ump TX bench.fsb_payload64_4_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_8_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload32_8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload32_8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload32_8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload32_8_request).word7 = word7;
    FL_DEBUG("ump TX bench.fsb_payload32_8_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_8_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload32_8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload32_8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload32_8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload32_8_reply).word7 = word7;
    FL_DEBUG("ump TX bench.fsb_payload32_8_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_8_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload64_8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload64_8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload64_8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload64_8_request).word7 = word7;
    FL_DEBUG("ump TX bench.fsb_payload64_8_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_8_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload64_8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload64_8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload64_8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload64_8_reply).word7 = word7;
    FL_DEBUG("ump TX bench.fsb_payload64_8_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_16_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload32_16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload32_16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload32_16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload32_16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload32_16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload32_16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload32_16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload32_16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload32_16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload32_16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload32_16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload32_16_request).word15 = word15;
    FL_DEBUG("ump TX bench.fsb_payload32_16_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_16_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload32_16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload32_16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload32_16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload32_16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload32_16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload32_16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload32_16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload32_16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload32_16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload32_16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload32_16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload32_16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload32_16_reply).word15 = word15;
    FL_DEBUG("ump TX bench.fsb_payload32_16_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_16_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7, int64_t word8, int64_t word9, int64_t word10, int64_t word11, int64_t word12, int64_t word13, int64_t word14, int64_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload64_16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload64_16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload64_16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload64_16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload64_16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload64_16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload64_16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload64_16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload64_16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload64_16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload64_16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload64_16_request).word15 = word15;
    FL_DEBUG("ump TX bench.fsb_payload64_16_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_16_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7, int64_t word8, int64_t word9, int64_t word10, int64_t word11, int64_t word12, int64_t word13, int64_t word14, int64_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_fsb_payload64_16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload64_16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload64_16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload64_16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload64_16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload64_16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload64_16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload64_16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload64_16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload64_16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload64_16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload64_16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload64_16_reply).word15 = word15;
    FL_DEBUG("ump TX bench.fsb_payload64_16_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_init__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_lrpc_init__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.lrpc_init\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_init_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_lrpc_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.lrpc_init_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_bench_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, uint64_t value)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_lrpc_bench_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).lrpc_bench_reply).value = value;
    FL_DEBUG("ump TX bench.lrpc_bench_reply\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_init_request__ump_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).shmc_init_request).coreid = coreid;
    FL_DEBUG("ump TX bench.shmc_init_request\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_init_reply__ump_send(struct bench_binding *_binding, struct event_closure _continuation, struct capref cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).shmc_init_reply).cap = cap;
    FL_DEBUG("ump TX bench.shmc_init_reply\n");
    
    // init cap send state
    ((((struct bench_ump_binding *)(_binding))->ump_state).capst).tx_capnum = 0;
    ((((struct bench_ump_binding *)(_binding))->ump_state).capst).rx_cap_ack = false;
    ((((struct bench_ump_binding *)(_binding))->ump_state).capst).monitor_mutex_held = false;
    
    // wait to acquire the monitor binding mutex
    flounder_support_monitor_mutex_enqueue(((((struct bench_ump_binding *)(_binding))->ump_state).chan).monitor_binding, &(_binding->event_qnode), (struct event_closure){  .handler = bench_ump_monitor_mutex_cont,  .arg = _binding });
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_start__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_start__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.shmc_start\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_done__ump_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and arguments
    _binding->tx_msgnum = bench_shmc_done__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("ump TX bench.shmc_done\n");
    
    // try to send!
    bench_ump_send_handler(_binding);
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct bench_tx_vtbl bench_ump_tx_vtbl = {
    .init_request = bench_init_request__ump_send,
    .init_reply = bench_init_reply__ump_send,
    .token_request = bench_token_request__ump_send,
    .token_reply = bench_token_reply__ump_send,
    .busy_init_request = bench_busy_init_request__ump_send,
    .busy_init_reply = bench_busy_init_reply__ump_send,
    .busy_ping = bench_busy_ping__ump_send,
    .ump_init_msg = bench_ump_init_msg__ump_send,
    .fsb_init_msg = bench_fsb_init_msg__ump_send,
    .fsb_empty_request = bench_fsb_empty_request__ump_send,
    .fsb_empty_reply = bench_fsb_empty_reply__ump_send,
    .fsb_buffer_request = bench_fsb_buffer_request__ump_send,
    .fsb_buffer_reply = bench_fsb_buffer_reply__ump_send,
    .fsb_payload_request = bench_fsb_payload_request__ump_send,
    .fsb_payload_reply = bench_fsb_payload_reply__ump_send,
    .fsb_payload1_request = bench_fsb_payload1_request__ump_send,
    .fsb_payload1_reply = bench_fsb_payload1_reply__ump_send,
    .fsb_payload2_request = bench_fsb_payload2_request__ump_send,
    .fsb_payload2_reply = bench_fsb_payload2_reply__ump_send,
    .fsb_payload8_request = bench_fsb_payload8_request__ump_send,
    .fsb_payload8_reply = bench_fsb_payload8_reply__ump_send,
    .fsb_payload16_request = bench_fsb_payload16_request__ump_send,
    .fsb_payload16_reply = bench_fsb_payload16_reply__ump_send,
    .fsb_payload32_1_request = bench_fsb_payload32_1_request__ump_send,
    .fsb_payload32_1_reply = bench_fsb_payload32_1_reply__ump_send,
    .fsb_payload64_1_request = bench_fsb_payload64_1_request__ump_send,
    .fsb_payload64_1_reply = bench_fsb_payload64_1_reply__ump_send,
    .fsb_payload32_2_request = bench_fsb_payload32_2_request__ump_send,
    .fsb_payload32_2_reply = bench_fsb_payload32_2_reply__ump_send,
    .fsb_payload64_2_request = bench_fsb_payload64_2_request__ump_send,
    .fsb_payload64_2_reply = bench_fsb_payload64_2_reply__ump_send,
    .fsb_payload32_4_request = bench_fsb_payload32_4_request__ump_send,
    .fsb_payload32_4_reply = bench_fsb_payload32_4_reply__ump_send,
    .fsb_payload64_4_request = bench_fsb_payload64_4_request__ump_send,
    .fsb_payload64_4_reply = bench_fsb_payload64_4_reply__ump_send,
    .fsb_payload32_8_request = bench_fsb_payload32_8_request__ump_send,
    .fsb_payload32_8_reply = bench_fsb_payload32_8_reply__ump_send,
    .fsb_payload64_8_request = bench_fsb_payload64_8_request__ump_send,
    .fsb_payload64_8_reply = bench_fsb_payload64_8_reply__ump_send,
    .fsb_payload32_16_request = bench_fsb_payload32_16_request__ump_send,
    .fsb_payload32_16_reply = bench_fsb_payload32_16_reply__ump_send,
    .fsb_payload64_16_request = bench_fsb_payload64_16_request__ump_send,
    .fsb_payload64_16_reply = bench_fsb_payload64_16_reply__ump_send,
    .lrpc_init = bench_lrpc_init__ump_send,
    .lrpc_init_reply = bench_lrpc_init_reply__ump_send,
    .lrpc_bench_reply = bench_lrpc_bench_reply__ump_send,
    .shmc_init_request = bench_shmc_init_request__ump_send,
    .shmc_init_reply = bench_shmc_init_reply__ump_send,
    .shmc_start = bench_shmc_start__ump_send,
    .shmc_done = bench_shmc_done__ump_send,
};
/*
 * Control functions
 */
static  bool bench_ump_can_send(struct bench_binding *b)
{
    return((b->tx_msgnum) == 0);
}

static  errval_t bench_ump_register_send(struct bench_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(flounder_support_register(ws, &(b->register_chanstate), _continuation, bench_ump_can_send(b)));
}

static  void bench_ump_default_error_handler(struct bench_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated bench ump binding (default handler)");
    abort();
}

static  errval_t bench_ump_change_waitset(struct bench_binding *_binding, struct waitset *ws)
{
    struct bench_ump_binding *b = (void *)(_binding);
    errval_t err;
    
    // change waitset on private monitor binding if we have one
    if ((((b->ump_state).chan).monitor_binding) != get_monitor_binding()) {
        err = flounder_support_change_monitor_waitset(((b->ump_state).chan).monitor_binding, ws);
        if (err_is_fail(err)) {
            return(err_push(err, FLOUNDER_ERR_CHANGE_MONITOR_WAITSET));
        }
    }
    
    // change waitset on binding
    _binding->waitset = ws;
    
    // re-register for receive (if previously registered)
    err = ump_chan_deregister_recv(&((b->ump_state).chan));
    if (err_is_fail(err) && (err_no(err) != LIB_ERR_CHAN_NOT_REGISTERED)) {
        return(err_push(err, LIB_ERR_CHAN_DEREGISTER_RECV));
    }
    if (err_is_ok(err)) {
        err = ump_chan_register_recv(&((b->ump_state).chan), _binding->waitset, (struct event_closure){  .handler = bench_ump_rx_handler,  .arg = _binding });
        if (err_is_fail(err)) {
            return(err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
        }
    }
    return(SYS_ERR_OK);
}

static  errval_t bench_ump_control(struct bench_binding *_binding, idc_control_t control)
{
    // no control flags are supported
    return(SYS_ERR_OK);
}


/*
 * Function to destroy the binding state
 */
 void bench_ump_destroy(struct bench_ump_binding *b)
{
    flounder_support_waitset_chanstate_destroy(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_destroy(&((b->b).tx_cont_chanstate));
    ump_chan_destroy(&((b->ump_state).chan));
}


/*
 * Bind function
 */
static  void bench_ump_bind_continuation(void *st, errval_t err, struct ump_chan *chan, struct capref notify_cap)
{
    struct bench_binding *_binding = st;
    struct bench_ump_binding *b = st;
    
    if (err_is_ok(err)) {
        // notify cap ignored
        // setup cap handlers
        (((b->ump_state).chan).cap_handlers).st = b;
        (((b->ump_state).chan).cap_handlers).cap_receive_handler = bench_ump_cap_rx_handler;
        // register for receive notification
        err = ump_chan_register_recv(&((b->ump_state).chan), _binding->waitset, (struct event_closure){  .handler = bench_ump_rx_handler,  .arg = _binding });
        if (err_is_fail(err)) {
            (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
        }
    } else {
        bench_ump_destroy(b);
    }
    
    (_binding->bind_cont)(_binding->st, err, _binding);
}

 errval_t bench_ump_init(struct bench_ump_binding *b, struct waitset *waitset, volatile void *inbuf, size_t inbufsize, volatile void *outbuf, size_t outbufsize)
{
    errval_t err;
    struct bench_binding *_binding = &(b->b);
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = bench_ump_can_send;
    (b->b).register_send = bench_ump_register_send;
    (b->b).error_handler = bench_ump_default_error_handler;
    (b->b).tx_vtbl = bench_ump_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    flounder_stub_ump_state_init(&(b->ump_state), b);
    err = ump_chan_init(&((b->ump_state).chan), inbuf, inbufsize, outbuf, outbufsize);
    if (err_is_fail(err)) {
        bench_ump_destroy(b);
        return(err_push(err, LIB_ERR_UMP_CHAN_INIT));
    }
    
    (b->b).change_waitset = bench_ump_change_waitset;
    (b->b).control = bench_ump_control;
    // register for receive notification
    err = ump_chan_register_recv(&((b->ump_state).chan), _binding->waitset, (struct event_closure){  .handler = bench_ump_rx_handler,  .arg = _binding });
    if (err_is_fail(err)) {
        (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
    }
    
    return(err);
}

static  void bench_ump_new_monitor_binding_continuation(void *st, errval_t err, struct monitor_binding *monitor_binding)
{
    struct bench_binding *_binding = st;
    struct bench_ump_binding *b = st;
    
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_MONITOR_CLIENT_BIND);
        goto out;
    }
    
    ((b->ump_state).chan).monitor_binding = monitor_binding;
    // start the bind on the new monitor binding
    err = ump_chan_bind(&((b->ump_state).chan), (struct ump_bind_continuation){  .handler = bench_ump_bind_continuation,  .st = b }, &(_binding->event_qnode), b->iref, monitor_binding, b->inchanlen, b->outchanlen, NULL_CAP);
    
    out:
    if (err_is_fail(err)) {
        (_binding->bind_cont)(_binding->st, err, _binding);
        bench_ump_destroy(b);
    }
}

 errval_t bench_ump_bind(struct bench_ump_binding *b, iref_t iref, bench_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags, size_t inchanlen, size_t outchanlen)
{
    errval_t err;
    (b->b).st = NULL;
    (b->b).waitset = waitset;
    event_mutex_init(&((b->b).mutex), waitset);
    (b->b).can_send = bench_ump_can_send;
    (b->b).register_send = bench_ump_register_send;
    (b->b).error_handler = bench_ump_default_error_handler;
    (b->b).tx_vtbl = bench_ump_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    flounder_stub_ump_state_init(&(b->ump_state), b);
    (b->b).change_waitset = bench_ump_change_waitset;
    (b->b).control = bench_ump_control;
    (b->b).st = st;
    (b->b).bind_cont = _continuation;
    b->iref = iref;
    b->inchanlen = inchanlen;
    b->outchanlen = outchanlen;
    
    // do we need a new monitor binding?
    if (flags & IDC_BIND_FLAG_RPC_CAP_TRANSFER) {
        err = monitor_client_new_binding(bench_ump_new_monitor_binding_continuation, b, waitset, DEFAULT_LMP_BUF_WORDS);
    } else {
        err = ump_chan_bind(&((b->ump_state).chan), (struct ump_bind_continuation){  .handler = bench_ump_bind_continuation,  .st = b }, &((b->b).event_qnode), iref, get_monitor_binding(), inchanlen, outchanlen, NULL_CAP);
    }
    
    if (err_is_fail(err)) {
        bench_ump_destroy(b);
    }
    return(err);
}


/*
 * Connect callback for export
 */
 errval_t bench_ump_connect_handler(void *st, struct monitor_binding *mb, uintptr_t mon_id, struct capref frame, size_t inchanlen, size_t outchanlen, struct capref notify_cap)
{
    struct bench_export *e = st;
    errval_t err;
    
    // allocate storage for binding
    struct bench_ump_binding *b = malloc(sizeof(struct bench_ump_binding ));
    if (b == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    struct bench_binding *_binding = &(b->b);
    (b->b).st = NULL;
    (b->b).waitset = (e->waitset);
    event_mutex_init(&((b->b).mutex), e->waitset);
    (b->b).can_send = bench_ump_can_send;
    (b->b).register_send = bench_ump_register_send;
    (b->b).error_handler = bench_ump_default_error_handler;
    (b->b).tx_vtbl = bench_ump_tx_vtbl;
    memset(&((b->b).rx_vtbl), 0, sizeof((b->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((b->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((b->b).tx_cont_chanstate));
    (b->b).tx_msgnum = 0;
    (b->b).rx_msgnum = 0;
    (b->b).tx_msg_fragment = 0;
    (b->b).rx_msg_fragment = 0;
    (b->b).tx_str_pos = 0;
    (b->b).rx_str_pos = 0;
    (b->b).tx_str_len = 0;
    (b->b).rx_str_len = 0;
    (b->b).bind_cont = NULL;
    flounder_stub_ump_state_init(&(b->ump_state), b);
    (b->b).change_waitset = bench_ump_change_waitset;
    (b->b).control = bench_ump_control;
    
    // run user's connect handler
    err = ((e->connect_cb)(e->st, _binding));
    if (err_is_fail(err)) {
        // connection refused
        bench_ump_destroy(b);
        return(err);
    }
    
    // accept the connection and setup the channel
    err = ump_chan_accept(&((b->ump_state).chan), mon_id, frame, inchanlen, outchanlen);
    if (err_is_fail(err)) {
        err = err_push(err, LIB_ERR_UMP_CHAN_ACCEPT);
        (_binding->error_handler)(_binding, err);
        return(err);
    }
    
    // notify cap ignored
    // setup cap handlers
    (((b->ump_state).chan).cap_handlers).st = b;
    (((b->ump_state).chan).cap_handlers).cap_receive_handler = bench_ump_cap_rx_handler;
    
    // register for receive notification
    err = ump_chan_register_recv(&((b->ump_state).chan), _binding->waitset, (struct event_closure){  .handler = bench_ump_rx_handler,  .arg = _binding });
    if (err_is_fail(err)) {
        (_binding->error_handler)(_binding, err_push(err, LIB_ERR_CHAN_REGISTER_RECV));
    }
    
    // send back bind reply
    ump_chan_send_bind_reply(mb, &((b->ump_state).chan), SYS_ERR_OK, mon_id, NULL_CAP);
    
    return(SYS_ERR_OK);
}

#endif // CONFIG_FLOUNDER_BACKEND_UMP
/*
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * INTERFACE NAME: bench
 * INTEFACE FILE: ../if/bench.if
 * INTERFACE DESCRIPTION: The bench Interface
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr.6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY FLOUNDER: DO NOT EDIT!
 */

#ifdef CONFIG_FLOUNDER_BACKEND_MULTIHOP
/*
 * Generated Stub for Multihop on x86_64
 */

#include <string.h>
#include <barrelfish/barrelfish.h>
#include <flounder/flounder_support.h>
#include <if/bench_defs.h>

/*
 * Capability sender function
 */
static  void bench_multihop_cap_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    
    // Switch on current outgoing message
    switch (_binding->tx_msgnum) {
    case bench_shmc_init_reply__msgnum:
        // Switch on current outgoing cap
        switch ((mb->capst).tx_capnum) {
        case 0:
            err = multihop_send_capability(&(mb->chan), MKCONT(bench_multihop_cap_send_handler, _binding), &(mb->capst), ((_binding->tx_union).shmc_init_reply).cap);
            if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
                err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_multihop_cap_send_handler, _binding));
                assert(err_is_ok(err));
            }
            if (err_is_fail(err)) {
                (_binding->error_handler)(_binding, err);
                _binding->tx_msgnum = 0;
                flounder_support_trigger_chan(&(_binding->register_chanstate));
                flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
                break;
            }
            break;
        case 1:
            if (multihop_chan_is_window_full(&(mb->chan))) {
                mb->trigger_chan = true;
                break;
            } else {
                _binding->tx_msgnum = 0;
                flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
                flounder_support_trigger_chan(&(_binding->register_chanstate));
                break;
            }
        default:
            assert(!("invalid cap number"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    default:
        assert(!("invalid message number"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
}

/*
 * Send handler functions
 */
static  void bench_init_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment uint8 [NamedField "coreid"] 0]]
        msg[0] = (bench_init_request__msgnum | (((uint64_t )(((_binding->tx_union).init_request).coreid)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_init_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_init_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_init_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_init_reply__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_init_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_init_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_token_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_token_request__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_token_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_token_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_token_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_token_reply__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_token_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_token_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_busy_init_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_busy_init_request__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_busy_init_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_busy_init_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_busy_init_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_busy_init_reply__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_busy_init_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_busy_init_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_busy_ping__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_busy_ping__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_busy_ping__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_busy_ping__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_ump_init_msg__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment uint8 [NamedField "coreid"] 0]]
        msg[0] = (bench_ump_init_msg__msgnum | (((uint64_t )(((_binding->tx_union).ump_init_msg).coreid)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_ump_init_msg__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_ump_init_msg__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_init_msg__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment uint8 [NamedField "coreid"] 0]]
        msg[0] = (bench_fsb_init_msg__msgnum | (((uint64_t )(((_binding->tx_union).fsb_init_msg).coreid)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_init_msg__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_init_msg__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_empty_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_fsb_empty_request__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_empty_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_empty_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_empty_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_fsb_empty_reply__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_empty_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_empty_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_buffer_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    uint8_t *msg2;
    uint64_t o_frag_size;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        msg_size = (msg_size + ((((_binding->tx_union).fsb_buffer_request).size) + 8));
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_fsb_buffer_request__msgnum;
        msg2 = (((uint8_t *)(msg)) + 8);
        
        // copy strings
        
        // copy buffers
        o_frag_size = ((uint64_t )(((_binding->tx_union).fsb_buffer_request).size));
        memcpy(msg2, &o_frag_size, 8);
        memcpy(msg2 + 8, ((_binding->tx_union).fsb_buffer_request).buf, o_frag_size);
        msg2 = ((msg2 + o_frag_size) + 8);
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_buffer_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_buffer_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_buffer_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    uint8_t *msg2;
    uint64_t o_frag_size;
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        msg_size = (msg_size + ((((_binding->tx_union).fsb_buffer_reply).size) + 8));
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_fsb_buffer_reply__msgnum;
        msg2 = (((uint8_t *)(msg)) + 8);
        
        // copy strings
        
        // copy buffers
        o_frag_size = ((uint64_t )(((_binding->tx_union).fsb_buffer_reply).size));
        memcpy(msg2, &o_frag_size, 8);
        memcpy(msg2 + 8, ((_binding->tx_union).fsb_buffer_reply).buf, o_frag_size);
        msg2 = ((msg2 + o_frag_size) + 8);
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_buffer_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_buffer_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 24;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0]]
        msg[0] = (bench_fsb_payload_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload_request).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload_request).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload_request).word2)) << 32));
        msg[2] = (((_binding->tx_union).fsb_payload_request).word3);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 24;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0]]
        msg[0] = (bench_fsb_payload_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload_reply).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload_reply).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload_reply).word2)) << 32));
        msg[2] = (((_binding->tx_union).fsb_payload_reply).word3);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload1_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0]]
        msg[0] = (bench_fsb_payload1_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload1_request).word0)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload1_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload1_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload1_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0]]
        msg[0] = (bench_fsb_payload1_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload1_reply).word0)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload1_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload1_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload2_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 16;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0]]
        msg[0] = (bench_fsb_payload2_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload2_request).word0)) << 16));
        msg[1] = (((_binding->tx_union).fsb_payload2_request).word1);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload2_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload2_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload2_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 16;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0]]
        msg[0] = (bench_fsb_payload2_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload2_reply).word0)) << 16));
        msg[1] = (((_binding->tx_union).fsb_payload2_reply).word1);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload2_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload2_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload8_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 40;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0]]
        msg[0] = (bench_fsb_payload8_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload8_request).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload8_request).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload8_request).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload8_request).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload8_request).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload8_request).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload8_request).word6)) << 32));
        msg[4] = (((_binding->tx_union).fsb_payload8_request).word7);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload8_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload8_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload8_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 40;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0]]
        msg[0] = (bench_fsb_payload8_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload8_reply).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload8_reply).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload8_reply).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload8_reply).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload8_reply).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload8_reply).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload8_reply).word6)) << 32));
        msg[4] = (((_binding->tx_union).fsb_payload8_reply).word7);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload8_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload8_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload16_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 72;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0,ArgFieldFragment int32 [NamedField "word8"] 0],[ArgFieldFragment int32 [NamedField "word9"] 0,ArgFieldFragment int32 [NamedField "word10"] 0],[ArgFieldFragment int32 [NamedField "word11"] 0,ArgFieldFragment int32 [NamedField "word12"] 0],[ArgFieldFragment int32 [NamedField "word13"] 0,ArgFieldFragment int32 [NamedField "word14"] 0],[ArgFieldFragment int32 [NamedField "word15"] 0]]
        msg[0] = (bench_fsb_payload16_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload16_request).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload16_request).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload16_request).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word6)) << 32));
        msg[4] = ((((_binding->tx_union).fsb_payload16_request).word7) | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word8)) << 32));
        msg[5] = ((((_binding->tx_union).fsb_payload16_request).word9) | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word10)) << 32));
        msg[6] = ((((_binding->tx_union).fsb_payload16_request).word11) | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word12)) << 32));
        msg[7] = ((((_binding->tx_union).fsb_payload16_request).word13) | (((uint64_t )(((_binding->tx_union).fsb_payload16_request).word14)) << 32));
        msg[8] = (((_binding->tx_union).fsb_payload16_request).word15);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload16_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload16_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload16_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 72;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0,ArgFieldFragment int32 [NamedField "word8"] 0],[ArgFieldFragment int32 [NamedField "word9"] 0,ArgFieldFragment int32 [NamedField "word10"] 0],[ArgFieldFragment int32 [NamedField "word11"] 0,ArgFieldFragment int32 [NamedField "word12"] 0],[ArgFieldFragment int32 [NamedField "word13"] 0,ArgFieldFragment int32 [NamedField "word14"] 0],[ArgFieldFragment int32 [NamedField "word15"] 0]]
        msg[0] = (bench_fsb_payload16_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload16_reply).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload16_reply).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload16_reply).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word6)) << 32));
        msg[4] = ((((_binding->tx_union).fsb_payload16_reply).word7) | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word8)) << 32));
        msg[5] = ((((_binding->tx_union).fsb_payload16_reply).word9) | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word10)) << 32));
        msg[6] = ((((_binding->tx_union).fsb_payload16_reply).word11) | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word12)) << 32));
        msg[7] = ((((_binding->tx_union).fsb_payload16_reply).word13) | (((uint64_t )(((_binding->tx_union).fsb_payload16_reply).word14)) << 32));
        msg[8] = (((_binding->tx_union).fsb_payload16_reply).word15);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload16_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload16_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_1_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0]]
        msg[0] = (bench_fsb_payload32_1_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_1_request).word0)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_1_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_1_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_1_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0]]
        msg[0] = (bench_fsb_payload32_1_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_1_reply).word0)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_1_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_1_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_1_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 16;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0]]
        msg[0] = bench_fsb_payload64_1_request__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_1_request).word0);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_1_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_1_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_1_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 16;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0]]
        msg[0] = bench_fsb_payload64_1_reply__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_1_reply).word0);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_1_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_1_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_2_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 16;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0]]
        msg[0] = (bench_fsb_payload32_2_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_2_request).word0)) << 16));
        msg[1] = (((_binding->tx_union).fsb_payload32_2_request).word1);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_2_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_2_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_2_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 16;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0]]
        msg[0] = (bench_fsb_payload32_2_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_2_reply).word0)) << 16));
        msg[1] = (((_binding->tx_union).fsb_payload32_2_reply).word1);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_2_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_2_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_2_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 24;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0]]
        msg[0] = bench_fsb_payload64_2_request__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_2_request).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_2_request).word1);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_2_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_2_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_2_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 24;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0]]
        msg[0] = bench_fsb_payload64_2_reply__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_2_reply).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_2_reply).word1);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_2_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_2_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_4_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 24;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0]]
        msg[0] = (bench_fsb_payload32_4_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_4_request).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload32_4_request).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload32_4_request).word2)) << 32));
        msg[2] = (((_binding->tx_union).fsb_payload32_4_request).word3);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_4_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_4_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_4_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 24;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0]]
        msg[0] = (bench_fsb_payload32_4_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_4_reply).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload32_4_reply).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload32_4_reply).word2)) << 32));
        msg[2] = (((_binding->tx_union).fsb_payload32_4_reply).word3);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_4_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_4_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_4_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 40;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0],[ArgFieldFragment int64 [NamedField "word2"] 0],[ArgFieldFragment int64 [NamedField "word3"] 0]]
        msg[0] = bench_fsb_payload64_4_request__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_4_request).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_4_request).word1);
        msg[3] = (((_binding->tx_union).fsb_payload64_4_request).word2);
        msg[4] = (((_binding->tx_union).fsb_payload64_4_request).word3);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_4_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_4_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_4_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 40;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0],[ArgFieldFragment int64 [NamedField "word2"] 0],[ArgFieldFragment int64 [NamedField "word3"] 0]]
        msg[0] = bench_fsb_payload64_4_reply__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_4_reply).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_4_reply).word1);
        msg[3] = (((_binding->tx_union).fsb_payload64_4_reply).word2);
        msg[4] = (((_binding->tx_union).fsb_payload64_4_reply).word3);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_4_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_4_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_8_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 40;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0]]
        msg[0] = (bench_fsb_payload32_8_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_request).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload32_8_request).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_request).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload32_8_request).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_request).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload32_8_request).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_request).word6)) << 32));
        msg[4] = (((_binding->tx_union).fsb_payload32_8_request).word7);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_8_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_8_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_8_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 40;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0]]
        msg[0] = (bench_fsb_payload32_8_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_reply).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload32_8_reply).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_reply).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload32_8_reply).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_reply).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload32_8_reply).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload32_8_reply).word6)) << 32));
        msg[4] = (((_binding->tx_union).fsb_payload32_8_reply).word7);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_8_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_8_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_8_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 72;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0],[ArgFieldFragment int64 [NamedField "word2"] 0],[ArgFieldFragment int64 [NamedField "word3"] 0],[ArgFieldFragment int64 [NamedField "word4"] 0],[ArgFieldFragment int64 [NamedField "word5"] 0],[ArgFieldFragment int64 [NamedField "word6"] 0],[ArgFieldFragment int64 [NamedField "word7"] 0]]
        msg[0] = bench_fsb_payload64_8_request__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_8_request).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_8_request).word1);
        msg[3] = (((_binding->tx_union).fsb_payload64_8_request).word2);
        msg[4] = (((_binding->tx_union).fsb_payload64_8_request).word3);
        msg[5] = (((_binding->tx_union).fsb_payload64_8_request).word4);
        msg[6] = (((_binding->tx_union).fsb_payload64_8_request).word5);
        msg[7] = (((_binding->tx_union).fsb_payload64_8_request).word6);
        msg[8] = (((_binding->tx_union).fsb_payload64_8_request).word7);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_8_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_8_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_8_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 72;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0],[ArgFieldFragment int64 [NamedField "word2"] 0],[ArgFieldFragment int64 [NamedField "word3"] 0],[ArgFieldFragment int64 [NamedField "word4"] 0],[ArgFieldFragment int64 [NamedField "word5"] 0],[ArgFieldFragment int64 [NamedField "word6"] 0],[ArgFieldFragment int64 [NamedField "word7"] 0]]
        msg[0] = bench_fsb_payload64_8_reply__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_8_reply).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_8_reply).word1);
        msg[3] = (((_binding->tx_union).fsb_payload64_8_reply).word2);
        msg[4] = (((_binding->tx_union).fsb_payload64_8_reply).word3);
        msg[5] = (((_binding->tx_union).fsb_payload64_8_reply).word4);
        msg[6] = (((_binding->tx_union).fsb_payload64_8_reply).word5);
        msg[7] = (((_binding->tx_union).fsb_payload64_8_reply).word6);
        msg[8] = (((_binding->tx_union).fsb_payload64_8_reply).word7);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_8_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_8_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_16_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 72;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0,ArgFieldFragment int32 [NamedField "word8"] 0],[ArgFieldFragment int32 [NamedField "word9"] 0,ArgFieldFragment int32 [NamedField "word10"] 0],[ArgFieldFragment int32 [NamedField "word11"] 0,ArgFieldFragment int32 [NamedField "word12"] 0],[ArgFieldFragment int32 [NamedField "word13"] 0,ArgFieldFragment int32 [NamedField "word14"] 0],[ArgFieldFragment int32 [NamedField "word15"] 0]]
        msg[0] = (bench_fsb_payload32_16_request__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload32_16_request).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload32_16_request).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload32_16_request).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word6)) << 32));
        msg[4] = ((((_binding->tx_union).fsb_payload32_16_request).word7) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word8)) << 32));
        msg[5] = ((((_binding->tx_union).fsb_payload32_16_request).word9) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word10)) << 32));
        msg[6] = ((((_binding->tx_union).fsb_payload32_16_request).word11) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word12)) << 32));
        msg[7] = ((((_binding->tx_union).fsb_payload32_16_request).word13) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_request).word14)) << 32));
        msg[8] = (((_binding->tx_union).fsb_payload32_16_request).word15);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_16_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_16_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload32_16_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 72;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment int32 [NamedField "word0"] 0],[ArgFieldFragment int32 [NamedField "word1"] 0,ArgFieldFragment int32 [NamedField "word2"] 0],[ArgFieldFragment int32 [NamedField "word3"] 0,ArgFieldFragment int32 [NamedField "word4"] 0],[ArgFieldFragment int32 [NamedField "word5"] 0,ArgFieldFragment int32 [NamedField "word6"] 0],[ArgFieldFragment int32 [NamedField "word7"] 0,ArgFieldFragment int32 [NamedField "word8"] 0],[ArgFieldFragment int32 [NamedField "word9"] 0,ArgFieldFragment int32 [NamedField "word10"] 0],[ArgFieldFragment int32 [NamedField "word11"] 0,ArgFieldFragment int32 [NamedField "word12"] 0],[ArgFieldFragment int32 [NamedField "word13"] 0,ArgFieldFragment int32 [NamedField "word14"] 0],[ArgFieldFragment int32 [NamedField "word15"] 0]]
        msg[0] = (bench_fsb_payload32_16_reply__msgnum | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word0)) << 16));
        msg[1] = ((((_binding->tx_union).fsb_payload32_16_reply).word1) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word2)) << 32));
        msg[2] = ((((_binding->tx_union).fsb_payload32_16_reply).word3) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word4)) << 32));
        msg[3] = ((((_binding->tx_union).fsb_payload32_16_reply).word5) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word6)) << 32));
        msg[4] = ((((_binding->tx_union).fsb_payload32_16_reply).word7) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word8)) << 32));
        msg[5] = ((((_binding->tx_union).fsb_payload32_16_reply).word9) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word10)) << 32));
        msg[6] = ((((_binding->tx_union).fsb_payload32_16_reply).word11) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word12)) << 32));
        msg[7] = ((((_binding->tx_union).fsb_payload32_16_reply).word13) | (((uint64_t )(((_binding->tx_union).fsb_payload32_16_reply).word14)) << 32));
        msg[8] = (((_binding->tx_union).fsb_payload32_16_reply).word15);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload32_16_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload32_16_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_16_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 136;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0],[ArgFieldFragment int64 [NamedField "word2"] 0],[ArgFieldFragment int64 [NamedField "word3"] 0],[ArgFieldFragment int64 [NamedField "word4"] 0],[ArgFieldFragment int64 [NamedField "word5"] 0],[ArgFieldFragment int64 [NamedField "word6"] 0],[ArgFieldFragment int64 [NamedField "word7"] 0],[ArgFieldFragment int64 [NamedField "word8"] 0],[ArgFieldFragment int64 [NamedField "word9"] 0],[ArgFieldFragment int64 [NamedField "word10"] 0],[ArgFieldFragment int64 [NamedField "word11"] 0],[ArgFieldFragment int64 [NamedField "word12"] 0],[ArgFieldFragment int64 [NamedField "word13"] 0],[ArgFieldFragment int64 [NamedField "word14"] 0],[ArgFieldFragment int64 [NamedField "word15"] 0]]
        msg[0] = bench_fsb_payload64_16_request__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_16_request).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_16_request).word1);
        msg[3] = (((_binding->tx_union).fsb_payload64_16_request).word2);
        msg[4] = (((_binding->tx_union).fsb_payload64_16_request).word3);
        msg[5] = (((_binding->tx_union).fsb_payload64_16_request).word4);
        msg[6] = (((_binding->tx_union).fsb_payload64_16_request).word5);
        msg[7] = (((_binding->tx_union).fsb_payload64_16_request).word6);
        msg[8] = (((_binding->tx_union).fsb_payload64_16_request).word7);
        msg[9] = (((_binding->tx_union).fsb_payload64_16_request).word8);
        msg[10] = (((_binding->tx_union).fsb_payload64_16_request).word9);
        msg[11] = (((_binding->tx_union).fsb_payload64_16_request).word10);
        msg[12] = (((_binding->tx_union).fsb_payload64_16_request).word11);
        msg[13] = (((_binding->tx_union).fsb_payload64_16_request).word12);
        msg[14] = (((_binding->tx_union).fsb_payload64_16_request).word13);
        msg[15] = (((_binding->tx_union).fsb_payload64_16_request).word14);
        msg[16] = (((_binding->tx_union).fsb_payload64_16_request).word15);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_16_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_16_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_fsb_payload64_16_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 136;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment int64 [NamedField "word0"] 0],[ArgFieldFragment int64 [NamedField "word1"] 0],[ArgFieldFragment int64 [NamedField "word2"] 0],[ArgFieldFragment int64 [NamedField "word3"] 0],[ArgFieldFragment int64 [NamedField "word4"] 0],[ArgFieldFragment int64 [NamedField "word5"] 0],[ArgFieldFragment int64 [NamedField "word6"] 0],[ArgFieldFragment int64 [NamedField "word7"] 0],[ArgFieldFragment int64 [NamedField "word8"] 0],[ArgFieldFragment int64 [NamedField "word9"] 0],[ArgFieldFragment int64 [NamedField "word10"] 0],[ArgFieldFragment int64 [NamedField "word11"] 0],[ArgFieldFragment int64 [NamedField "word12"] 0],[ArgFieldFragment int64 [NamedField "word13"] 0],[ArgFieldFragment int64 [NamedField "word14"] 0],[ArgFieldFragment int64 [NamedField "word15"] 0]]
        msg[0] = bench_fsb_payload64_16_reply__msgnum;
        msg[1] = (((_binding->tx_union).fsb_payload64_16_reply).word0);
        msg[2] = (((_binding->tx_union).fsb_payload64_16_reply).word1);
        msg[3] = (((_binding->tx_union).fsb_payload64_16_reply).word2);
        msg[4] = (((_binding->tx_union).fsb_payload64_16_reply).word3);
        msg[5] = (((_binding->tx_union).fsb_payload64_16_reply).word4);
        msg[6] = (((_binding->tx_union).fsb_payload64_16_reply).word5);
        msg[7] = (((_binding->tx_union).fsb_payload64_16_reply).word6);
        msg[8] = (((_binding->tx_union).fsb_payload64_16_reply).word7);
        msg[9] = (((_binding->tx_union).fsb_payload64_16_reply).word8);
        msg[10] = (((_binding->tx_union).fsb_payload64_16_reply).word9);
        msg[11] = (((_binding->tx_union).fsb_payload64_16_reply).word10);
        msg[12] = (((_binding->tx_union).fsb_payload64_16_reply).word11);
        msg[13] = (((_binding->tx_union).fsb_payload64_16_reply).word12);
        msg[14] = (((_binding->tx_union).fsb_payload64_16_reply).word13);
        msg[15] = (((_binding->tx_union).fsb_payload64_16_reply).word14);
        msg[16] = (((_binding->tx_union).fsb_payload64_16_reply).word15);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_fsb_payload64_16_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_fsb_payload64_16_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_lrpc_init__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_lrpc_init__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_lrpc_init__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_lrpc_init__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_lrpc_init_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_lrpc_init_reply__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_lrpc_init_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_lrpc_init_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_lrpc_bench_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 16;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode],[ArgFieldFragment uint64 [NamedField "value"] 0]]
        msg[0] = bench_lrpc_bench_reply__msgnum;
        msg[1] = (((_binding->tx_union).lrpc_bench_reply).value);
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_lrpc_bench_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_lrpc_bench_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_shmc_init_request__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode,ArgFieldFragment uint8 [NamedField "coreid"] 0]]
        msg[0] = (bench_shmc_init_request__msgnum | (((uint64_t )(((_binding->tx_union).shmc_init_request).coreid)) << 16));
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_shmc_init_request__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_shmc_init_request__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_shmc_init_reply__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_shmc_init_reply__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_shmc_init_reply__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_shmc_init_reply__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        free(mb->message);
        // send caps
        bench_multihop_cap_send_handler(mb);
        return;
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_shmc_start__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_shmc_start__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_shmc_start__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_shmc_start__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}

static  void bench_shmc_done__multihop_send_handler(void *arg)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    errval_t err = SYS_ERR_OK;
    uint64_t *msg;
    uint64_t msg_size;
    
    
    // Switch on current outgoing message fragment
    switch (_binding->tx_msg_fragment) {
    case 0:
        // Calculate size of message & allocate it
        msg_size = 8;
        assert(msg_size != 0);
        msg = malloc(msg_size);
        
        // copy words from fixed size fragments
        // [[MsgCode]]
        msg[0] = bench_shmc_done__msgnum;
        
        
        // copy strings
        
        // copy buffers
        
        // try to send!
        (_binding->tx_msg_fragment)++;
        mb->message = msg;
        err = multihop_send_message(&(mb->chan), MKCONT(bench_shmc_done__multihop_send_handler, _binding), msg, msg_size);
        if (err_no(err) == FLOUNDER_ERR_TX_BUSY) {
            (_binding->tx_msg_fragment)--;
            err = multihop_chan_register_send(&(mb->chan), _binding->waitset, MKCONT(bench_shmc_done__multihop_send_handler, _binding));
            assert(err_is_ok(err));
        }
        if (err_is_fail(err)) {
            break;
        } else {
            return;
        }
    case 1:
        // all fragments are sent
        free(mb->message);
        if (multihop_chan_is_window_full(&(mb->chan))) {
            mb->trigger_chan = true;
            return;
        } else {
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
            return;
        }
    default:
        assert(!("invalid fragment"));
        err = FLOUNDER_ERR_INVALID_STATE;
    }
    
    
    // Report error to user
    (_binding->error_handler)(_binding, err);
    _binding->tx_msgnum = 0;
    flounder_support_trigger_chan(&(_binding->register_chanstate));
    flounder_support_deregister_chan(&(_binding->tx_cont_chanstate));
}


/*
 * Cap receive handlers
 */
 void bench_multihop_caps_rx_handler(void *arg, errval_t success, struct capref cap, uint32_t capid)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    
    assert(capid == ((mb->capst).rx_capnum));
    
    // Check if there's an associated error
    // FIXME: how should we report this to the user? at present we just deliver a NULL capref
    if (err_is_fail(success)) {
        DEBUG_ERR(success, "could not send cap over multihop channel");
    }
    
    // Switch on current incoming message
    switch (_binding->rx_msgnum) {
    case bench_shmc_init_reply__msgnum:
        // Switch on current incoming cap
        switch (((mb->capst).rx_capnum)++) {
        case 0:
            ((_binding->rx_union).shmc_init_reply).cap = cap;
            if (mb->trigger_chan) {
                mb->trigger_chan = false;
                _binding->tx_msgnum = 0;
                flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
                flounder_support_trigger_chan(&(_binding->register_chanstate));
            }
            FL_DEBUG("multihop RX bench.shmc_init_reply\n");
            assert(((_binding->rx_vtbl).shmc_init_reply) != NULL);
            ((_binding->rx_vtbl).shmc_init_reply)(_binding, ((_binding->rx_union).shmc_init_reply).cap);
            _binding->rx_msgnum = 0;
            break;
        default:
            assert(!("invalid cap number"));
            (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
        }
        break;
    default:
        assert(!("invalid message number"));
        (_binding->error_handler)(_binding, FLOUNDER_ERR_INVALID_STATE);
    }
}


/*
 * Message sender functions
 */
static  errval_t bench_init_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).init_request).coreid = coreid;
    FL_DEBUG("multihop TX bench.init_request\n");
    
    // try to send!
    bench_init_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_init_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.init_reply\n");
    
    // try to send!
    bench_init_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_token_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_token_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.token_request\n");
    
    // try to send!
    bench_token_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_token_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_token_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.token_reply\n");
    
    // try to send!
    bench_token_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_init_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_busy_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.busy_init_request\n");
    
    // try to send!
    bench_busy_init_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_init_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_busy_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.busy_init_reply\n");
    
    // try to send!
    bench_busy_init_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_busy_ping__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_busy_ping__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.busy_ping\n");
    
    // try to send!
    bench_busy_ping__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_ump_init_msg__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_ump_init_msg__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).ump_init_msg).coreid = coreid;
    FL_DEBUG("multihop TX bench.ump_init_msg\n");
    
    // try to send!
    bench_ump_init_msg__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_init_msg__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_init_msg__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_init_msg).coreid = coreid;
    FL_DEBUG("multihop TX bench.fsb_init_msg\n");
    
    // try to send!
    bench_fsb_init_msg__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_empty_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_empty_request__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.fsb_empty_request\n");
    
    // try to send!
    bench_fsb_empty_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_empty_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_empty_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.fsb_empty_reply\n");
    
    // try to send!
    bench_fsb_empty_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_buffer_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, const uint8_t *buf, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_buffer_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_buffer_request).buf = ((uint8_t *)(buf));
    ((_binding->tx_union).fsb_buffer_request).size = size;
    FL_DEBUG("multihop TX bench.fsb_buffer_request\n");
    
    // try to send!
    bench_fsb_buffer_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_buffer_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, const uint8_t *buf, size_t size)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_buffer_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_buffer_reply).buf = ((uint8_t *)(buf));
    ((_binding->tx_union).fsb_buffer_reply).size = size;
    FL_DEBUG("multihop TX bench.fsb_buffer_reply\n");
    
    // try to send!
    bench_fsb_buffer_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload_request).word0 = word0;
    ((_binding->tx_union).fsb_payload_request).word1 = word1;
    ((_binding->tx_union).fsb_payload_request).word2 = word2;
    ((_binding->tx_union).fsb_payload_request).word3 = word3;
    FL_DEBUG("multihop TX bench.fsb_payload_request\n");
    
    // try to send!
    bench_fsb_payload_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload_reply).word3 = word3;
    FL_DEBUG("multihop TX bench.fsb_payload_reply\n");
    
    // try to send!
    bench_fsb_payload_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload1_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload1_request).word0 = word0;
    FL_DEBUG("multihop TX bench.fsb_payload1_request\n");
    
    // try to send!
    bench_fsb_payload1_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload1_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload1_reply).word0 = word0;
    FL_DEBUG("multihop TX bench.fsb_payload1_reply\n");
    
    // try to send!
    bench_fsb_payload1_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload2_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload2_request).word1 = word1;
    FL_DEBUG("multihop TX bench.fsb_payload2_request\n");
    
    // try to send!
    bench_fsb_payload2_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload2_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload2_reply).word1 = word1;
    FL_DEBUG("multihop TX bench.fsb_payload2_reply\n");
    
    // try to send!
    bench_fsb_payload2_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload8_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload8_request).word7 = word7;
    FL_DEBUG("multihop TX bench.fsb_payload8_request\n");
    
    // try to send!
    bench_fsb_payload8_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload8_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload8_reply).word7 = word7;
    FL_DEBUG("multihop TX bench.fsb_payload8_reply\n");
    
    // try to send!
    bench_fsb_payload8_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload16_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload16_request).word15 = word15;
    FL_DEBUG("multihop TX bench.fsb_payload16_request\n");
    
    // try to send!
    bench_fsb_payload16_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload16_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload16_reply).word15 = word15;
    FL_DEBUG("multihop TX bench.fsb_payload16_reply\n");
    
    // try to send!
    bench_fsb_payload16_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_1_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_1_request).word0 = word0;
    FL_DEBUG("multihop TX bench.fsb_payload32_1_request\n");
    
    // try to send!
    bench_fsb_payload32_1_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_1_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_1_reply).word0 = word0;
    FL_DEBUG("multihop TX bench.fsb_payload32_1_reply\n");
    
    // try to send!
    bench_fsb_payload32_1_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_1_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_1_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_1_request).word0 = word0;
    FL_DEBUG("multihop TX bench.fsb_payload64_1_request\n");
    
    // try to send!
    bench_fsb_payload64_1_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_1_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_1_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_1_reply).word0 = word0;
    FL_DEBUG("multihop TX bench.fsb_payload64_1_reply\n");
    
    // try to send!
    bench_fsb_payload64_1_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_2_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_2_request).word1 = word1;
    FL_DEBUG("multihop TX bench.fsb_payload32_2_request\n");
    
    // try to send!
    bench_fsb_payload32_2_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_2_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_2_reply).word1 = word1;
    FL_DEBUG("multihop TX bench.fsb_payload32_2_reply\n");
    
    // try to send!
    bench_fsb_payload32_2_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_2_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_2_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_2_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_2_request).word1 = word1;
    FL_DEBUG("multihop TX bench.fsb_payload64_2_request\n");
    
    // try to send!
    bench_fsb_payload64_2_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_2_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_2_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_2_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_2_reply).word1 = word1;
    FL_DEBUG("multihop TX bench.fsb_payload64_2_reply\n");
    
    // try to send!
    bench_fsb_payload64_2_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_4_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_4_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_4_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_4_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_4_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_4_request).word3 = word3;
    FL_DEBUG("multihop TX bench.fsb_payload32_4_request\n");
    
    // try to send!
    bench_fsb_payload32_4_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_4_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_4_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_4_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_4_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_4_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_4_reply).word3 = word3;
    FL_DEBUG("multihop TX bench.fsb_payload32_4_reply\n");
    
    // try to send!
    bench_fsb_payload32_4_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_4_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_4_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_4_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_4_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_4_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_4_request).word3 = word3;
    FL_DEBUG("multihop TX bench.fsb_payload64_4_request\n");
    
    // try to send!
    bench_fsb_payload64_4_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_4_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_4_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_4_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_4_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_4_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_4_reply).word3 = word3;
    FL_DEBUG("multihop TX bench.fsb_payload64_4_reply\n");
    
    // try to send!
    bench_fsb_payload64_4_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_8_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload32_8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload32_8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload32_8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload32_8_request).word7 = word7;
    FL_DEBUG("multihop TX bench.fsb_payload32_8_request\n");
    
    // try to send!
    bench_fsb_payload32_8_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_8_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload32_8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload32_8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload32_8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload32_8_reply).word7 = word7;
    FL_DEBUG("multihop TX bench.fsb_payload32_8_reply\n");
    
    // try to send!
    bench_fsb_payload32_8_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_8_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_8_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_8_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_8_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_8_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_8_request).word3 = word3;
    ((_binding->tx_union).fsb_payload64_8_request).word4 = word4;
    ((_binding->tx_union).fsb_payload64_8_request).word5 = word5;
    ((_binding->tx_union).fsb_payload64_8_request).word6 = word6;
    ((_binding->tx_union).fsb_payload64_8_request).word7 = word7;
    FL_DEBUG("multihop TX bench.fsb_payload64_8_request\n");
    
    // try to send!
    bench_fsb_payload64_8_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_8_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_8_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_8_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_8_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_8_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_8_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload64_8_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload64_8_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload64_8_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload64_8_reply).word7 = word7;
    FL_DEBUG("multihop TX bench.fsb_payload64_8_reply\n");
    
    // try to send!
    bench_fsb_payload64_8_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_16_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload32_16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload32_16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload32_16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload32_16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload32_16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload32_16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload32_16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload32_16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload32_16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload32_16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload32_16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload32_16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload32_16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload32_16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload32_16_request).word15 = word15;
    FL_DEBUG("multihop TX bench.fsb_payload32_16_request\n");
    
    // try to send!
    bench_fsb_payload32_16_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload32_16_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int32_t word0, int32_t word1, int32_t word2, int32_t word3, int32_t word4, int32_t word5, int32_t word6, int32_t word7, int32_t word8, int32_t word9, int32_t word10, int32_t word11, int32_t word12, int32_t word13, int32_t word14, int32_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload32_16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload32_16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload32_16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload32_16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload32_16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload32_16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload32_16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload32_16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload32_16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload32_16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload32_16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload32_16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload32_16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload32_16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload32_16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload32_16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload32_16_reply).word15 = word15;
    FL_DEBUG("multihop TX bench.fsb_payload32_16_reply\n");
    
    // try to send!
    bench_fsb_payload32_16_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_16_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7, int64_t word8, int64_t word9, int64_t word10, int64_t word11, int64_t word12, int64_t word13, int64_t word14, int64_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_16_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_16_request).word0 = word0;
    ((_binding->tx_union).fsb_payload64_16_request).word1 = word1;
    ((_binding->tx_union).fsb_payload64_16_request).word2 = word2;
    ((_binding->tx_union).fsb_payload64_16_request).word3 = word3;
    ((_binding->tx_union).fsb_payload64_16_request).word4 = word4;
    ((_binding->tx_union).fsb_payload64_16_request).word5 = word5;
    ((_binding->tx_union).fsb_payload64_16_request).word6 = word6;
    ((_binding->tx_union).fsb_payload64_16_request).word7 = word7;
    ((_binding->tx_union).fsb_payload64_16_request).word8 = word8;
    ((_binding->tx_union).fsb_payload64_16_request).word9 = word9;
    ((_binding->tx_union).fsb_payload64_16_request).word10 = word10;
    ((_binding->tx_union).fsb_payload64_16_request).word11 = word11;
    ((_binding->tx_union).fsb_payload64_16_request).word12 = word12;
    ((_binding->tx_union).fsb_payload64_16_request).word13 = word13;
    ((_binding->tx_union).fsb_payload64_16_request).word14 = word14;
    ((_binding->tx_union).fsb_payload64_16_request).word15 = word15;
    FL_DEBUG("multihop TX bench.fsb_payload64_16_request\n");
    
    // try to send!
    bench_fsb_payload64_16_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_fsb_payload64_16_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, int64_t word0, int64_t word1, int64_t word2, int64_t word3, int64_t word4, int64_t word5, int64_t word6, int64_t word7, int64_t word8, int64_t word9, int64_t word10, int64_t word11, int64_t word12, int64_t word13, int64_t word14, int64_t word15)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_fsb_payload64_16_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).fsb_payload64_16_reply).word0 = word0;
    ((_binding->tx_union).fsb_payload64_16_reply).word1 = word1;
    ((_binding->tx_union).fsb_payload64_16_reply).word2 = word2;
    ((_binding->tx_union).fsb_payload64_16_reply).word3 = word3;
    ((_binding->tx_union).fsb_payload64_16_reply).word4 = word4;
    ((_binding->tx_union).fsb_payload64_16_reply).word5 = word5;
    ((_binding->tx_union).fsb_payload64_16_reply).word6 = word6;
    ((_binding->tx_union).fsb_payload64_16_reply).word7 = word7;
    ((_binding->tx_union).fsb_payload64_16_reply).word8 = word8;
    ((_binding->tx_union).fsb_payload64_16_reply).word9 = word9;
    ((_binding->tx_union).fsb_payload64_16_reply).word10 = word10;
    ((_binding->tx_union).fsb_payload64_16_reply).word11 = word11;
    ((_binding->tx_union).fsb_payload64_16_reply).word12 = word12;
    ((_binding->tx_union).fsb_payload64_16_reply).word13 = word13;
    ((_binding->tx_union).fsb_payload64_16_reply).word14 = word14;
    ((_binding->tx_union).fsb_payload64_16_reply).word15 = word15;
    FL_DEBUG("multihop TX bench.fsb_payload64_16_reply\n");
    
    // try to send!
    bench_fsb_payload64_16_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_init__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_lrpc_init__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.lrpc_init\n");
    
    // try to send!
    bench_lrpc_init__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_init_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_lrpc_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.lrpc_init_reply\n");
    
    // try to send!
    bench_lrpc_init_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_lrpc_bench_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, uint64_t value)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_lrpc_bench_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).lrpc_bench_reply).value = value;
    FL_DEBUG("multihop TX bench.lrpc_bench_reply\n");
    
    // try to send!
    bench_lrpc_bench_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_init_request__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, uint8_t coreid)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_shmc_init_request__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).shmc_init_request).coreid = coreid;
    FL_DEBUG("multihop TX bench.shmc_init_request\n");
    
    // try to send!
    bench_shmc_init_request__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_init_reply__multihop_send(struct bench_binding *_binding, struct event_closure _continuation, struct capref cap)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_shmc_init_reply__msgnum;
    _binding->tx_msg_fragment = 0;
    ((_binding->tx_union).shmc_init_reply).cap = cap;
    FL_DEBUG("multihop TX bench.shmc_init_reply\n");
    
    // try to send!
    bench_shmc_init_reply__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_start__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_shmc_start__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.shmc_start\n");
    
    // try to send!
    bench_shmc_start__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}

static  errval_t bench_shmc_done__multihop_send(struct bench_binding *_binding, struct event_closure _continuation)
{
    // check that we can accept an outgoing message
    if ((_binding->tx_msgnum) != 0) {
        return(FLOUNDER_ERR_TX_BUSY);
    }
    
    // register send continuation
    if ((_continuation.handler) != NULL) {
        errval_t _err;
        _err = flounder_support_register(_binding->waitset, &(_binding->tx_cont_chanstate), _continuation, false);
        // may fail if previous continuation hasn't fired yet
        if (err_is_fail(_err)) {
            if (err_no(_err) == LIB_ERR_CHAN_ALREADY_REGISTERED) {
                return(FLOUNDER_ERR_TX_BUSY);
            } else {
                assert(!("shouldn't happen"));
                return(_err);
            }
        }
    }
    
    // store message number and the arguments
    _binding->tx_msgnum = bench_shmc_done__msgnum;
    _binding->tx_msg_fragment = 0;
    FL_DEBUG("multihop TX bench.shmc_done\n");
    
    // try to send!
    bench_shmc_done__multihop_send_handler(_binding);
    
    return(SYS_ERR_OK);
}


/*
 * Send vtable
 */
static  struct bench_tx_vtbl bench_multihop_tx_vtbl = {
    .init_request = bench_init_request__multihop_send,
    .init_reply = bench_init_reply__multihop_send,
    .token_request = bench_token_request__multihop_send,
    .token_reply = bench_token_reply__multihop_send,
    .busy_init_request = bench_busy_init_request__multihop_send,
    .busy_init_reply = bench_busy_init_reply__multihop_send,
    .busy_ping = bench_busy_ping__multihop_send,
    .ump_init_msg = bench_ump_init_msg__multihop_send,
    .fsb_init_msg = bench_fsb_init_msg__multihop_send,
    .fsb_empty_request = bench_fsb_empty_request__multihop_send,
    .fsb_empty_reply = bench_fsb_empty_reply__multihop_send,
    .fsb_buffer_request = bench_fsb_buffer_request__multihop_send,
    .fsb_buffer_reply = bench_fsb_buffer_reply__multihop_send,
    .fsb_payload_request = bench_fsb_payload_request__multihop_send,
    .fsb_payload_reply = bench_fsb_payload_reply__multihop_send,
    .fsb_payload1_request = bench_fsb_payload1_request__multihop_send,
    .fsb_payload1_reply = bench_fsb_payload1_reply__multihop_send,
    .fsb_payload2_request = bench_fsb_payload2_request__multihop_send,
    .fsb_payload2_reply = bench_fsb_payload2_reply__multihop_send,
    .fsb_payload8_request = bench_fsb_payload8_request__multihop_send,
    .fsb_payload8_reply = bench_fsb_payload8_reply__multihop_send,
    .fsb_payload16_request = bench_fsb_payload16_request__multihop_send,
    .fsb_payload16_reply = bench_fsb_payload16_reply__multihop_send,
    .fsb_payload32_1_request = bench_fsb_payload32_1_request__multihop_send,
    .fsb_payload32_1_reply = bench_fsb_payload32_1_reply__multihop_send,
    .fsb_payload64_1_request = bench_fsb_payload64_1_request__multihop_send,
    .fsb_payload64_1_reply = bench_fsb_payload64_1_reply__multihop_send,
    .fsb_payload32_2_request = bench_fsb_payload32_2_request__multihop_send,
    .fsb_payload32_2_reply = bench_fsb_payload32_2_reply__multihop_send,
    .fsb_payload64_2_request = bench_fsb_payload64_2_request__multihop_send,
    .fsb_payload64_2_reply = bench_fsb_payload64_2_reply__multihop_send,
    .fsb_payload32_4_request = bench_fsb_payload32_4_request__multihop_send,
    .fsb_payload32_4_reply = bench_fsb_payload32_4_reply__multihop_send,
    .fsb_payload64_4_request = bench_fsb_payload64_4_request__multihop_send,
    .fsb_payload64_4_reply = bench_fsb_payload64_4_reply__multihop_send,
    .fsb_payload32_8_request = bench_fsb_payload32_8_request__multihop_send,
    .fsb_payload32_8_reply = bench_fsb_payload32_8_reply__multihop_send,
    .fsb_payload64_8_request = bench_fsb_payload64_8_request__multihop_send,
    .fsb_payload64_8_reply = bench_fsb_payload64_8_reply__multihop_send,
    .fsb_payload32_16_request = bench_fsb_payload32_16_request__multihop_send,
    .fsb_payload32_16_reply = bench_fsb_payload32_16_reply__multihop_send,
    .fsb_payload64_16_request = bench_fsb_payload64_16_request__multihop_send,
    .fsb_payload64_16_reply = bench_fsb_payload64_16_reply__multihop_send,
    .lrpc_init = bench_lrpc_init__multihop_send,
    .lrpc_init_reply = bench_lrpc_init_reply__multihop_send,
    .lrpc_bench_reply = bench_lrpc_bench_reply__multihop_send,
    .shmc_init_request = bench_shmc_init_request__multihop_send,
    .shmc_init_reply = bench_shmc_init_reply__multihop_send,
    .shmc_start = bench_shmc_start__multihop_send,
    .shmc_done = bench_shmc_done__multihop_send,
};
/*
 * Receive handler
 */
 void bench_multihop_rx_handler(void *arg, uint8_t *message, size_t message_len)
{
    // Get the binding state from our argument pointer
    struct bench_binding *_binding = arg;
    struct bench_multihop_binding *mb = arg;
    
    uint64_t o_frag_size;
    uint8_t *msg;
    
    // if this a dummy message?
    if (message_len == 0) {
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        return;
    }
    // is this the start of a new message?
    if ((_binding->rx_msgnum) == 0) {
        // unmarshall message number from first word, set fragment to 0
        _binding->rx_msgnum = ((message[0]) & 0xffff);
        _binding->rx_msg_fragment = 0;
        (mb->capst).rx_capnum = 0;
    } else {
        assert(!"should not happen");
    }
    
    // switch on message number
    switch (_binding->rx_msgnum) {
    case bench_init_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).init_request).coreid = (((((uint64_t *)(message))[0]) >> 16) & 0xff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.init_request\n");
        assert(((_binding->rx_vtbl).init_request) != NULL);
        ((_binding->rx_vtbl).init_request)(_binding, ((_binding->rx_union).init_request).coreid);
        _binding->rx_msgnum = 0;
        break;
    case bench_init_reply__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.init_reply\n");
        assert(((_binding->rx_vtbl).init_reply) != NULL);
        ((_binding->rx_vtbl).init_reply)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_token_request__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.token_request\n");
        assert(((_binding->rx_vtbl).token_request) != NULL);
        ((_binding->rx_vtbl).token_request)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_token_reply__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.token_reply\n");
        assert(((_binding->rx_vtbl).token_reply) != NULL);
        ((_binding->rx_vtbl).token_reply)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_busy_init_request__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.busy_init_request\n");
        assert(((_binding->rx_vtbl).busy_init_request) != NULL);
        ((_binding->rx_vtbl).busy_init_request)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_busy_init_reply__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.busy_init_reply\n");
        assert(((_binding->rx_vtbl).busy_init_reply) != NULL);
        ((_binding->rx_vtbl).busy_init_reply)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_busy_ping__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.busy_ping\n");
        assert(((_binding->rx_vtbl).busy_ping) != NULL);
        ((_binding->rx_vtbl).busy_ping)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_ump_init_msg__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).ump_init_msg).coreid = (((((uint64_t *)(message))[0]) >> 16) & 0xff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.ump_init_msg\n");
        assert(((_binding->rx_vtbl).ump_init_msg) != NULL);
        ((_binding->rx_vtbl).ump_init_msg)(_binding, ((_binding->rx_union).ump_init_msg).coreid);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_init_msg__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_init_msg).coreid = (((((uint64_t *)(message))[0]) >> 16) & 0xff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_init_msg\n");
        assert(((_binding->rx_vtbl).fsb_init_msg) != NULL);
        ((_binding->rx_vtbl).fsb_init_msg)(_binding, ((_binding->rx_union).fsb_init_msg).coreid);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_empty_request__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_empty_request\n");
        assert(((_binding->rx_vtbl).fsb_empty_request) != NULL);
        ((_binding->rx_vtbl).fsb_empty_request)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_empty_reply__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_empty_reply\n");
        assert(((_binding->rx_vtbl).fsb_empty_reply) != NULL);
        ((_binding->rx_vtbl).fsb_empty_reply)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_buffer_request__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        o_frag_size = 0;
        memcpy(&o_frag_size, msg, 8);
        ((_binding->rx_union).fsb_buffer_request).buf = malloc(o_frag_size);
        memcpy(((_binding->rx_union).fsb_buffer_request).buf, msg + 8, o_frag_size);
        ((_binding->rx_union).fsb_buffer_request).size = ((size_t )(o_frag_size));
        msg = ((msg + o_frag_size) + 8);
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_buffer_request\n");
        assert(((_binding->rx_vtbl).fsb_buffer_request) != NULL);
        ((_binding->rx_vtbl).fsb_buffer_request)(_binding, ((_binding->rx_union).fsb_buffer_request).buf, ((_binding->rx_union).fsb_buffer_request).size);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_buffer_reply__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        o_frag_size = 0;
        memcpy(&o_frag_size, msg, 8);
        ((_binding->rx_union).fsb_buffer_reply).buf = malloc(o_frag_size);
        memcpy(((_binding->rx_union).fsb_buffer_reply).buf, msg + 8, o_frag_size);
        ((_binding->rx_union).fsb_buffer_reply).size = ((size_t )(o_frag_size));
        msg = ((msg + o_frag_size) + 8);
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_buffer_reply\n");
        assert(((_binding->rx_vtbl).fsb_buffer_reply) != NULL);
        ((_binding->rx_vtbl).fsb_buffer_reply)(_binding, ((_binding->rx_union).fsb_buffer_reply).buf, ((_binding->rx_union).fsb_buffer_reply).size);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload_request).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload_request).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        msg = (message + 24);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload_request\n");
        assert(((_binding->rx_vtbl).fsb_payload_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload_request)(_binding, ((_binding->rx_union).fsb_payload_request).word0, ((_binding->rx_union).fsb_payload_request).word1, ((_binding->rx_union).fsb_payload_request).word2, ((_binding->rx_union).fsb_payload_request).word3);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload_reply).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload_reply).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        msg = (message + 24);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload_reply)(_binding, ((_binding->rx_union).fsb_payload_reply).word0, ((_binding->rx_union).fsb_payload_reply).word1, ((_binding->rx_union).fsb_payload_reply).word2, ((_binding->rx_union).fsb_payload_reply).word3);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload1_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload1_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload1_request\n");
        assert(((_binding->rx_vtbl).fsb_payload1_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload1_request)(_binding, ((_binding->rx_union).fsb_payload1_request).word0);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload1_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload1_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload1_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload1_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload1_reply)(_binding, ((_binding->rx_union).fsb_payload1_reply).word0);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload2_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload2_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload2_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        msg = (message + 16);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload2_request\n");
        assert(((_binding->rx_vtbl).fsb_payload2_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload2_request)(_binding, ((_binding->rx_union).fsb_payload2_request).word0, ((_binding->rx_union).fsb_payload2_request).word1);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload2_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload2_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload2_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        msg = (message + 16);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload2_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload2_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload2_reply)(_binding, ((_binding->rx_union).fsb_payload2_reply).word0, ((_binding->rx_union).fsb_payload2_reply).word1);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload8_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload8_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_request).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_request).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_request).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_request).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_request).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_request).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        msg = (message + 40);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload8_request\n");
        assert(((_binding->rx_vtbl).fsb_payload8_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload8_request)(_binding, ((_binding->rx_union).fsb_payload8_request).word0, ((_binding->rx_union).fsb_payload8_request).word1, ((_binding->rx_union).fsb_payload8_request).word2, ((_binding->rx_union).fsb_payload8_request).word3, ((_binding->rx_union).fsb_payload8_request).word4, ((_binding->rx_union).fsb_payload8_request).word5, ((_binding->rx_union).fsb_payload8_request).word6, ((_binding->rx_union).fsb_payload8_request).word7);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload8_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload8_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_reply).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_reply).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_reply).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_reply).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_reply).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload8_reply).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        msg = (message + 40);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload8_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload8_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload8_reply)(_binding, ((_binding->rx_union).fsb_payload8_reply).word0, ((_binding->rx_union).fsb_payload8_reply).word1, ((_binding->rx_union).fsb_payload8_reply).word2, ((_binding->rx_union).fsb_payload8_reply).word3, ((_binding->rx_union).fsb_payload8_reply).word4, ((_binding->rx_union).fsb_payload8_reply).word5, ((_binding->rx_union).fsb_payload8_reply).word6, ((_binding->rx_union).fsb_payload8_reply).word7);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload16_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload16_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word8 = (((((uint64_t *)(message))[4]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word9 = ((((uint64_t *)(message))[5]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word10 = (((((uint64_t *)(message))[5]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word11 = ((((uint64_t *)(message))[6]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word12 = (((((uint64_t *)(message))[6]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word13 = ((((uint64_t *)(message))[7]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word14 = (((((uint64_t *)(message))[7]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_request).word15 = ((((uint64_t *)(message))[8]) & 0xffffffff);
        msg = (message + 72);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload16_request\n");
        assert(((_binding->rx_vtbl).fsb_payload16_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload16_request)(_binding, ((_binding->rx_union).fsb_payload16_request).word0, ((_binding->rx_union).fsb_payload16_request).word1, ((_binding->rx_union).fsb_payload16_request).word2, ((_binding->rx_union).fsb_payload16_request).word3, ((_binding->rx_union).fsb_payload16_request).word4, ((_binding->rx_union).fsb_payload16_request).word5, ((_binding->rx_union).fsb_payload16_request).word6, ((_binding->rx_union).fsb_payload16_request).word7, ((_binding->rx_union).fsb_payload16_request).word8, ((_binding->rx_union).fsb_payload16_request).word9, ((_binding->rx_union).fsb_payload16_request).word10, ((_binding->rx_union).fsb_payload16_request).word11, ((_binding->rx_union).fsb_payload16_request).word12, ((_binding->rx_union).fsb_payload16_request).word13, ((_binding->rx_union).fsb_payload16_request).word14, ((_binding->rx_union).fsb_payload16_request).word15);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload16_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload16_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word8 = (((((uint64_t *)(message))[4]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word9 = ((((uint64_t *)(message))[5]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word10 = (((((uint64_t *)(message))[5]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word11 = ((((uint64_t *)(message))[6]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word12 = (((((uint64_t *)(message))[6]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word13 = ((((uint64_t *)(message))[7]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word14 = (((((uint64_t *)(message))[7]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload16_reply).word15 = ((((uint64_t *)(message))[8]) & 0xffffffff);
        msg = (message + 72);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload16_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload16_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload16_reply)(_binding, ((_binding->rx_union).fsb_payload16_reply).word0, ((_binding->rx_union).fsb_payload16_reply).word1, ((_binding->rx_union).fsb_payload16_reply).word2, ((_binding->rx_union).fsb_payload16_reply).word3, ((_binding->rx_union).fsb_payload16_reply).word4, ((_binding->rx_union).fsb_payload16_reply).word5, ((_binding->rx_union).fsb_payload16_reply).word6, ((_binding->rx_union).fsb_payload16_reply).word7, ((_binding->rx_union).fsb_payload16_reply).word8, ((_binding->rx_union).fsb_payload16_reply).word9, ((_binding->rx_union).fsb_payload16_reply).word10, ((_binding->rx_union).fsb_payload16_reply).word11, ((_binding->rx_union).fsb_payload16_reply).word12, ((_binding->rx_union).fsb_payload16_reply).word13, ((_binding->rx_union).fsb_payload16_reply).word14, ((_binding->rx_union).fsb_payload16_reply).word15);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_1_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_1_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_1_request\n");
        assert(((_binding->rx_vtbl).fsb_payload32_1_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_1_request)(_binding, ((_binding->rx_union).fsb_payload32_1_request).word0);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_1_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_1_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_1_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload32_1_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_1_reply)(_binding, ((_binding->rx_union).fsb_payload32_1_reply).word0);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_1_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_1_request).word0 = (((uint64_t *)(message))[1]);
        msg = (message + 16);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_1_request\n");
        assert(((_binding->rx_vtbl).fsb_payload64_1_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_1_request)(_binding, ((_binding->rx_union).fsb_payload64_1_request).word0);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_1_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_1_reply).word0 = (((uint64_t *)(message))[1]);
        msg = (message + 16);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_1_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload64_1_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_1_reply)(_binding, ((_binding->rx_union).fsb_payload64_1_reply).word0);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_2_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_2_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_2_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        msg = (message + 16);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_2_request\n");
        assert(((_binding->rx_vtbl).fsb_payload32_2_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_2_request)(_binding, ((_binding->rx_union).fsb_payload32_2_request).word0, ((_binding->rx_union).fsb_payload32_2_request).word1);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_2_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_2_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_2_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        msg = (message + 16);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_2_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload32_2_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_2_reply)(_binding, ((_binding->rx_union).fsb_payload32_2_reply).word0, ((_binding->rx_union).fsb_payload32_2_reply).word1);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_2_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_2_request).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_2_request).word1 = (((uint64_t *)(message))[2]);
        msg = (message + 24);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_2_request\n");
        assert(((_binding->rx_vtbl).fsb_payload64_2_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_2_request)(_binding, ((_binding->rx_union).fsb_payload64_2_request).word0, ((_binding->rx_union).fsb_payload64_2_request).word1);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_2_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_2_reply).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_2_reply).word1 = (((uint64_t *)(message))[2]);
        msg = (message + 24);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_2_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload64_2_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_2_reply)(_binding, ((_binding->rx_union).fsb_payload64_2_reply).word0, ((_binding->rx_union).fsb_payload64_2_reply).word1);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_4_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_4_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_4_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_4_request).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_4_request).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        msg = (message + 24);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_4_request\n");
        assert(((_binding->rx_vtbl).fsb_payload32_4_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_4_request)(_binding, ((_binding->rx_union).fsb_payload32_4_request).word0, ((_binding->rx_union).fsb_payload32_4_request).word1, ((_binding->rx_union).fsb_payload32_4_request).word2, ((_binding->rx_union).fsb_payload32_4_request).word3);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_4_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_4_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_4_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_4_reply).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_4_reply).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        msg = (message + 24);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_4_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload32_4_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_4_reply)(_binding, ((_binding->rx_union).fsb_payload32_4_reply).word0, ((_binding->rx_union).fsb_payload32_4_reply).word1, ((_binding->rx_union).fsb_payload32_4_reply).word2, ((_binding->rx_union).fsb_payload32_4_reply).word3);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_4_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_4_request).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_4_request).word1 = (((uint64_t *)(message))[2]);
        ((_binding->rx_union).fsb_payload64_4_request).word2 = (((uint64_t *)(message))[3]);
        ((_binding->rx_union).fsb_payload64_4_request).word3 = (((uint64_t *)(message))[4]);
        msg = (message + 40);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_4_request\n");
        assert(((_binding->rx_vtbl).fsb_payload64_4_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_4_request)(_binding, ((_binding->rx_union).fsb_payload64_4_request).word0, ((_binding->rx_union).fsb_payload64_4_request).word1, ((_binding->rx_union).fsb_payload64_4_request).word2, ((_binding->rx_union).fsb_payload64_4_request).word3);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_4_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_4_reply).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_4_reply).word1 = (((uint64_t *)(message))[2]);
        ((_binding->rx_union).fsb_payload64_4_reply).word2 = (((uint64_t *)(message))[3]);
        ((_binding->rx_union).fsb_payload64_4_reply).word3 = (((uint64_t *)(message))[4]);
        msg = (message + 40);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_4_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload64_4_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_4_reply)(_binding, ((_binding->rx_union).fsb_payload64_4_reply).word0, ((_binding->rx_union).fsb_payload64_4_reply).word1, ((_binding->rx_union).fsb_payload64_4_reply).word2, ((_binding->rx_union).fsb_payload64_4_reply).word3);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_8_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_8_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_request).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_request).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_request).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_request).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_request).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_request).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        msg = (message + 40);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_8_request\n");
        assert(((_binding->rx_vtbl).fsb_payload32_8_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_8_request)(_binding, ((_binding->rx_union).fsb_payload32_8_request).word0, ((_binding->rx_union).fsb_payload32_8_request).word1, ((_binding->rx_union).fsb_payload32_8_request).word2, ((_binding->rx_union).fsb_payload32_8_request).word3, ((_binding->rx_union).fsb_payload32_8_request).word4, ((_binding->rx_union).fsb_payload32_8_request).word5, ((_binding->rx_union).fsb_payload32_8_request).word6, ((_binding->rx_union).fsb_payload32_8_request).word7);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_8_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_8_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_reply).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_reply).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_reply).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_reply).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_reply).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_8_reply).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        msg = (message + 40);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_8_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload32_8_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_8_reply)(_binding, ((_binding->rx_union).fsb_payload32_8_reply).word0, ((_binding->rx_union).fsb_payload32_8_reply).word1, ((_binding->rx_union).fsb_payload32_8_reply).word2, ((_binding->rx_union).fsb_payload32_8_reply).word3, ((_binding->rx_union).fsb_payload32_8_reply).word4, ((_binding->rx_union).fsb_payload32_8_reply).word5, ((_binding->rx_union).fsb_payload32_8_reply).word6, ((_binding->rx_union).fsb_payload32_8_reply).word7);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_8_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_8_request).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_8_request).word1 = (((uint64_t *)(message))[2]);
        ((_binding->rx_union).fsb_payload64_8_request).word2 = (((uint64_t *)(message))[3]);
        ((_binding->rx_union).fsb_payload64_8_request).word3 = (((uint64_t *)(message))[4]);
        ((_binding->rx_union).fsb_payload64_8_request).word4 = (((uint64_t *)(message))[5]);
        ((_binding->rx_union).fsb_payload64_8_request).word5 = (((uint64_t *)(message))[6]);
        ((_binding->rx_union).fsb_payload64_8_request).word6 = (((uint64_t *)(message))[7]);
        ((_binding->rx_union).fsb_payload64_8_request).word7 = (((uint64_t *)(message))[8]);
        msg = (message + 72);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_8_request\n");
        assert(((_binding->rx_vtbl).fsb_payload64_8_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_8_request)(_binding, ((_binding->rx_union).fsb_payload64_8_request).word0, ((_binding->rx_union).fsb_payload64_8_request).word1, ((_binding->rx_union).fsb_payload64_8_request).word2, ((_binding->rx_union).fsb_payload64_8_request).word3, ((_binding->rx_union).fsb_payload64_8_request).word4, ((_binding->rx_union).fsb_payload64_8_request).word5, ((_binding->rx_union).fsb_payload64_8_request).word6, ((_binding->rx_union).fsb_payload64_8_request).word7);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_8_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_8_reply).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_8_reply).word1 = (((uint64_t *)(message))[2]);
        ((_binding->rx_union).fsb_payload64_8_reply).word2 = (((uint64_t *)(message))[3]);
        ((_binding->rx_union).fsb_payload64_8_reply).word3 = (((uint64_t *)(message))[4]);
        ((_binding->rx_union).fsb_payload64_8_reply).word4 = (((uint64_t *)(message))[5]);
        ((_binding->rx_union).fsb_payload64_8_reply).word5 = (((uint64_t *)(message))[6]);
        ((_binding->rx_union).fsb_payload64_8_reply).word6 = (((uint64_t *)(message))[7]);
        ((_binding->rx_union).fsb_payload64_8_reply).word7 = (((uint64_t *)(message))[8]);
        msg = (message + 72);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_8_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload64_8_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_8_reply)(_binding, ((_binding->rx_union).fsb_payload64_8_reply).word0, ((_binding->rx_union).fsb_payload64_8_reply).word1, ((_binding->rx_union).fsb_payload64_8_reply).word2, ((_binding->rx_union).fsb_payload64_8_reply).word3, ((_binding->rx_union).fsb_payload64_8_reply).word4, ((_binding->rx_union).fsb_payload64_8_reply).word5, ((_binding->rx_union).fsb_payload64_8_reply).word6, ((_binding->rx_union).fsb_payload64_8_reply).word7);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_16_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_16_request).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word8 = (((((uint64_t *)(message))[4]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word9 = ((((uint64_t *)(message))[5]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word10 = (((((uint64_t *)(message))[5]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word11 = ((((uint64_t *)(message))[6]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word12 = (((((uint64_t *)(message))[6]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word13 = ((((uint64_t *)(message))[7]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word14 = (((((uint64_t *)(message))[7]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_request).word15 = ((((uint64_t *)(message))[8]) & 0xffffffff);
        msg = (message + 72);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_16_request\n");
        assert(((_binding->rx_vtbl).fsb_payload32_16_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_16_request)(_binding, ((_binding->rx_union).fsb_payload32_16_request).word0, ((_binding->rx_union).fsb_payload32_16_request).word1, ((_binding->rx_union).fsb_payload32_16_request).word2, ((_binding->rx_union).fsb_payload32_16_request).word3, ((_binding->rx_union).fsb_payload32_16_request).word4, ((_binding->rx_union).fsb_payload32_16_request).word5, ((_binding->rx_union).fsb_payload32_16_request).word6, ((_binding->rx_union).fsb_payload32_16_request).word7, ((_binding->rx_union).fsb_payload32_16_request).word8, ((_binding->rx_union).fsb_payload32_16_request).word9, ((_binding->rx_union).fsb_payload32_16_request).word10, ((_binding->rx_union).fsb_payload32_16_request).word11, ((_binding->rx_union).fsb_payload32_16_request).word12, ((_binding->rx_union).fsb_payload32_16_request).word13, ((_binding->rx_union).fsb_payload32_16_request).word14, ((_binding->rx_union).fsb_payload32_16_request).word15);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload32_16_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload32_16_reply).word0 = (((((uint64_t *)(message))[0]) >> 16) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word1 = ((((uint64_t *)(message))[1]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word2 = (((((uint64_t *)(message))[1]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word3 = ((((uint64_t *)(message))[2]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word4 = (((((uint64_t *)(message))[2]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word5 = ((((uint64_t *)(message))[3]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word6 = (((((uint64_t *)(message))[3]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word7 = ((((uint64_t *)(message))[4]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word8 = (((((uint64_t *)(message))[4]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word9 = ((((uint64_t *)(message))[5]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word10 = (((((uint64_t *)(message))[5]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word11 = ((((uint64_t *)(message))[6]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word12 = (((((uint64_t *)(message))[6]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word13 = ((((uint64_t *)(message))[7]) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word14 = (((((uint64_t *)(message))[7]) >> 32) & 0xffffffff);
        ((_binding->rx_union).fsb_payload32_16_reply).word15 = ((((uint64_t *)(message))[8]) & 0xffffffff);
        msg = (message + 72);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload32_16_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload32_16_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload32_16_reply)(_binding, ((_binding->rx_union).fsb_payload32_16_reply).word0, ((_binding->rx_union).fsb_payload32_16_reply).word1, ((_binding->rx_union).fsb_payload32_16_reply).word2, ((_binding->rx_union).fsb_payload32_16_reply).word3, ((_binding->rx_union).fsb_payload32_16_reply).word4, ((_binding->rx_union).fsb_payload32_16_reply).word5, ((_binding->rx_union).fsb_payload32_16_reply).word6, ((_binding->rx_union).fsb_payload32_16_reply).word7, ((_binding->rx_union).fsb_payload32_16_reply).word8, ((_binding->rx_union).fsb_payload32_16_reply).word9, ((_binding->rx_union).fsb_payload32_16_reply).word10, ((_binding->rx_union).fsb_payload32_16_reply).word11, ((_binding->rx_union).fsb_payload32_16_reply).word12, ((_binding->rx_union).fsb_payload32_16_reply).word13, ((_binding->rx_union).fsb_payload32_16_reply).word14, ((_binding->rx_union).fsb_payload32_16_reply).word15);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_16_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_16_request).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_16_request).word1 = (((uint64_t *)(message))[2]);
        ((_binding->rx_union).fsb_payload64_16_request).word2 = (((uint64_t *)(message))[3]);
        ((_binding->rx_union).fsb_payload64_16_request).word3 = (((uint64_t *)(message))[4]);
        ((_binding->rx_union).fsb_payload64_16_request).word4 = (((uint64_t *)(message))[5]);
        ((_binding->rx_union).fsb_payload64_16_request).word5 = (((uint64_t *)(message))[6]);
        ((_binding->rx_union).fsb_payload64_16_request).word6 = (((uint64_t *)(message))[7]);
        ((_binding->rx_union).fsb_payload64_16_request).word7 = (((uint64_t *)(message))[8]);
        ((_binding->rx_union).fsb_payload64_16_request).word8 = (((uint64_t *)(message))[9]);
        ((_binding->rx_union).fsb_payload64_16_request).word9 = (((uint64_t *)(message))[10]);
        ((_binding->rx_union).fsb_payload64_16_request).word10 = (((uint64_t *)(message))[11]);
        ((_binding->rx_union).fsb_payload64_16_request).word11 = (((uint64_t *)(message))[12]);
        ((_binding->rx_union).fsb_payload64_16_request).word12 = (((uint64_t *)(message))[13]);
        ((_binding->rx_union).fsb_payload64_16_request).word13 = (((uint64_t *)(message))[14]);
        ((_binding->rx_union).fsb_payload64_16_request).word14 = (((uint64_t *)(message))[15]);
        ((_binding->rx_union).fsb_payload64_16_request).word15 = (((uint64_t *)(message))[16]);
        msg = (message + 136);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_16_request\n");
        assert(((_binding->rx_vtbl).fsb_payload64_16_request) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_16_request)(_binding, ((_binding->rx_union).fsb_payload64_16_request).word0, ((_binding->rx_union).fsb_payload64_16_request).word1, ((_binding->rx_union).fsb_payload64_16_request).word2, ((_binding->rx_union).fsb_payload64_16_request).word3, ((_binding->rx_union).fsb_payload64_16_request).word4, ((_binding->rx_union).fsb_payload64_16_request).word5, ((_binding->rx_union).fsb_payload64_16_request).word6, ((_binding->rx_union).fsb_payload64_16_request).word7, ((_binding->rx_union).fsb_payload64_16_request).word8, ((_binding->rx_union).fsb_payload64_16_request).word9, ((_binding->rx_union).fsb_payload64_16_request).word10, ((_binding->rx_union).fsb_payload64_16_request).word11, ((_binding->rx_union).fsb_payload64_16_request).word12, ((_binding->rx_union).fsb_payload64_16_request).word13, ((_binding->rx_union).fsb_payload64_16_request).word14, ((_binding->rx_union).fsb_payload64_16_request).word15);
        _binding->rx_msgnum = 0;
        break;
    case bench_fsb_payload64_16_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).fsb_payload64_16_reply).word0 = (((uint64_t *)(message))[1]);
        ((_binding->rx_union).fsb_payload64_16_reply).word1 = (((uint64_t *)(message))[2]);
        ((_binding->rx_union).fsb_payload64_16_reply).word2 = (((uint64_t *)(message))[3]);
        ((_binding->rx_union).fsb_payload64_16_reply).word3 = (((uint64_t *)(message))[4]);
        ((_binding->rx_union).fsb_payload64_16_reply).word4 = (((uint64_t *)(message))[5]);
        ((_binding->rx_union).fsb_payload64_16_reply).word5 = (((uint64_t *)(message))[6]);
        ((_binding->rx_union).fsb_payload64_16_reply).word6 = (((uint64_t *)(message))[7]);
        ((_binding->rx_union).fsb_payload64_16_reply).word7 = (((uint64_t *)(message))[8]);
        ((_binding->rx_union).fsb_payload64_16_reply).word8 = (((uint64_t *)(message))[9]);
        ((_binding->rx_union).fsb_payload64_16_reply).word9 = (((uint64_t *)(message))[10]);
        ((_binding->rx_union).fsb_payload64_16_reply).word10 = (((uint64_t *)(message))[11]);
        ((_binding->rx_union).fsb_payload64_16_reply).word11 = (((uint64_t *)(message))[12]);
        ((_binding->rx_union).fsb_payload64_16_reply).word12 = (((uint64_t *)(message))[13]);
        ((_binding->rx_union).fsb_payload64_16_reply).word13 = (((uint64_t *)(message))[14]);
        ((_binding->rx_union).fsb_payload64_16_reply).word14 = (((uint64_t *)(message))[15]);
        ((_binding->rx_union).fsb_payload64_16_reply).word15 = (((uint64_t *)(message))[16]);
        msg = (message + 136);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.fsb_payload64_16_reply\n");
        assert(((_binding->rx_vtbl).fsb_payload64_16_reply) != NULL);
        ((_binding->rx_vtbl).fsb_payload64_16_reply)(_binding, ((_binding->rx_union).fsb_payload64_16_reply).word0, ((_binding->rx_union).fsb_payload64_16_reply).word1, ((_binding->rx_union).fsb_payload64_16_reply).word2, ((_binding->rx_union).fsb_payload64_16_reply).word3, ((_binding->rx_union).fsb_payload64_16_reply).word4, ((_binding->rx_union).fsb_payload64_16_reply).word5, ((_binding->rx_union).fsb_payload64_16_reply).word6, ((_binding->rx_union).fsb_payload64_16_reply).word7, ((_binding->rx_union).fsb_payload64_16_reply).word8, ((_binding->rx_union).fsb_payload64_16_reply).word9, ((_binding->rx_union).fsb_payload64_16_reply).word10, ((_binding->rx_union).fsb_payload64_16_reply).word11, ((_binding->rx_union).fsb_payload64_16_reply).word12, ((_binding->rx_union).fsb_payload64_16_reply).word13, ((_binding->rx_union).fsb_payload64_16_reply).word14, ((_binding->rx_union).fsb_payload64_16_reply).word15);
        _binding->rx_msgnum = 0;
        break;
    case bench_lrpc_init__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.lrpc_init\n");
        assert(((_binding->rx_vtbl).lrpc_init) != NULL);
        ((_binding->rx_vtbl).lrpc_init)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_lrpc_init_reply__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.lrpc_init_reply\n");
        assert(((_binding->rx_vtbl).lrpc_init_reply) != NULL);
        ((_binding->rx_vtbl).lrpc_init_reply)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_lrpc_bench_reply__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).lrpc_bench_reply).value = (((uint64_t *)(message))[1]);
        msg = (message + 16);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.lrpc_bench_reply\n");
        assert(((_binding->rx_vtbl).lrpc_bench_reply) != NULL);
        ((_binding->rx_vtbl).lrpc_bench_reply)(_binding, ((_binding->rx_union).lrpc_bench_reply).value);
        _binding->rx_msgnum = 0;
        break;
    case bench_shmc_init_request__msgnum:
        // store fixed size fragments
        ((_binding->rx_union).shmc_init_request).coreid = (((((uint64_t *)(message))[0]) >> 16) & 0xff);
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.shmc_init_request\n");
        assert(((_binding->rx_vtbl).shmc_init_request) != NULL);
        ((_binding->rx_vtbl).shmc_init_request)(_binding, ((_binding->rx_union).shmc_init_request).coreid);
        _binding->rx_msgnum = 0;
        break;
    case bench_shmc_init_reply__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        (_binding->rx_msg_fragment)++;
        break;
    case bench_shmc_start__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.shmc_start\n");
        assert(((_binding->rx_vtbl).shmc_start) != NULL);
        ((_binding->rx_vtbl).shmc_start)(_binding);
        _binding->rx_msgnum = 0;
        break;
    case bench_shmc_done__msgnum:
        // store fixed size fragments
        msg = (message + 8);
        
        // receive strings
        
        // receive buffers
        
        free(message);
        if (mb->trigger_chan) {
            mb->trigger_chan = false;
            _binding->tx_msgnum = 0;
            flounder_support_trigger_chan(&(_binding->tx_cont_chanstate));
            flounder_support_trigger_chan(&(_binding->register_chanstate));
        }
        FL_DEBUG("multihop RX bench.shmc_done\n");
        assert(((_binding->rx_vtbl).shmc_done) != NULL);
        ((_binding->rx_vtbl).shmc_done)(_binding);
        _binding->rx_msgnum = 0;
        break;
    default:
        (_binding->error_handler)(_binding, FLOUNDER_ERR_RX_INVALID_MSGNUM);
        return;
    }
}


/*
 * Control functions
 */
static  bool bench_multihop_can_send(struct bench_binding *b)
{
    struct bench_multihop_binding *mb = (struct bench_multihop_binding *)(b);
    return(((b->tx_msgnum) == 0) && (!multihop_chan_is_window_full(&(mb->chan))));
}

static  errval_t bench_multihop_register_send(struct bench_binding *b, struct waitset *ws, struct event_closure _continuation)
{
    return(flounder_support_register(ws, &(b->register_chanstate), _continuation, bench_multihop_can_send(b)));
}

static  void bench_multihop_default_error_handler(struct bench_binding *b, errval_t err)
{
    DEBUG_ERR(err, "asynchronous error in Flounder-generated bench multihop binding (default handler)");
    abort();
}

static  errval_t bench_multihop_change_waitset(struct bench_binding *_binding, struct waitset *ws)
{
    struct bench_multihop_binding *mb = (void *)(_binding);
    
    // change waitset on binding
    _binding->waitset = ws;
    
    // change waitset on multi-hop channel
    return(multihop_chan_change_waitset(&(mb->chan), ws));
}

static  errval_t bench_multihop_control(struct bench_binding *_binding, idc_control_t control)
{
    // No control flags supported
    return(SYS_ERR_OK);
}

/*
 * Functions to initialise/destroy the binding state
 */
 void bench_multihop_init(struct bench_multihop_binding *mb, struct waitset *waitset)
{
    (mb->b).st = NULL;
    (mb->b).waitset = waitset;
    event_mutex_init(&((mb->b).mutex), waitset);
    (mb->b).can_send = bench_multihop_can_send;
    (mb->b).register_send = bench_multihop_register_send;
    (mb->b).error_handler = bench_multihop_default_error_handler;
    (mb->b).tx_vtbl = bench_multihop_tx_vtbl;
    memset(&((mb->b).rx_vtbl), 0, sizeof((mb->b).rx_vtbl));
    flounder_support_waitset_chanstate_init(&((mb->b).register_chanstate));
    flounder_support_waitset_chanstate_init(&((mb->b).tx_cont_chanstate));
    (mb->b).tx_msgnum = 0;
    (mb->b).rx_msgnum = 0;
    (mb->b).tx_msg_fragment = 0;
    (mb->b).rx_msg_fragment = 0;
    (mb->b).tx_str_pos = 0;
    (mb->b).rx_str_pos = 0;
    (mb->b).tx_str_len = 0;
    (mb->b).rx_str_len = 0;
    (mb->b).bind_cont = NULL;
    (mb->b).change_waitset = bench_multihop_change_waitset;
    (mb->b).control = bench_multihop_control;
    mb->trigger_chan = false;
}

 void bench_multihop_destroy(struct bench_multihop_binding *mb)
{
    flounder_support_waitset_chanstate_destroy(&((mb->b).register_chanstate));
    flounder_support_waitset_chanstate_destroy(&((mb->b).tx_cont_chanstate));
    assert(! "NYI!");
}


/*
 * Bind function
 */
static  void bench_multihop_bind_continuation(void *st, errval_t err, struct multihop_chan *chan)
{
    struct bench_multihop_binding *mb = st;
    
    if (err_is_ok(err)) {
        // set receive handlers
        multihop_chan_set_receive_handler(&(mb->chan), (struct multihop_receive_handler){  .handler = bench_multihop_rx_handler,  .arg = st });
        multihop_chan_set_caps_receive_handlers(&(mb->chan), (struct monitor_cap_handlers){  .st = st,  .cap_receive_handler = bench_multihop_caps_rx_handler });
    } else {
        bench_multihop_destroy(mb);
    }
    
    ((mb->b).bind_cont)((mb->b).st, err, &(mb->b));
}

 errval_t bench_multihop_bind(struct bench_multihop_binding *mb, iref_t iref, bench_bind_continuation_fn *_continuation, void *st, struct waitset *waitset, idc_bind_flags_t flags)
{
    errval_t err;
    bench_multihop_init(mb, waitset);
    (mb->b).st = st;
    (mb->b).bind_cont = _continuation;
    err = multihop_chan_bind(&(mb->chan), (struct multihop_bind_continuation){  .handler = bench_multihop_bind_continuation,  .st = mb }, iref, waitset);
    if (err_is_fail(err)) {
        bench_multihop_destroy(mb);
    }
    return(err);
}


/*
 * Connect callback for export
 */
 errval_t bench_multihop_connect_handler(void *st, multihop_vci_t vci)
{
    struct bench_export *e = st;
    errval_t err;
    
    // allocate storage for binding
    struct bench_multihop_binding *mb = malloc(sizeof(struct bench_multihop_binding ));
    if (mb == NULL) {
        return(LIB_ERR_MALLOC_FAIL);
    }
    
    // initialize binding
    struct bench_binding *_binding = &(mb->b);
    bench_multihop_init(mb, e->waitset);
    (mb->chan).vci = vci;
    
    // run user's connect handler
    err = ((e->connect_cb)(e->st, _binding));
    if (err_is_fail(err)) {
        return(err);
    }
    
    // set receive handlers
    multihop_chan_set_receive_handler(&(mb->chan), (struct multihop_receive_handler){  .handler = bench_multihop_rx_handler,  .arg = mb });
    multihop_chan_set_caps_receive_handlers(&(mb->chan), (struct monitor_cap_handlers){  .st = mb,  .cap_receive_handler = bench_multihop_caps_rx_handler });
    
    // send back bind reply
    multihop_chan_send_bind_reply(&(mb->chan), SYS_ERR_OK, (mb->chan).vci, (mb->b).waitset);
    
    return(err);
}

#endif // CONFIG_FLOUNDER_BACKEND_MULTIHOP
